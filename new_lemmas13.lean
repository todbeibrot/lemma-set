import imports
lemma new_lemma_104000 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (dlist.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (dlist.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_104001 (h0 h1 : pnat) : pnat.coprime (id h0) h1 := sorry --non-trivial
lemma new_lemma_104002 (h0 : topological_space (mul_zero_class unsigned)) : totally_disconnected_space (mul_zero_class unsigned) := sorry --non-trivial
lemma new_lemma_104003 (h0 : enat -> char) (h1 : char) : set.range h0 h1 := sorry --non-trivial
lemma new_lemma_104004 (h0 : topological_space (distrib (comm_ring char))) : t0_space (distrib (comm_ring char)) := sorry --non-trivial
lemma new_lemma_104005 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_abs.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_abs.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_104006 (h0 : topological_space (normed_lattice_add_comm_group (has_scalar Type pos))) : loc_path_connected_space (normed_lattice_add_comm_group (has_scalar Type pos)) := sorry --non-trivial
lemma new_lemma_104007 (h0 : function.extfun Type (functor.comp add_group canonically_ordered_comm_semiring)) : @is_add_cyclic.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.comp.run.{0 0 0} add_group.{0} canonically_ordered_comm_semiring.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} add_group.{0} canonically_ordered_comm_semiring.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_104008 (h0 : functor.add_const (cancel_comm_monoid_with_zero (semigroup unsigned)) unsigned) : @unique_factorization_monoid.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (semigroup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_104009 (h0 : functor.add_const (topological_space (normed_comm_ring ennreal)) unsigned) : @loc_path_connected_space.{0} (normed_comm_ring.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_104010 (h0 : group (has_add (comm_group (option (has_add (has_add name)))))) : group.fg (has_add (comm_group (option (has_add (has_add name))))) := sorry --non-trivial
lemma new_lemma_104011 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc num))) : @normalizer_condition.{0} (has_emptyc.{0} num) (@finset.pi.empty.{1 0} Type group.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_104012 (h0 : topological_space (linear_ordered_semiring (random_gen (has_norm fun_info)))) : discrete_topology (linear_ordered_semiring (random_gen (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_104013 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_104014 (h0 : topological_space (id (metric_space num))) : totally_separated_space (id (metric_space num)) := sorry --non-trivial
lemma new_lemma_104015 (h0 : topological_space (normed_comm_ring (finset (finset pos)))) : t0_space (normed_comm_ring (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_104016 (h0 : functor.add_const (topological_space (add_group unsigned)) unsigned) : @path_connected_space.{0} (add_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_104017 (h0 : functor.add_const (topological_space (canonically_ordered_add_monoid empty)) empty) : @loc_path_connected_space.{0} (canonically_ordered_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_add_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_104018 (h1 : ring (has_ssubset (mul_one_class reducibility_hints))) : is_domain (has_ssubset (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_104019 (h0 : option (option num) -> option (option num) -> Prop) : total h0 := sorry --non-trivial
lemma new_lemma_104020 (h0 : topological_space (normed_group real)) : irreducible_space (normed_group real) := sorry --non-trivial
lemma new_lemma_104021 (h0 : ring (pseudo_metric_space name)) : strong_rank_condition (pseudo_metric_space name) := sorry --non-trivial
lemma new_lemma_104022 (h0 : add_group (measure_theory.measure_space to_additive.value_type)) : is_add_cyclic (measure_theory.measure_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_104023 (h0 : topological_space (add_comm_semigroup char)) (h2 : preorder (add_comm_semigroup char) -> char) (h3 : coe_sort (set.range h2)) : @order_closed_topology.{0} (add_comm_semigroup.{0} char) h0 (@set.range_splitting.{0 0} (preorder.{0} (add_comm_semigroup.{0} char)) char h2 h3)  := sorry --non-trivial
lemma new_lemma_104024 (h0 : topological_space (comm_group (ring (ring Type)))) : t0_space (comm_group (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_104025 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_104026 (h0 : functor.add_const (filter Type) (has_Inf Type)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_104027 (h0 : fin has_zero.zero) : @separated_space.{1} (has_Inf.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (has_Inf.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_104028 (h0 : functor.add_const (topological_space (ring pos)) pos) : @totally_disconnected_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_104029 (h0 : complete_lattice (monoid_with_zero (option (option pos)))) : is_atomistic (monoid_with_zero (option (option pos))) := sorry --non-trivial
lemma new_lemma_104030 (h0 : topological_space (semigroup (mul_one_class (has_add (has_zero linarith.comp))))) : t1_space (semigroup (mul_one_class (has_add (has_zero linarith.comp)))) := sorry --non-trivial
lemma new_lemma_104031 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_semilattice_Sup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_104032 (h2 : add_group (distrib char)) : is_add_cyclic (distrib char) := sorry --non-trivial
lemma new_lemma_104033 (h0 : group (metric_space string_imp)) : is_cyclic (metric_space string_imp) := sorry --non-trivial
lemma new_lemma_104034 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_104035 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (linear_ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (linear_ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_104036 (h0 : multiset (semi_normed_ring char)) (h1 : not (multiset (semi_normed_ring char) -> false)) : multiset.disjoint h0 (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_104037 (h0 : not (has_mem.mem (measurable_space congr_arg_kind) has_emptyc.emptyc -> false)) : @is_domain.{0} (measurable_space.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type ring.{0} (measurable_space.{0} congr_arg_kind) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} congr_arg_kind) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_104038 (h0 : topological_space (with_one num)) : irreducible_space (with_one num) := sorry --non-trivial
lemma new_lemma_104039 (h0 : topological_space (has_pos_part Type)) : regular_space (has_pos_part Type) := sorry --non-trivial
lemma new_lemma_104040 (h0 : functor.add_const (ring (has_add pos)) linarith.comp) : @is_principal_ideal_ring.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_104041 (h0 : not (topological_space (non_unital_non_assoc_semiring to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (non_unital_non_assoc_semiring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (non_unital_non_assoc_semiring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_104042 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_inner empty empty)) (option (option (option unsigned)))) : @unique_factorization_monoid.{0} (has_inner.{0 0} empty empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_inner.{0 0} empty empty)) (option.{0} (option.{0} (option.{0} unsigned))) h0)  := sorry --non-trivial
lemma new_lemma_104043 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) (finset pos)) : @preirreducible_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_104044 (h1 : complete_lattice (has_add fun_info)) : complete_lattice.is_Sup_finite_compact (has_add fun_info) := sorry --non-trivial
lemma new_lemma_104045 (h0 : topological_space (add_comm_semigroup environment.projection_info)) (h1 : preorder (add_comm_semigroup environment.projection_info)) : order_closed_topology (add_comm_semigroup environment.projection_info) := sorry --non-trivial
lemma new_lemma_104046 (h0 : set (has_ssubset to_additive.value_type)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_104047 (h0 : functor.add_const (ring ennreal) (option (option (option (option ennreal))))) : @strong_rank_condition.{0} ennreal (@functor.add_const.run.{0 0} (ring.{0} ennreal) (option.{0} (option.{0} (option.{0} (option.{0} ennreal)))) h0)  := sorry --non-trivial
lemma new_lemma_104048 (h0 h1 : multiset (has_lt char)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_104049 (h0 : functor.add_const (functor.add_const (list linarith.comp) linarith.comp) Type) : list.nodup (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_104050 (h0 : not (topological_space (non_unital_non_assoc_semiring linarith.ineq) -> false)) (h1 : not (preorder (non_unital_non_assoc_semiring linarith.ineq) -> false)) : @order_topology.{0} (non_unital_non_assoc_semiring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (non_unital_non_assoc_semiring.{0} linarith.ineq)) h0) (@classical.by_contradiction'.{1} (preorder.{0} (non_unital_non_assoc_semiring.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_104051 (h0 : functor.add_const (add_group (simple_graph Type)) linarith.comp) : @is_add_cyclic.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (simple_graph.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_104052 (h0 : not (has_mem.mem (with_bot num) has_emptyc.emptyc -> false)) : @discrete_topology.{0} (with_bot.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_104053 (h0 : not (complete_lattice (normed_group linarith.ineq) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_group.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_104054 (h0 : topological_space (add_comm_monoid (has_neg_part Type))) : loc_path_connected_space (add_comm_monoid (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_104055 (h0 : list (has_Inf (has_nndist linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_104056 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @loc_path_connected_space.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_104057 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @t1_space.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_104058 (h0 : functor.add_const (topological_space (has_to_string unsigned)) name) : @regular_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_104059 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring linarith.comp)) linarith.comp) : @totally_disconnected_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_104060 (h0 : functor.add_const (topological_space (complete_distrib_lattice environment.implicit_infer_kind)) Type) : @path_connected_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_104061 (h1 : monoid (with_one (with_bot string_imp))) : monoid.fg (with_one (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_104062 (h0 : functor.add_const (topological_space (has_nndist Type)) linarith.comp) : @locally_compact_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_104063 (h0 : set (mul_one_class num -> mul_one_class fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_104064 (h0 : ring (boolean_algebra.core (finset Type))) : is_domain (boolean_algebra.core (finset Type)) := sorry --non-trivial
lemma new_lemma_104065 (h0 : functor.add_const (ring (boolean_algebra linarith.comp)) (finset Type)) : @is_domain.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (boolean_algebra.{0} linarith.comp)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_104066 (h0 : functor.comp topological_space has_nndist pos) : @topological_space.separable_space.{0} (has_nndist.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} pos (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} pos (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} pos (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} pos h0))))  := sorry --non-trivial
lemma new_lemma_104067 (h0 : ring (has_top (random_gen (random_gen fun_info)))) : rank_condition (has_top (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_104068 (h0 : group (add_right_cancel_monoid num)) : group.fg (add_right_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_104069 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_104070 (h1 : not (complete_lattice (distrib_lattice char) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (distrib_lattice.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (distrib_lattice.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_104071 (h0 : complete_lattice (mul_one_class (add_comm_semigroup Prop))) : complete_lattice.is_Sup_finite_compact (mul_one_class (add_comm_semigroup Prop)) := sorry --non-trivial
lemma new_lemma_104072 (h0 : topological_space (has_dist (option num))) : path_connected_space (has_dist (option num)) := sorry --non-trivial
lemma new_lemma_104073 (h0 : complete_lattice (finset (finset (finset (finset (finset name)))))) : is_compactly_generated (finset (finset (finset (finset (finset name))))) := sorry --non-trivial
lemma new_lemma_104074 (h0 : prod (complete_distrib_lattice congr_arg_kind) (complete_distrib_lattice congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_104075 (h1 : topological_space (random_gen fun_info)) : totally_separated_space (random_gen fun_info) := sorry --non-trivial
lemma new_lemma_104076 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_104077 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (has_Inf name)) := sorry --non-trivial
lemma new_lemma_104078 (h0 : topological_space (has_inter empty)) : topological_space.separable_space (has_inter empty) := sorry --non-trivial
lemma new_lemma_104079 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (mul_zero_class Type)) := sorry --non-trivial
lemma new_lemma_104080 (h0 : functor.add_const (semiring (has_pos_part Type)) linarith.comp) : @is_noetherian_ring.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (has_pos_part.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_104081 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (mul_zero_class.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} num))  := sorry --non-trivial
lemma new_lemma_104082 (h0 : cancel_comm_monoid_with_zero (add_semigroup (option (option (option unsigned))))) : unique_factorization_monoid (add_semigroup (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_104083 (h0 : topological_space (complete_distrib_lattice (has_pos_part Type))) : totally_separated_space (complete_distrib_lattice (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_104084 (h0 : functor.add_const (function.extfun Type ring) linarith.comp) : @is_domain.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) linarith.comp h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_104085 (h0 : topological_space (has_to_string (boolean_algebra linarith.comp))) : path_connected_space (has_to_string (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_104086 (h0 : cancel_comm_monoid_with_zero (add_comm_monoid unsigned)) : unique_factorization_monoid (add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_104087 (h3 : complete_lattice (with_zero linarith.ineq)) : is_compactly_generated (with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_104088 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (complete_semilattice_Sup linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_104089 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_104090 (h0 : functor.add_const (topological_space (semigroup Type)) unsigned) : @regular_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_104091 (h1 : topological_space (metric_space (has_Inf linarith.comp_source))) : t0_space (metric_space (has_Inf linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_104092 (h1 : list (distrib_lattice to_additive.value_type)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_104093 (h0 : functor.add_const (group (has_nndist name)) Type) : @is_cyclic.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 1} (group.{0} (has_nndist.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_104094 (h1 : ring (add_cancel_comm_monoid (random_gen linarith.comp_source))) : is_domain (add_cancel_comm_monoid (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_104095 (h0 : finset (finset (has_add (option unsigned)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_104096 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (canonically_linear_ordered_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_104097 (h0 : complete_lattice (normed_lattice_add_comm_group (boolean_algebra (sub_neg_monoid pos)))) : is_compactly_generated (normed_lattice_add_comm_group (boolean_algebra (sub_neg_monoid pos))) := sorry --non-trivial
lemma new_lemma_104098 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_nndist unsigned)) name) : @unique_factorization_monoid.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_nndist.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_104099 (h0 : topological_space (left_cancel_monoid empty)) : preirreducible_space (left_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_104100 (h0 : complete_lattice (has_inter empty)) : complete_lattice.is_Sup_finite_compact (has_inter empty) := sorry --non-trivial
lemma new_lemma_104101 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_104102 (h0 : topological_space (semiring (has_norm (semiring (has_norm num))))) : locally_compact_space (semiring (has_norm (semiring (has_norm num)))) := sorry --non-trivial
lemma new_lemma_104103 (h0 : functor.add_const (uniform_space (has_bot empty)) empty) : @separated_space.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_bot.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_104104 (h0 : function.extfun nat fin) : @totally_disconnected_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_104105 (h0 : list (has_inv (random_gen to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_104106 (h0 : not (complete_lattice (semiring (random_gen linarith.ineq)) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} (random_gen.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semiring.{0} (random_gen.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_104107 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_104108 (h0 : topological_space (comm_group (has_neg_part pos))) : irreducible_space (comm_group (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_104109 (h0 : functor.add_const (group (add_cancel_monoid pos)) (option unsigned)) : @group.fg.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} pos)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_104110 (h0 : functor.add_const (complete_lattice (has_zero Type)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_zero.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_104111 (h0 : topological_space (mul_one_class reducibility_hints)) : totally_disconnected_space (mul_one_class reducibility_hints) := sorry --non-trivial
lemma new_lemma_104112 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ordered_cancel_add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_104113 (h0 : complete_lattice (linear_ordered_comm_ring (semiring (semiring empty)))) : is_compactly_generated (linear_ordered_comm_ring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_104114 (h0 : ring (has_neg (ring Type))) : strong_rank_condition (has_neg (ring Type)) := sorry --non-trivial
lemma new_lemma_104115 (h0 : topological_space (has_neg (comm_group (comm_group (has_add unsigned))))) : normal_space (has_neg (comm_group (comm_group (has_add unsigned)))) := sorry --non-trivial
lemma new_lemma_104116 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} h0 (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_104117 (h0 : complete_lattice (mul_zero_class (semiring (semiring empty)))) : is_compactly_generated (mul_zero_class (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_104118 (h0 : ordered_add_comm_monoid (add_right_cancel_monoid (option unsigned))) : archimedean (add_right_cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_104119 (h0 : ring (comm_ring (has_norm fun_info))) : rank_condition (comm_ring (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_104120 (h0 : topological_space (metric_space (metric_space (metric_space (metric_space num))))) : normal_space (metric_space (metric_space (metric_space (metric_space num)))) := sorry --non-trivial
lemma new_lemma_104121 (h0 : topological_space (boolean_algebra (has_pos_part linarith.comp))) : t0_space (boolean_algebra (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_104122 (h0 : function.extfun Type group) : @group.fg.{0} (has_nndist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_nndist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_104123 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_inter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_inter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_104124 (h1 : topological_space (id congr_arg_kind)) : locally_compact_space (id congr_arg_kind) := sorry --non-trivial
lemma new_lemma_104125 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} empty (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) empty)  := sorry --non-trivial
lemma new_lemma_104126 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_inter.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_inter.{0} empty))  := sorry --non-trivial
lemma new_lemma_104127 (h0 : topological_space (comm_monoid (option empty))) : totally_disconnected_space (comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_104128 (h0 : ring (semigroup (has_add (has_to_string name)))) : rank_condition (semigroup (has_add (has_to_string name))) := sorry --non-trivial
lemma new_lemma_104129 (h0 : functor.add_const (group (normed_comm_ring empty)) empty) : @group.fg.{0} (normed_comm_ring.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_104130 (h0 : complete_lattice (add_comm_monoid (finset environment.implicit_infer_kind))) : is_compactly_generated (add_comm_monoid (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_104131 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @path_connected_space.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_104132 (h0 : functor.add_const (group (canonically_ordered_add_monoid empty)) unsigned) : @group.fg.{0} (canonically_ordered_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_add_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_104133 (h0 : complete_lattice (add_comm_monoid ennreal)) : is_compactly_generated (add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_104134 (h0 : functor.add_const (group (comm_group pos)) linarith.comp) : @group.fg.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_104135 (h0 : functor.add_const (ordered_comm_monoid (has_pos_part pos)) (ordered_comm_ring linarith.comp)) : @has_exists_mul_of_le.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_pos_part.{0} pos)) (ordered_comm_ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_104136 (h0 : functor.add_const (group (add_comm_monoid pos)) (finset environment.implicit_infer_kind)) : @normalizer_condition.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (add_comm_monoid.{0} pos)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_104137 (h0 : not (topological_space (complete_semilattice_Sup num) -> false)) : @locally_compact_space.{0} (complete_semilattice_Sup.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_104138 (h0 : group (has_bot (has_pos_part pos))) : is_simple_group (has_bot (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_104139 (h0 : topological_space (linear_ordered_semiring empty)) : preirreducible_space (linear_ordered_semiring empty) := sorry --non-trivial
lemma new_lemma_104140 (h0 : functor.add_const (list (has_neg linarith.comp)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_104141 (h0 : functor.add_const (topological_space (has_add linarith.comp)) linarith.comp) : @t1_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_104142 (h0 : ring (measurable_space (random_gen linarith.comp_source))) : strong_rank_condition (measurable_space (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_104143 (h0 : functor.add_const (topological_space (has_add (comm_monoid linarith.comp))) (ring environment.implicit_infer_kind)) : @preirreducible_space.{0} (has_add.{0} (comm_monoid.{0} linarith.comp)) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} (comm_monoid.{0} linarith.comp))) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_104144 (h0 : complete_lattice (has_inner unsigned congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (has_inner unsigned congr_arg_kind) := sorry --non-trivial
lemma new_lemma_104145 (h0 : complete_lattice (has_zero (has_neg_part (has_neg_part pos)))) : is_atomistic (has_zero (has_neg_part (has_neg_part pos))) := sorry --non-trivial
lemma new_lemma_104146 (h0 : functor.add_const (group (has_nndist pos)) Type) : @is_simple_group.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (has_nndist.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_104147 (h1 : complete_lattice (has_append (has_ssubset char))) : is_compactly_generated (has_append (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_104148 (h0 : ring rat) : is_principal_ideal_ring rat := sorry --non-trivial
lemma new_lemma_104149 (h0 : topological_space (has_pos_part (has_neg Type))) : regular_space (has_pos_part (has_neg Type)) := sorry --non-trivial
lemma new_lemma_104150 (h0 : topological_space (left_cancel_semigroup (partial_order unsigned))) : t0_space (left_cancel_semigroup (partial_order unsigned)) := sorry --non-trivial
lemma new_lemma_104151 (h0 : not (topological_space (uniform_space char) -> false)) : @totally_disconnected_space.{0} (uniform_space.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_104152 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_104153 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_104154 (h0 : functor.add_const (ring (has_neg_part pos)) (semigroup name)) : @strong_rank_condition.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_neg_part.{0} pos)) (semigroup.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_104155 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_104156 (h0 : functor.add_const (topological_space (has_Sup unsigned)) unsigned) : @discrete_topology.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_104157 (h0 : functor.add_const (list (measurable_space.dynkin_system empty)) num) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_104158 (h0 : function.extfun Type ring) : @rank_condition.{0} (group_with_zero.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (group_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_104159 (h0 : ordered_add_comm_monoid (simple_graph name)) : archimedean (simple_graph name) := sorry --non-trivial
lemma new_lemma_104160 (h0 : list (has_to_string (boolean_algebra (ring (ring linarith.comp))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_104161 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_104162 (h0 : semiring (linear_ordered_field (has_to_string num))) : is_noetherian_ring (linear_ordered_field (has_to_string num)) := sorry --non-trivial
lemma new_lemma_104163 (h0 : false) : matrix.vec_empty (false.elim h0) := sorry --trivial
lemma new_lemma_104164 (h1 : preorder (encodable linarith.ineq)) (h2 : add_group (closure_operator (encodable linarith.ineq))) : is_add_cyclic (closure_operator (encodable linarith.ineq)) := sorry --non-trivial
lemma new_lemma_104165 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_sub.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_sub.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_104166 (h0 : function.extfun (Type 1) ring) : @strong_rank_condition.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_104167 (h0 : topological_space (has_emptyc (random_gen (has_norm linarith.comp_source)))) : totally_separated_space (has_emptyc (random_gen (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_104168 (h0 : topological_space (has_nndist (has_add unsigned))) : totally_separated_space (has_nndist (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_104169 (h0 : topological_space (sub_neg_monoid (has_neg (has_neg (has_neg pos))))) : path_connected_space (sub_neg_monoid (has_neg (has_neg (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_104170 (h0 : set (set (simple_graph string.iterator_imp))) (h1 : set (simple_graph string.iterator_imp)) : measurable_space.dynkin_system.generate_has h0 h1 := sorry --non-trivial
lemma new_lemma_104171 (h0 : uniform_space (add_group num)) : separated_space (add_group num) := sorry --non-trivial
lemma new_lemma_104172 (h0 : ring (denumerable (random_gen (random_gen (random_gen char))))) : is_domain (denumerable (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_104173 (h0 : topological_space (partial_order (semiring num))) : t0_space (partial_order (semiring num)) := sorry --non-trivial
lemma new_lemma_104174 (h0 : topological_space (add_right_cancel_monoid (semiring (semiring (semiring (semiring empty)))))) : discrete_topology (add_right_cancel_monoid (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_104175 (h0 : filter (boolean_algebra (finset environment.implicit_infer_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_104176 (h0 : functor.add_const (ring (comm_group pos)) environment.implicit_infer_kind) : @rank_condition.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_104177 (h0 : add_group (has_zero (add_comm_monoid name))) : is_add_cyclic (has_zero (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_104178 (h0 : functor.add_const (uniform_space (ordered_comm_ring linarith.comp)) name) : @complete_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_comm_ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_104179 (h0 : functor.add_const (ordered_comm_monoid (sub_neg_monoid name)) linarith.comp) : @has_exists_mul_of_le.{0} (sub_neg_monoid.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (sub_neg_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_104180 (h0 : uniform_space (with_one (has_norm (has_norm (semiring empty))))) : complete_space (with_one (has_norm (has_norm (semiring empty)))) := sorry --non-trivial
lemma new_lemma_104181 (h0 : semiring (has_one unsigned)) : is_noetherian_ring (has_one unsigned) := sorry --non-trivial
lemma new_lemma_104182 (h0 : topological_space (has_emptyc (has_top (has_top (random_gen linarith.comp_source))))) : path_connected_space (has_emptyc (has_top (has_top (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_104183 (h0 : functor.add_const (topological_space (semigroup pos)) linarith.comp) : @preirreducible_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_104184 (h0 : function.extfun Type (functor.add_const (ring pos))) : @is_principal_ideal_ring.{0} pos (@functor.add_const.run.{0 0} (ring.{0} pos) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} pos)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_104185 (h0 : group (has_norm (random_gen (has_inv (has_inv (random_gen fun_info)))))) : normalizer_condition (has_norm (random_gen (has_inv (has_inv (random_gen fun_info))))) := sorry --non-trivial
lemma new_lemma_104186 (h0 : complete_lattice (semiring (semiring (has_one num)))) : is_atomistic (semiring (semiring (has_one num))) := sorry --non-trivial
lemma new_lemma_104187 (h0 : group (id (with_bot (with_bot (with_bot to_additive.value_type))))) : normalizer_condition (id (with_bot (with_bot (with_bot to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_104188 (h3 : group linarith.comp_source) : normalizer_condition linarith.comp_source := sorry --non-trivial
lemma new_lemma_104189 (h0 : with_bot (fin has_zero.zero)) (h1 : ne h0 has_bot.bot) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@matrix.vec_empty.{0} (filter.{0} Prop) (@with_bot.unbot.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0 h1))  := sorry --non-trivial
lemma new_lemma_104190 (h0 : semiring (ordered_comm_monoid (has_add (sub_neg_monoid (has_Inf (has_Inf real)))))) : is_noetherian_ring (ordered_comm_monoid (has_add (sub_neg_monoid (has_Inf (has_Inf real))))) := sorry --non-trivial
lemma new_lemma_104191 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_104192 (h0 : topological_space (has_to_string (boolean_algebra name))) : normal_space (has_to_string (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_104193 (h0 : list (has_neg_part (pseudo_metric_space unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_104194 (h0 : topological_space (has_top (id linarith.comp))) : t0_space (has_top (id linarith.comp)) := sorry --non-trivial
lemma new_lemma_104195 (h0 : functor.add_const (finset (complete_distrib_lattice pos)) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_104196 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_104197 (h0 : not (uniform_space (has_star congr_arg_kind) -> false)) : @complete_space.{0} (has_star.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_star.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_104198 (h0 : functor.add_const (topological_space (sub_neg_monoid linarith.comp)) Type) : @loc_path_connected_space.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (sub_neg_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_104199 (h0 : functor.add_const (add_monoid (has_to_string environment.implicit_infer_kind)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_to_string.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_104200 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_104201 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) pos) : @archimedean.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) pos h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_104202 (h0 : function.extfun (finset Type) (has_mem.mem (semiring linarith.comp))) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} linarith.comp) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_104203 (h0 : complete_lattice (complete_distrib_lattice (option ennreal))) : is_compactly_generated (complete_distrib_lattice (option ennreal)) := sorry --non-trivial
lemma new_lemma_104204 (h0 : ring (cancel_monoid (has_add Type))) : rank_condition (cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_104205 (h0 : functor.add_const (complete_lattice (normed_comm_ring pos)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_104206 (h0 : ordered_add_comm_monoid (has_neg (add_cancel_monoid Type))) : archimedean (has_neg (add_cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_104207 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @irreducible_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_104208 (h0 : set (add_comm_semigroup enat -> mul_one_class (mul_one_class char))) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_104209 (h0 : topological_space (has_pos_part (ring linarith.comp))) : totally_separated_space (has_pos_part (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_104210 (h0 : function.extfun (Type 1) topological_space) : @sequential_space.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_104211 (h0 : group (id (semiring unsigned))) : normalizer_condition (id (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_104212 (h0 : ring (has_add (normed_linear_ordered_group Type))) : is_principal_ideal_ring (has_add (normed_linear_ordered_group Type)) := sorry --non-trivial
lemma new_lemma_104213 (h0 : topological_space (has_zero (ring Type))) : locally_compact_space (has_zero (ring Type)) := sorry --non-trivial
lemma new_lemma_104214 (h0 : group (normed_field (has_nnnorm (semi_normed_ring reducibility_hints)))) : is_cyclic (normed_field (has_nnnorm (semi_normed_ring reducibility_hints))) := sorry --non-trivial
lemma new_lemma_104215 (h0 : measurable_space (semi_normed_comm_ring (mul_one_class (mul_one_class (mul_one_class char))))) (h1 : filter (semi_normed_comm_ring (mul_one_class (mul_one_class (mul_one_class char))))) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_104216 (h0 : topological_space (random_gen (has_norm fun_info))) : totally_separated_space (random_gen (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_104217 (h0 : fun_info -> Prop) (h1 : fun_info -> set fun_info) (h2 : preorder Prop) (h3 : set Prop) : upper_bounds h3 (filter.is_basis h0 h1) := sorry --non-trivial
lemma new_lemma_104218 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_104219 (h0 : ring (topological_space (metric_space reducibility_hints))) : strong_rank_condition (topological_space (metric_space reducibility_hints)) := sorry --non-trivial
lemma new_lemma_104220 (h0 : topological_space (has_Inf (has_add (has_Inf (has_add linarith.comp))))) : preconnected_space (has_Inf (has_add (has_Inf (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_104221 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (has_one.{0} (semiring.{0} (semiring.{0} (linear_ordered_semiring.{0} (has_top.{0} empty))))) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_one.{0} (semiring.{0} (semiring.{0} (linear_ordered_semiring.{0} (has_top.{0} empty))))))  := sorry --non-trivial
lemma new_lemma_104222 (h0 : ring (has_nnnorm (random_gen reducibility_hints))) : is_domain (has_nnnorm (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_104223 (h0 : complete_lattice (finset (sub_neg_monoid real))) : is_atomistic (finset (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_104224 (h0 : functor.add_const (ordered_add_comm_monoid (normed_linear_ordered_group num)) unsigned) : @archimedean.{0} (normed_linear_ordered_group.{0} num) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (normed_linear_ordered_group.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_104225 (h0 : uniform_space (with_bot to_additive.value_type)) : separated_space (with_bot to_additive.value_type) := sorry --non-trivial
lemma new_lemma_104226 (h0 : topological_space (plift num)) : totally_separated_space (plift num) := sorry --non-trivial
lemma new_lemma_104227 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @t1_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_104228 (h0 : uniform_space (linear_ordered_field (option unsigned))) : separated_space (linear_ordered_field (option unsigned)) := sorry --non-trivial
lemma new_lemma_104229 (h0 : topological_space (normed_comm_ring (has_to_string num))) : discrete_topology (normed_comm_ring (has_to_string num)) := sorry --non-trivial
lemma new_lemma_104230 (h0 : ordered_comm_monoid (ring (has_add pos))) : has_exists_mul_of_le (ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_104231 (h0 : complete_lattice (has_nnnorm (mul_one_class (mul_one_class char)))) : is_compactly_generated (has_nnnorm (mul_one_class (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_104232 (h0 : cancel_comm_monoid_with_zero (has_neg_part (has_neg_part unsigned))) : unique_factorization_monoid (has_neg_part (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_104233 (h0 : function.extfun Type (functor.add_const (topological_space ennreal))) : preconnected_space ennreal := sorry --non-trivial
lemma new_lemma_104234 (h0 : functor.add_const (topological_space (simple_graph pos)) Type) : @t1_space.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (simple_graph.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_104235 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_sdiff.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_sdiff.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_104236 (h0 : functor.add_const (filter (has_add Type)) environment.implicit_infer_kind) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_104237 (h0 : topological_space (canonically_ordered_comm_semiring linarith.comp)) : totally_disconnected_space (canonically_ordered_comm_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_104238 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_104239 (h0 : cancel_comm_monoid_with_zero (add_cancel_monoid (ring Type))) : unique_factorization_monoid (add_cancel_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_104240 (h0 : ring (complete_semilattice_Sup (has_top num))) : rank_condition (complete_semilattice_Sup (has_top num)) := sorry --non-trivial
lemma new_lemma_104241 (h0 : topological_space (has_to_string (comm_group Type))) : irreducible_space (has_to_string (comm_group Type)) := sorry --non-trivial
lemma new_lemma_104242 (h0 : std_gen -> std_gen -> Prop) (h1 : set std_gen) : is_strong_antichain h0 h1 := sorry --non-trivial
lemma new_lemma_104243 (h0 : monoid (ring (has_pos_part linarith.comp))) : monoid.fg (ring (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_104244 (h0 : functor.add_const (add_monoid (complete_distrib_lattice environment.implicit_infer_kind)) name) : @add_monoid.fg.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_104245 (h0 : topological_space (ordered_comm_monoid (finset Type))) : totally_separated_space (ordered_comm_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_104246 (h0 : functor.add_const (topological_space (has_neg name)) name) : @irreducible_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_104247 (h0 : topological_space (distrib_lattice (random_gen linarith.comp_source))) : locally_compact_space (distrib_lattice (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_104248 (h1 : add_comm_monoid char) (h2 : add_submonoid char) (h3 : has_lt (add_localization h2)) : no_max_order (add_localization h2) := sorry --non-trivial
lemma new_lemma_104249 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @normal_space.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} real)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_104250 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @t0_space.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_104251 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (canonically_ordered_comm_semiring.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} h0 (canonically_ordered_comm_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_104252 (h0 : not (has_mem.mem (measurable_space linarith.comp) has_emptyc.emptyc -> false)) : @t0_space.{0} (measurable_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} linarith.comp) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} linarith.comp) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_104253 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (add_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_104254 (h0 : has_mem.mem (has_norm linarith.comp) has_emptyc.emptyc) : @totally_disconnected_space.{0} (has_norm.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_104255 (h0 : topological_space (sub_neg_monoid (has_nndist linarith.comp))) : regular_space (sub_neg_monoid (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_104256 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_104257 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_104258 (h0 : topological_space (ordered_comm_monoid (has_bot real))) : preconnected_space (ordered_comm_monoid (has_bot real)) := sorry --non-trivial
lemma new_lemma_104259 (h0 : group (semiring (has_norm (has_top congr_arg_kind)))) : group.fg (semiring (has_norm (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_104260 (h0 : functor.add_const (ring (finset empty)) empty) : @strong_rank_condition.{0} (finset.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_104261 (h0 : ring (has_ssubset (random_gen (random_gen (random_gen (random_gen fun_info)))))) : rank_condition (has_ssubset (random_gen (random_gen (random_gen (random_gen fun_info))))) := sorry --non-trivial
lemma new_lemma_104262 (h0 : functor.add_const (complete_lattice (has_zero Type)) linarith.comp) : @is_atomistic.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_zero.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_104263 (h0 : group (complete_semilattice_Sup (semiring congr_arg_kind))) : normalizer_condition (complete_semilattice_Sup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_104264 (h0 : ring (has_inv fun_info)) : is_domain (has_inv fun_info) := sorry --non-trivial
lemma new_lemma_104265 (h0 : function.extfun nat fin) : @totally_disconnected_space.{0} (semigroup.{0} (finset.{0} linarith.comp)) (@matrix.vec_empty.{0} (topological_space.{0} (semigroup.{0} (finset.{0} linarith.comp))) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_104266 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @loc_path_connected_space.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_104267 (h0 : topological_space (ordered_comm_ring (finset linarith.comp))) : loc_path_connected_space (ordered_comm_ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_104268 (h0 : ring (with_one (semiring (semiring fun_info)))) : is_domain (with_one (semiring (semiring fun_info))) := sorry --non-trivial
lemma new_lemma_104269 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (is_R_or_C.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (is_R_or_C.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_104270 (h0 : function.extfun (Type -> Type) (function.extfun Type) -> Prop) (h1 : Exists (fun (x : function.extfun (Type -> Type) (function.extfun Type)), h0 x)) : @t0_space.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.some.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0 h1) topological_space.{0}) (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_104271 (h3 : not (add_group (simple_graph string_imp) -> false)) : @is_add_cyclic.{0} (simple_graph.{0} string_imp) (@classical.by_contradiction'.{1} (add_group.{0} (simple_graph.{0} string_imp)) h3)  := sorry --non-trivial
lemma new_lemma_104272 (h0 : ring (normed_group (random_gen linarith.comp))) : is_domain (normed_group (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_104273 (h0 : ordered_add_comm_monoid (has_nndist (option pos))) : archimedean (has_nndist (option pos)) := sorry --non-trivial
lemma new_lemma_104274 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @path_connected_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_104275 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_104276 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (left_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (left_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_104277 (h1 : filter (normed_group string_imp)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_104278 (h2 : filter (with_zero linarith.ineq)) : filter.ne_bot h2 := sorry --non-trivial
lemma new_lemma_104279 (h0 : cancel_comm_monoid_with_zero (finset (option (option ennreal)))) : unique_factorization_monoid (finset (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_104280 (h0 : topological_space (measurable_space (has_norm (has_norm (has_norm linarith.comp_source))))) : totally_separated_space (measurable_space (has_norm (has_norm (has_norm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_104281 (h0 : pfun (mul_one_class enat) Prop) (h1 : coe_sort (pfun.dom h0)) : pfun.as_subtype h0 h1 := sorry --non-trivial
lemma new_lemma_104282 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (mul_zero_class.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_104283 (h1 : ring (topological_space linarith.comp_source)) : is_domain (topological_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_104284 (h0 : complete_lattice (uniform_space (has_compl reducibility_hints))) : complete_lattice.is_Sup_finite_compact (uniform_space (has_compl reducibility_hints)) := sorry --non-trivial
lemma new_lemma_104285 (h0 : function.extfun Type (functor.add_const (topological_space auto.case_option))) : @t1_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} auto.case_option)) h0 num))  := sorry --non-trivial
lemma new_lemma_104286 (h0 : function.extfun Type ring) : @is_domain.{0} (monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_104287 (h0 : functor.add_const (function.extfun Type add_monoid) (ring Type)) : @add_monoid.fg.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type add_monoid.{0}) (ring.{1} Type) h0) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_104288 (h0 : group (has_ssubset (random_gen to_additive.value_type))) : is_cyclic (has_ssubset (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_104289 (h2 : topological_space to_additive.value_type) (h3 : add_group to_additive.value_type) : topological_add_group to_additive.value_type := sorry --non-trivial
lemma new_lemma_104290 (h0 : set Prop) (h1 : set.nonempty h0) : set.nonempty.some h1 := sorry --non-trivial
lemma new_lemma_104291 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} name (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) name)  := sorry --non-trivial
lemma new_lemma_104292 (h0 : functor.add_const (group (generalized_boolean_algebra name)) linarith.comp) : @is_cyclic.{0} (generalized_boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (group.{0} (generalized_boolean_algebra.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_104293 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (linear_ordered_field.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (linear_ordered_field.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_104294 (h0 : Exists (fun (x : nat), has_lt.lt has_zero.zero x)) (h1 : not (pnat -> false)) : pnat.coprime (encodable.choose_x h0) (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_104295 (h0 : functor.add_const (topological_space (has_zero Type)) Type) : @preconnected_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_zero.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_104296 (h0 : has_mem.mem group has_emptyc.emptyc) : @normalizer_condition.{0} linarith.comp (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_104297 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (boolean_algebra.core num)) := sorry --non-trivial
lemma new_lemma_104298 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_104299 (h0 : functor.add_const (semiring (free_add_monoid unsigned)) unsigned) : @is_noetherian_ring.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (free_add_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_104300 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @monoid.fg.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) monoid.{0}) (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_104301 (h0 : topological_space (has_neg (has_pos_part Type))) : discrete_topology (has_neg (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_104302 (h0 : complete_lattice (has_inter empty)) : is_compactly_generated (has_inter empty) := sorry --non-trivial
lemma new_lemma_104303 (h1 : topological_space (with_zero string_imp)) : t0_space (with_zero string_imp) := sorry --non-trivial
lemma new_lemma_104304 (h0 : topological_space (distrib_lattice (has_norm to_additive.value_type))) : t0_space (distrib_lattice (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_104305 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_104306 (h0 : complete_lattice (plift (has_top num))) : complete_lattice.is_Sup_finite_compact (plift (has_top num)) := sorry --non-trivial
lemma new_lemma_104307 (h0 : group (measurable_space (random_gen (with_bot (random_gen (with_bot string_imp)))))) : normalizer_condition (measurable_space (random_gen (with_bot (random_gen (with_bot string_imp))))) := sorry --non-trivial
lemma new_lemma_104308 (h0 : topological_space (normed_group (non_assoc_semiring linarith.comp))) : preirreducible_space (normed_group (non_assoc_semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_104309 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_104310 (h0 : functor.add_const (function.extfun nat fin) linarith.comp) : @is_compactly_generated.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (has_pos_part.{1} Type)) (@function.extfun_app.{1 1} nat fin (@functor.add_const.run.{0 0} (function.extfun.{1 1} nat fin) linarith.comp h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_104311 (h0 : group (has_to_string (has_add linarith.comp))) : is_cyclic (has_to_string (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_104312 (h0 : complete_lattice (with_bot (semiring empty))) : is_atomistic (with_bot (semiring empty)) := sorry --non-trivial
lemma new_lemma_104313 (h0 : topological_space (has_sub num)) : preirreducible_space (has_sub num) := sorry --non-trivial
lemma new_lemma_104314 (h0 : topological_space (with_bot congr_arg_kind)) : locally_compact_space (with_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_104315 (h0 : complete_lattice (has_norm to_additive.value_type)) : is_atomistic (has_norm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_104316 (h0 : functor.add_const (complete_lattice (cancel_monoid Type)) name) : @is_atomistic.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_104317 (h0 : finset (has_neg (finset (finset environment.implicit_infer_kind)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_104318 (h0 : complete_lattice (random_gen linarith.ineq)) : is_compactly_generated (random_gen linarith.ineq) := sorry --non-trivial
lemma new_lemma_104319 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_104320 (h0 : topological_space (with_one (has_append fun_info))) : irreducible_space (with_one (has_append fun_info)) := sorry --non-trivial
lemma new_lemma_104321 (h0 : topological_space (comm_group congr_arg_kind)) : irreducible_space (comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_104322 (h0 : semiring (boolean_algebra (has_to_string unsigned))) : is_noetherian_ring (boolean_algebra (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_104323 (h0 : ring (has_bot (has_Inf (has_neg linarith.comp)))) : strong_rank_condition (has_bot (has_Inf (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_104324 (h0 : functor.add_const (topological_space znum) unsigned) : @t0_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) unsigned h0)  := sorry --non-trivial
lemma new_lemma_104325 (h0 : not (uniform_space (linear_ordered_comm_group_with_zero (denumerable (mul_one_class (random_gen char)))) -> false)) : @complete_space.{0} (linear_ordered_comm_group_with_zero.{0} (denumerable.{0} (mul_one_class.{0} (random_gen.{0} char)))) (@classical.by_contradiction'.{1} (uniform_space.{0} (linear_ordered_comm_group_with_zero.{0} (denumerable.{0} (mul_one_class.{0} (random_gen.{0} char))))) h0)  := sorry --non-trivial
lemma new_lemma_104326 (h1 : ring (has_compl (comm_ring (comm_ring linarith.comp_source)))) : is_domain (has_compl (comm_ring (comm_ring linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_104327 (h0 : ring (has_emptyc (semiring num))) : is_domain (has_emptyc (semiring num)) := sorry --non-trivial
lemma new_lemma_104328 (h1 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_104329 (h0 : functor.add_const (ring znum) unsigned) : @is_principal_ideal_ring.{0} znum (@functor.add_const.run.{0 0} (ring.{0} znum) unsigned h0)  := sorry --non-trivial
lemma new_lemma_104330 (h0 : cancel_comm_monoid_with_zero (linear_ordered_field unsigned)) : unique_factorization_monoid (linear_ordered_field unsigned) := sorry --non-trivial
lemma new_lemma_104331 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (boolean_algebra.core environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_104332 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} h0 congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_104333 (h0 : semiring (has_pos_part (has_Inf (ordered_comm_monoid (ordered_comm_monoid Type))))) : is_noetherian_ring (has_pos_part (has_Inf (ordered_comm_monoid (ordered_comm_monoid Type)))) := sorry --non-trivial
lemma new_lemma_104334 (h0 : finset (has_top unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_104335 (h0 : functor.add_const (function.extfun Type complete_lattice) (has_Inf (finset pos))) : @is_compactly_generated.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) (has_Inf.{0} (finset.{0} pos)) h0) (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_104336 (h0 : topological_space (has_scalar ennreal ennreal)) : totally_disconnected_space (has_scalar ennreal ennreal) := sorry --non-trivial
lemma new_lemma_104337 (h0 : has_mem.mem linarith.comp has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} linarith.comp (@finset.pi.empty.{1 0} Type complete_lattice.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_104338 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 monoid.{0}) (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_104339 (h0 : not (topological_space (linear_ordered_semiring num) -> false)) : @totally_disconnected_space.{0} (linear_ordered_semiring.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_104340 (h0 : list (add_group num)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_104341 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system unsigned)) congr_arg_kind) : @t0_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_104342 (h0 : complete_lattice (random_gen (has_norm congr_arg_kind))) : is_atomistic (random_gen (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_104343 (h0 : functor.add_const (group (ring environment.implicit_infer_kind)) pos) : @is_simple_group.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_104344 (h0 : measurable_space (has_compl string_imp)) (h1 : has_inf (has_compl string_imp)) : has_measurable_inf₂ (has_compl string_imp) := sorry --non-trivial
lemma new_lemma_104345 (h0 : not (topological_space (semiring empty) -> false)) : @t1_space.{0} (semiring.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_104346 (h2 : topological_space (has_nnnorm linarith.comp_source)) : totally_disconnected_space (has_nnnorm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_104347 (h0 : functor.add_const (ordered_add_comm_monoid (finset name)) environment.implicit_infer_kind) : @archimedean.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (finset.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_104348 (h0 : function.extfun (Type 1) topological_space) : @regular_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_104349 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (complete_semilattice_Sup.{0} string_imp) (@function.extfun_app.{2 1} Type monoid.{0} h0 (complete_semilattice_Sup.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_104350 (h0 : function.extfun nat fin) : @is_principal_ideal_ring.{0} (complete_distrib_lattice.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (complete_distrib_lattice.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_104351 (h0 : topological_space (boolean_algebra (boolean_algebra (has_nndist (has_Inf Type))))) : locally_compact_space (boolean_algebra (boolean_algebra (has_nndist (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_104352 (h0 : topological_space (has_union (has_top congr_arg_kind))) : irreducible_space (has_union (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_104353 (h0 : topological_space (comm_ring (comm_ring (comm_ring fun_info)))) : irreducible_space (comm_ring (comm_ring (comm_ring fun_info))) := sorry --non-trivial
lemma new_lemma_104354 (h0 : monoid (normed_group (semiring unsigned))) : monoid.fg (normed_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_104355 (h0 : not (complete_lattice (partial_order empty) -> false)) : @is_atomistic.{0} (partial_order.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (partial_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_104356 (h0 : functor.add_const (topological_space (has_to_string name)) pos) : @locally_compact_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_104357 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_neg_part Type)) ennreal) : @unique_factorization_monoid.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (has_neg_part.{1} Type)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_104358 (h0 : uniform_space (complete_semilattice_Sup congr_arg_kind)) : separated_space (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_104359 (h0 : finset (boolean_algebra (normed_comm_ring linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_104360 (h1 : group (with_one (random_gen string_imp))) : is_cyclic (with_one (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_104361 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_104362 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_104363 (h0 : functor.add_const (topological_space (boolean_algebra pos)) linarith.comp) : @totally_separated_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_104364 (h0 : list (left_cancel_monoid (semiring empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_104365 (h0 : has_mem.mem (measurable_space num) has_emptyc.emptyc) : @is_domain.{0} (measurable_space.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (measurable_space.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_104366 (h0 : functor.add_const (complete_lattice (has_bot linarith.comp)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (has_bot.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_bot.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_104367 (h0 : functor.add_const (ring (free_add_monoid empty)) num) : @is_principal_ideal_ring.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (free_add_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_104368 (h0 : ordered_add_comm_monoid (cancel_monoid name)) : archimedean (cancel_monoid name) := sorry --non-trivial
lemma new_lemma_104369 (h1 : topological_space (cancel_monoid (add_comm_semigroup ereal))) : t0_space (cancel_monoid (add_comm_semigroup ereal)) := sorry --non-trivial
lemma new_lemma_104370 (h0 : filter (encodable (has_nnnorm linarith.comp_source))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_104371 (h0 : uniform_space (comm_ring (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source))))) : complete_space (comm_ring (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_104372 (h0 : functor.add_const (uniform_space (has_Inf linarith.comp)) Type) : @separated_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_Inf.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_104373 (h0 : topological_space (semilattice_inf (option ennreal))) : path_connected_space (semilattice_inf (option ennreal)) := sorry --non-trivial
lemma new_lemma_104374 (h0 : functor.add_const (filter (has_neg_part ennreal)) (option name)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_104375 (h0 : functor.add_const (finset (generalized_boolean_algebra linarith.comp)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_104376 (h0 : functor.add_const (ring (ring name)) linarith.comp) : @strong_rank_condition.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_104377 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) h0) (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_104378 (h0 : functor.add_const (add_monoid (canonically_ordered_comm_semiring Type)) name) : @add_monoid.fg.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (canonically_ordered_comm_semiring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_104379 (h0 : topological_space (has_bot (has_neg pos))) : t1_space (has_bot (has_neg pos)) := sorry --non-trivial
lemma new_lemma_104380 (h0 : group (canonically_ordered_monoid (ordered_comm_monoid pos))) : is_cyclic (canonically_ordered_monoid (ordered_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_104381 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (ordered_cancel_add_comm_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_104382 (h0 : topological_space (normed_comm_ring (option num))) : locally_compact_space (normed_comm_ring (option num)) := sorry --non-trivial
lemma new_lemma_104383 (h0 : semiring (has_nndist congr_arg_kind)) : is_noetherian_ring (has_nndist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_104384 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @irreducible_space.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_104385 (h0 : functor.add_const (semiring (add_cancel_monoid Type)) name) : @is_noetherian_ring.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (add_cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_104386 (h0 : functor.add_const (complete_lattice (has_add linarith.comp)) (has_neg_part unsigned)) : @is_compactly_generated.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_add.{0} linarith.comp)) (has_neg_part.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_104387 (h0 : functor.add_const (topological_space (has_neg_part environment.implicit_infer_kind)) name) : @locally_compact_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_104388 (h0 : functor.add_const (cancel_comm_monoid_with_zero (normed_comm_ring pos)) environment.implicit_infer_kind) : @unique_factorization_monoid.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (normed_comm_ring.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_104389 (h0 : topological_space (has_nnnorm (random_gen (has_nnnorm (random_gen (random_gen linarith.ineq)))))) : locally_compact_space (has_nnnorm (random_gen (has_nnnorm (random_gen (random_gen linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_104390 (h0 : topological_space (left_cancel_monoid (semiring (option (option unsigned))))) : path_connected_space (left_cancel_monoid (semiring (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_104391 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_principal_ideal_ring.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_104392 (h0 : functor.add_const (uniform_space (bin_tree empty)) empty) : @complete_space.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (bin_tree.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_104393 (h0 : topological_space (encodable (random_gen to_additive.value_type))) : locally_compact_space (encodable (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_104394 (h0 : ring (ordered_comm_ring (has_bot real))) : rank_condition (ordered_comm_ring (has_bot real)) := sorry --non-trivial
lemma new_lemma_104395 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @regular_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_104396 (h0 : topological_space (ordered_cancel_add_comm_monoid (with_bot empty))) : normal_space (ordered_cancel_add_comm_monoid (with_bot empty)) := sorry --non-trivial
lemma new_lemma_104397 (h0 : functor.add_const (monoid (simple_graph empty)) empty) : @monoid.fg.{0} (simple_graph.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (simple_graph.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_104398 (h0 : complete_lattice (linear_ordered_semiring unsigned)) : is_compactly_generated (linear_ordered_semiring unsigned) := sorry --non-trivial
lemma new_lemma_104399 (h0 : filter (add_monoid (has_nnnorm linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_104400 (h0 : list (linear_ordered_add_comm_group (random_gen (random_gen linarith.ineq)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_104401 (h0 : group (has_nndist (has_add unsigned))) : group.fg (has_nndist (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_104402 (h0 : list (cancel_monoid name)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_104403 (h1 : not (topological_space linarith.comp_source -> false)) : @totally_separated_space.{0} linarith.comp_source (@classical.by_contradiction'.{1} (topological_space.{0} linarith.comp_source) h1)  := sorry --non-trivial
lemma new_lemma_104404 (h0 : ring (has_to_string (ring linarith.comp))) : strong_rank_condition (has_to_string (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_104405 (h0 : num -> linarith.comp -> Prop) : relator.right_unique h0 := sorry --non-trivial
lemma new_lemma_104406 (h0 : uniform_space (normed_lattice_add_comm_group (has_bot real))) : complete_space (normed_lattice_add_comm_group (has_bot real)) := sorry --non-trivial
lemma new_lemma_104407 (h0 : has_lt (has_ssubset string.iterator_imp)) : no_max_order (has_ssubset string.iterator_imp) := sorry --non-trivial
lemma new_lemma_104408 (h0 : not (add_monoid (option unsigned) -> false)) : @add_monoid.fg.{0} (option.{0} unsigned) (@classical.by_contradiction'.{1} (add_monoid.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_104409 (h0 : set stieltjes_function) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_104410 (h0 : group (finset (has_neg (has_neg linarith.comp)))) : is_cyclic (finset (has_neg (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_104411 (h0 : ring (comm_semigroup (has_pos_part real))) : strong_rank_condition (comm_semigroup (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_104412 (h0 : list (random_gen (random_gen (random_gen linarith.comp_source)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_104413 (h1 : ring (semi_normed_comm_ring fun_info)) : rank_condition (semi_normed_comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_104414 (h0 : functor.add_const (topological_space (comm_group ennreal)) Type) : @totally_disconnected_space.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_104415 (h0 : filter (dlist to_additive.value_type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_104416 (h0 : functor.add_const (semiring (add_cancel_monoid name)) linarith.comp) : @is_noetherian_ring.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (add_cancel_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_104417 (h0 : not (group linarith.ineq -> false)) : @is_cyclic.{0} linarith.ineq (@classical.by_contradiction'.{1} (group.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_104418 (h0 : not (has_lt (mul_one_class char) -> false) -> has_lt (mul_one_class char)) (h1 : nonempty (has_lt (mul_one_class char))) : @no_max_order.{0} (mul_one_class.{0} char) (@classical.choice_of_by_contradiction'.{1} (has_lt.{0} (mul_one_class.{0} char)) h0 h1)  := sorry --non-trivial
lemma new_lemma_104419 (h0 : ring (sub_neg_monoid name)) : strong_rank_condition (sub_neg_monoid name) := sorry --non-trivial
lemma new_lemma_104420 (h0 : functor.add_const (add_monoid (ordered_ring empty)) (semiring (semiring (semiring num)))) : @add_monoid.fg.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (ordered_ring.{0} empty)) (semiring.{0} (semiring.{0} (semiring.{0} num))) h0)  := sorry --non-trivial
lemma new_lemma_104421 (h0 : ring (normed_comm_ring (semigroup (semigroup (comm_group name))))) : is_principal_ideal_ring (normed_comm_ring (semigroup (semigroup (comm_group name)))) := sorry --non-trivial
lemma new_lemma_104422 (h0 : complete_lattice (with_bot (semiring (random_gen (normed_group num))))) : is_atomistic (with_bot (semiring (random_gen (normed_group num)))) := sorry --non-trivial
lemma new_lemma_104423 (h1 : not (group (denumerable char) -> false)) : @is_cyclic.{0} (denumerable.{0} char) (@classical.by_contradiction'.{1} (group.{0} (denumerable.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_104424 (h0 : uniform_space (ordered_comm_monoid (ordered_comm_monoid (has_Inf (has_Inf real))))) : separated_space (ordered_comm_monoid (ordered_comm_monoid (has_Inf (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_104425 (h0 : functor.add_const (function.extfun (Type 1) monoid) Type) : @monoid.fg.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) monoid.{1}) Type h0) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_104426 (h0 : functor.add_const (finset (boolean_algebra unsigned)) (has_add (ordered_cancel_add_comm_monoid name))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_104427 (h0 : functor.add_const (topological_space (has_zero unsigned)) Type) : @loc_path_connected_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_104428 (h0 : functor.add_const (topological_space pos) (option (option pos))) : @t1_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) (option.{0} (option.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_104429 (h0 : uniform_space (normed_group (random_gen (measurable_space num)))) : separated_space (normed_group (random_gen (measurable_space num))) := sorry --non-trivial
lemma new_lemma_104430 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @topological_space.separable_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_104431 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_104432 (h0 : function.extfun (Type 1) group) : @normalizer_condition.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_104433 (h1 : uniform_space (complete_semilattice_Sup (with_bot to_additive.value_type))) : complete_space (complete_semilattice_Sup (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_104434 (h2 : complete_lattice (has_add (has_inv to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (has_add (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_104435 (h0 : function.extfun (set fun_info) (fun (x : set fun_info), Prop)) : is_countably_spanning (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_104436 (h0 : group (has_inv (with_bot string_imp))) : is_cyclic (has_inv (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_104437 (h0 : not (ring (has_union congr_arg_kind) -> false)) : @strong_rank_condition.{0} (has_union.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (has_union.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_104438 (h0 : ring (uniform_space (random_gen (has_nnnorm (random_gen char))))) : is_domain (uniform_space (random_gen (has_nnnorm (random_gen char)))) := sorry --non-trivial
lemma new_lemma_104439 (h1 : group (measurable_space (semiring linarith.comp))) : normalizer_condition (measurable_space (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_104440 (h1 : function.extfun Type uniform_space) : @complete_space.{0} (with_bot.{0} string_imp) (@function.extfun_app.{2 1} Type uniform_space.{0} h1 (with_bot.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_104441 (h0 : complete_lattice (measurable_space.dynkin_system (semiring empty))) : is_atomistic (measurable_space.dynkin_system (semiring empty)) := sorry --non-trivial
lemma new_lemma_104442 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (omega_complete_partial_order.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (omega_complete_partial_order.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_104443 (h0 : ring (boolean_algebra (normed_comm_ring Type))) : is_domain (boolean_algebra (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_104444 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_104445 (h0 : topological_space (has_to_string (add_cancel_monoid Type))) : sequential_space (has_to_string (add_cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_104446 (h0 : not (uniform_space (distrib reducibility_hints) -> false)) : @complete_space.{0} (distrib.{0} reducibility_hints) (@classical.by_contradiction'.{1} (uniform_space.{0} (distrib.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_104447 (h0 : function.extfun (Type 1) topological_space) : @discrete_topology.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_104448 (h0 : topological_space (add_semigroup unsigned)) : totally_disconnected_space (add_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_104449 (h0 : uniform_space (has_sub (has_one (semiring empty)))) : separated_space (has_sub (has_one (semiring empty))) := sorry --non-trivial
lemma new_lemma_104450 (h0 : functor.add_const (topological_space (has_dist empty)) congr_arg_kind) : @discrete_topology.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_104451 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_104452 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type semiring.{0} h0 (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_104453 (h4 : set (normed_field (add_comm_semigroup string.iterator_imp))) : set.finite h4 := sorry --non-trivial
lemma new_lemma_104454 (h0 : functor.add_const (complete_lattice (comm_group pos)) environment.implicit_infer_kind) : @is_compactly_generated.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_104455 (h0 : uniform_space (with_one empty)) : separated_space (with_one empty) := sorry --non-trivial
lemma new_lemma_104456 (h0 : functor.add_const (function.extfun (Type 1) add_group) pos) : @is_add_cyclic.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_group.{1}) pos h0) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_104457 (h0 : ring (has_nnnorm (mul_one_class (mul_one_class (mul_one_class linarith.comp_source))))) : rank_condition (has_nnnorm (mul_one_class (mul_one_class (mul_one_class linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_104458 (h0 : topological_space (add_cancel_monoid congr_arg_kind)) : discrete_topology (add_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_104459 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_104460 (h0 : topological_space (has_neg_part (option unsigned))) : totally_separated_space (has_neg_part (option unsigned)) := sorry --non-trivial
lemma new_lemma_104461 (h0 : ring (cancel_monoid empty)) : rank_condition (cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_104462 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (semilattice_inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (semilattice_inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_104463 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @t0_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_104464 (h1 : topological_space (normed_group congr_arg_kind)) : path_connected_space (normed_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_104465 (h0 : ordered_comm_monoid (ring (has_to_string linarith.comp))) : has_exists_mul_of_le (ring (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_104466 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_104467 (h1 : not (topological_space (measurable_space empty) -> false)) : @normal_space.{0} (measurable_space.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} empty)) h1)  := sorry --non-trivial
lemma new_lemma_104468 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_104469 (h0 : not (ring (with_bot empty) -> false)) : @rank_condition.{0} (with_bot.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (with_bot.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_104470 (h0 : topological_space (has_inv to_additive.value_type)) : locally_compact_space (has_inv to_additive.value_type) := sorry --non-trivial
lemma new_lemma_104471 (h0 : prod (finset (option (option (option pos)))) (finset (option (option (option pos))))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_104472 (h0 : topological_space (ordered_comm_monoid (has_add Type))) : normal_space (ordered_comm_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_104473 (h1 : topological_space (simple_graph (mul_one_class (random_gen linarith.ineq)))) : path_connected_space (simple_graph (mul_one_class (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_104474 (h1 : topological_space fun_info) (h2 : preorder fun_info) : order_closed_topology fun_info := sorry --non-trivial
lemma new_lemma_104475 (h0 : ring (has_zero (add_comm_monoid name))) : rank_condition (has_zero (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_104476 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (mul_zero_class.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (mul_zero_class.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_104477 (h0 : functor.add_const (topological_space (bin_tree num)) empty) : @normal_space.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_104478 (h0 : fin has_zero.zero) : @separated_space.{0} (canonically_linear_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (uniform_space.{0} (canonically_linear_ordered_monoid.{0} linarith.comp)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_104479 (h1 : has_le (add_comm_semigroup (normed_field string.iterator_imp))) (h2 : add_comm_semigroup (normed_field string.iterator_imp)) : is_bot h2 := sorry --non-trivial
lemma new_lemma_104480 (h0 : group (finset (finset environment.implicit_infer_kind))) : is_simple_group (finset (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_104481 (h0 : topological_space (mul_zero_class (has_add (has_add Type)))) : locally_compact_space (mul_zero_class (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_104482 (h0 : functor.add_const (topological_space (semigroup name)) linarith.comp) : @totally_disconnected_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_104483 : nonempty (with_top std_gen) := sorry --simp
lemma new_lemma_104484 (h0 : ring (finset (option (option empty)))) : is_domain (finset (option (option empty))) := sorry --non-trivial
lemma new_lemma_104485 (h0 : list (has_to_string (has_pos_part (has_Inf linarith.comp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_104486 (h1 : topological_space (semi_normed_ring string.iterator_imp)) : t0_space (semi_normed_ring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_104487 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_104488 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} name (@function.extfun_app.{2 1} Type add_monoid.{0} h0 name)  := sorry --non-trivial
lemma new_lemma_104489 (h3 : topological_space congr_arg_kind) : path_connected_space congr_arg_kind := sorry --non-trivial
lemma new_lemma_104490 (h0 : topological_space (has_add (option (option congr_arg_kind)))) : t1_space (has_add (option (option congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_104491 (h0 : semiring (has_one (has_norm (with_bot (has_union unsigned))))) : is_noetherian_ring (has_one (has_norm (with_bot (has_union unsigned)))) := sorry --non-trivial
lemma new_lemma_104492 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (as_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (as_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_104493 (h0 : group (has_to_string (has_add linarith.comp))) : group.fg (has_to_string (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_104494 (h0 : topological_space (add_group congr_arg_kind)) : totally_disconnected_space (add_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_104495 (h0 : functor.add_const (ring (has_to_string Type)) name) : @rank_condition.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_to_string.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_104496 (h0 : complete_lattice (has_emptyc (has_top (has_top linarith.comp_source)))) : is_compactly_generated (has_emptyc (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_104497 (h0 : functor.add_const (filter (has_zero pos)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_104498 (h0 : functor.add_const (topological_space (semigroup Type)) name) : @discrete_topology.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_104499 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_104500 (h1 : function.extfun Type topological_space) : @totally_separated_space.{0} (@id.{2} Type to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (@id.{2} Type to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_104501 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg_part.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_neg_part.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_104502 (h0 : function.extfun nat fin) : @discrete_topology.{0} (has_to_string.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_to_string.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_104503 (h0 : topological_space (canonically_ordered_monoid (has_Inf pos))) : totally_separated_space (canonically_ordered_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_104504 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_104505 (h0 : finset (monoid (option unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_104506 (h0 : topological_space (semi_normed_comm_ring enat)) : totally_disconnected_space (semi_normed_comm_ring enat) := sorry --non-trivial
lemma new_lemma_104507 (h0 : with_bot pnat) (h1 : ne h0 has_bot.bot) (h2 : fin has_zero.zero) : pnat.coprime (with_bot.unbot h0 h1) (matrix.vec_empty (id h2)) := sorry --non-trivial
lemma new_lemma_104508 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_104509 (h0 : functor.add_const (function.extfun Type ring) linarith.comp) : @strong_rank_condition.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) linarith.comp h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_104510 (h0 : functor.add_const (topological_space nnreal) unsigned) : preirreducible_space nnreal := sorry --non-trivial
lemma new_lemma_104511 (h0 : group (normed_lattice_add_comm_group (has_add (has_add (has_add real))))) : is_simple_group (normed_lattice_add_comm_group (has_add (has_add (has_add real)))) := sorry --non-trivial
lemma new_lemma_104512 (h0 : topological_space (normed_comm_ring name)) : topological_space.separable_space (normed_comm_ring name) := sorry --non-trivial
lemma new_lemma_104513 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (canonically_ordered_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_ordered_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_104514 (h0 : ring (add_comm_monoid (ring (ring linarith.comp)))) : is_domain (add_comm_monoid (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_104515 (h0 : monoid (complete_semilattice_Sup (random_gen to_additive.value_type))) : monoid.fg (complete_semilattice_Sup (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_104516 (h0 : topological_space (has_bot (boolean_algebra pos))) : locally_compact_space (has_bot (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_104517 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_separated_space.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_104518 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (@id.{2} Type linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (@id.{2} Type linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_104519 (h0 : function.extfun Type option) (h1 : coe_sort (option.is_some (function.extfun_app h0 Prop))) : option.get h1 := sorry --non-trivial
lemma new_lemma_104520 (h0 : topological_space (denumerable (random_gen (random_gen char)))) : t0_space (denumerable (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_104521 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_104522 (h0 : functor.add_const (ring (free_add_monoid congr_arg_kind)) unsigned) : @is_principal_ideal_ring.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (free_add_monoid.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_104523 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_104524 (h0 : list Prop) : id (list.head (id (id h0))) := sorry --non-trivial
lemma new_lemma_104525 (h0 : topological_space (linear_ordered_comm_group_with_zero string.iterator_imp)) : path_connected_space (linear_ordered_comm_group_with_zero string.iterator_imp) := sorry --non-trivial
lemma new_lemma_104526 (h0 : uniform_space (canonically_ordered_comm_semiring congr_arg_kind)) : complete_space (canonically_ordered_comm_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_104527 (h0 : add_group (has_top (has_top (has_top num)))) : is_add_cyclic (has_top (has_top (has_top num))) := sorry --non-trivial
lemma new_lemma_104528 (h0 : cancel_comm_monoid_with_zero (add_cancel_monoid (has_neg_part (has_add Type)))) : unique_factorization_monoid (add_cancel_monoid (has_neg_part (has_add Type))) := sorry --non-trivial
lemma new_lemma_104529 (h0 : function.extfun Type (functor.add_const (topological_space (preorder empty)))) : @loc_path_connected_space.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (preorder.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_104530 (h0 : filter (has_inv (random_gen (random_gen (random_gen (has_norm to_additive.value_type)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_104531 (h0 : functor.add_const (group (has_neg name)) name) : @group.fg.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_104532 (h0 : uniform_space (semi_normed_ring (metric_space to_additive.value_type))) : complete_space (semi_normed_ring (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_104533 (h0 : functor.add_const (list (has_to_string name)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_104534 (h0 : topological_space (has_add (has_Inf Type))) : loc_path_connected_space (has_add (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_104535 (h0 : add_group (ring (has_neg pos))) : is_add_cyclic (ring (has_neg pos)) := sorry --non-trivial
lemma new_lemma_104536 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (add_left_cancel_monoid.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (add_left_cancel_monoid.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_104537 (h0 : topological_space (has_add (has_add real))) : discrete_topology (has_add (has_add real)) := sorry --non-trivial
lemma new_lemma_104538 (h0 : with_bot pnat) (h1 : ne h0 has_bot.bot) (h2 : pnat) : pnat.coprime (id (with_bot.unbot h0 h1)) h2 := sorry --non-trivial
lemma new_lemma_104539 (h1 : complete_lattice (normed_field (denumerable (comm_ring reducibility_hints)))) : is_compactly_generated (normed_field (denumerable (comm_ring reducibility_hints))) := sorry --non-trivial
lemma new_lemma_104540 (h0 : add_group (mul_zero_class congr_arg_kind)) : is_add_cyclic (mul_zero_class congr_arg_kind) := sorry --non-trivial
lemma new_lemma_104541 (h0 : topological_space (metric_space (semiring unsigned))) : irreducible_space (metric_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_104542 (h0 : topological_space (comm_group (normed_comm_ring Type))) : path_connected_space (comm_group (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_104543 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_104544 (h0 : fin has_zero.zero) : @group.fg.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) h0) (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_104545 (h0 : nat) (h1 : fin (nat.succ h0) -> Prop) (h2 : false) : matrix.vec_tail h1 (false.elim h2) := sorry --trivial
lemma new_lemma_104546 (h0 : not (measurable_space (has_compl reducibility_hints) -> false)) (h1 : not (filter (has_compl reducibility_hints) -> false)) : @filter.is_measurably_generated.{0} (has_compl.{0} reducibility_hints) (@classical.by_contradiction'.{1} (measurable_space.{0} (has_compl.{0} reducibility_hints)) h0) (@classical.by_contradiction'.{1} (filter.{0} (has_compl.{0} reducibility_hints)) h1)  := sorry --non-trivial
lemma new_lemma_104547 (h0 : functor.add_const (finset (has_neg linarith.comp)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_104548 (h0 : filter (linear_ordered_comm_group congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_104549 (h0 : topological_space (free_add_monoid congr_arg_kind)) : loc_path_connected_space (free_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_104550 (h0 : not (complete_lattice (semiring linarith.comp_source) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semiring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_104551 (h0 : functor.add_const (list (normed_comm_ring Type)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_104552 (h0 : has_lt (add_comm_semigroup fun_info)) : no_max_order (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_104553 (h0 : functor.add_const (function.extfun Type complete_lattice) Type) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type complete_lattice.{0}) Type h0) (canonically_ordered_comm_semiring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_104554 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (non_assoc_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (non_assoc_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_104555 (h0 : functor.add_const (function.extfun nat fin) Type) : @is_simple_group.{0} pos (@matrix.vec_empty.{0} (group.{0} pos) (@function.extfun_app.{1 1} nat fin (@functor.add_const.run.{0 1} (function.extfun.{1 1} nat fin) Type h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_104556 (h0 : filter string) (h1 : ring (filter.germ h0 unsigned)) : is_domain (filter.germ h0 unsigned) := sorry --non-trivial
lemma new_lemma_104557 (h0 : functor.add_const (ring (free_add_monoid unsigned)) unsigned) : @rank_condition.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (free_add_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_104558 (h0 : complete_lattice (random_gen (has_nnnorm fun_info))) : is_compactly_generated (random_gen (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_104559 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) pos) : @t1_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_104560 (h1 : has_nnnorm fun_info -> has_nnnorm fun_info -> Prop) : is_trans (has_nnnorm fun_info) h1 := sorry --non-trivial
lemma new_lemma_104561 (h0 : functor.add_const (topological_space (ordered_ring congr_arg_kind)) num) : @t1_space.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_104562 (h0 : topological_space (comm_group (has_neg (has_neg linarith.comp)))) : totally_disconnected_space (comm_group (has_neg (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_104563 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_104564 (h0 : uniform_space (has_div (mul_one_class (mul_one_class enat)))) : complete_space (has_div (mul_one_class (mul_one_class enat))) := sorry --non-trivial
lemma new_lemma_104565 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (finset.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (finset.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_104566 (h0 : functor.add_const (topological_space (option name)) (option (option unsigned))) : @totally_disconnected_space.{0} (option.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} name)) (option.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_104567 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf (has_add Type)))) : normal_space (normed_lattice_add_comm_group (has_Inf (has_add Type))) := sorry --non-trivial
lemma new_lemma_104568 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_104569 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @totally_disconnected_space.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_104570 (h0 : function.extfun Type (functor.add_const (ring Type))) : @rank_condition.{1} Type (@functor.add_const.run.{1 0} (ring.{1} Type) environment.implicit_infer_kind (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (ring.{1} Type)) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_104571 (h0 : has_lt (has_lt (mul_one_class enat))) : no_max_order (has_lt (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_104572 (h0 : topological_space (has_emptyc (random_gen (random_gen (random_gen linarith.comp))))) : path_connected_space (has_emptyc (random_gen (random_gen (random_gen linarith.comp)))) := sorry --non-trivial
lemma new_lemma_104573 (h0 : uniform_space (mul_zero_class (semiring (semiring (semiring (semiring empty)))))) : separated_space (mul_zero_class (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_104574 (h0 : topological_space (has_nndist (finset (has_to_string (has_nndist Type))))) : sequential_space (has_nndist (finset (has_to_string (has_nndist Type)))) := sorry --non-trivial
lemma new_lemma_104575 (h0 : uniform_space (denumerable (random_gen (has_nnnorm linarith.ineq)))) : complete_space (denumerable (random_gen (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_104576 (h0 : functor.add_const (topological_space (monoid unsigned)) congr_arg_kind) : @normal_space.{0} (monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_104577 (h0 : ring (monoid (comm_monoid unsigned))) : is_domain (monoid (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_104578 (h0 : functor.add_const (function.extfun Type group) pos) : @is_cyclic.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_104579 (h0 : topological_space (omega_complete_partial_order (add_left_cancel_semigroup unsigned))) : irreducible_space (omega_complete_partial_order (add_left_cancel_semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_104580 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_104581 (h0 : functor.add_const (function.extfun Type topological_space) (has_Inf linarith.comp)) : @irreducible_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_Inf.{0} linarith.comp) h0) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_104582 (h0 : functor.add_const (group (mul_zero_class pos)) name) : @is_cyclic.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (mul_zero_class.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_104583 (h0 : ring (linear_ordered_comm_ring (semiring (semiring (semiring unsigned))))) : strong_rank_condition (linear_ordered_comm_ring (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_104584 (h0 : has_lt (mul_one_class (mul_one_class (mul_one_class (mul_one_class (mul_one_class ereal)))))) : no_max_order (mul_one_class (mul_one_class (mul_one_class (mul_one_class (mul_one_class ereal))))) := sorry --non-trivial
lemma new_lemma_104585 (h0 : group (finset (option (option (option unsigned))))) : normalizer_condition (finset (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_104586 (h1 : ring (mul_one_class fun_info)) : strong_rank_condition (mul_one_class fun_info) := sorry --non-trivial
lemma new_lemma_104587 (h0 : functor.add_const Prop environment.implicit_infer_kind) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_104588 (h0 : group (canonically_linear_ordered_monoid (option ennreal))) : is_simple_group (canonically_linear_ordered_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_104589 (h0 : topological_space (has_compl (mul_one_class std_gen))) : t0_space (has_compl (mul_one_class std_gen)) := sorry --non-trivial
lemma new_lemma_104590 (h0 : list (canonically_ordered_monoid Type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_104591 (h0 : bool) (h1 h2 : topological_space (mul_one_class char)) (h3 : set (mul_one_class char)) : is_path_connected h3 := sorry --non-trivial
lemma new_lemma_104592 (h0 : topological_space (ordered_comm_group (semiring empty))) : loc_path_connected_space (ordered_comm_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_104593 (h0 : has_mem.mem (complete_semilattice_Sup linarith.comp_source) has_emptyc.emptyc) : @is_domain.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (complete_semilattice_Sup.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_104594 (h0 : topological_space empty -> Prop) : totally_disconnected_space empty := sorry --non-trivial
lemma new_lemma_104595 (h0 : not (topological_space (linear_order empty) -> false)) : @locally_compact_space.{0} (linear_order.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_104596 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} h0 linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_104597 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_add_comm_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_104598 (h0 : ring (boolean_algebra (comm_semigroup real))) : rank_condition (boolean_algebra (comm_semigroup real)) := sorry --non-trivial
lemma new_lemma_104599 (h0 : uniform_space (semigroup (has_nndist (finset Type)))) : separated_space (semigroup (has_nndist (finset Type))) := sorry --non-trivial
lemma new_lemma_104600 (h0 : fin has_zero.zero) : @monoid.fg.{0} (has_nndist.{0} linarith.comp) (@matrix.vec_empty.{0} (monoid.{0} (has_nndist.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_104601 (h0 : not (function.extfun Type filter -> false)) : @filter.Limsup.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice) (@function.extfun_app.{2 1} Type filter.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type filter.{0}) h0) Prop)  := sorry --non-trivial
lemma new_lemma_104602 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} pos (@matrix.vec_empty.{0} (topological_space.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_104603 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} h0 (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_104604 (h0 : functor.add_const (topological_space (mul_zero_class Type)) Type) : @t0_space.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (mul_zero_class.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_104605 (h0 : topological_space (has_nndist (boolean_algebra (has_neg linarith.comp)))) : totally_disconnected_space (has_nndist (boolean_algebra (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_104606 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measure_theory.measure_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_104607 (h0 : not (topological_space unsigned -> false)) : @path_connected_space.{0} unsigned (@classical.by_contradiction'.{1} (topological_space.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_104608 (h0 : functor.add_const (monoid (cancel_monoid pos)) pos) : @monoid.fg.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_104609 (h0 : ring (finset (option (option (option pos))))) : strong_rank_condition (finset (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_104610 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_104611 (h0 : functor.add_const (complete_lattice (has_add pos)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_add.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_104612 (h0 : ring (denumerable (has_add linarith.comp_source))) : strong_rank_condition (denumerable (has_add linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_104613 (h0 : uniform_space (has_repr (random_gen fun_info))) : complete_space (has_repr (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_104614 (h0 : functor.add_const (group pos) (option unsigned)) : @is_simple_group.{0} pos (@functor.add_const.run.{0 0} (group.{0} pos) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_104615 (h0 : topological_space (linear_ordered_comm_ring empty)) : irreducible_space (linear_ordered_comm_ring empty) := sorry --non-trivial
lemma new_lemma_104616 (h0 : topological_space (boolean_algebra (has_neg (has_Inf Type)))) : normal_space (boolean_algebra (has_neg (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_104617 (h0 : topological_space (complete_distrib_lattice (has_add real))) : locally_compact_space (complete_distrib_lattice (has_add real)) := sorry --non-trivial
lemma new_lemma_104618 (h0 : functor.add_const (topological_space (has_neg_part Type)) pos) : @normal_space.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg_part.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_104619 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @locally_compact_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_104620 (h0 : topological_space (mul_zero_class (cancel_monoid pos))) : path_connected_space (mul_zero_class (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_104621 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_104622 (h0 : function.extfun Type (functor.add_const (finset (semigroup empty)))) : finset.nonempty (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_104623 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_104624 (h0 : group (has_repr (random_gen fun_info))) : is_cyclic (has_repr (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_104625 (h0 : function.extfun (Type 1) topological_space) : @normal_space.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_104626 (h0 : functor.add_const (group (has_neg name)) Type) : @group.fg.{0} (has_neg.{0} name) (@functor.add_const.run.{0 1} (group.{0} (has_neg.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_104627 (h0 : not (ring (has_star unsigned) -> false)) : @is_principal_ideal_ring.{0} (has_star.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (has_star.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_104628 (h0 : topological_space (has_dist ennreal)) : normal_space (has_dist ennreal) := sorry --non-trivial
lemma new_lemma_104629 (h0 : ordered_comm_monoid (has_Inf (has_neg (has_neg (ring environment.implicit_infer_kind))))) : has_exists_mul_of_le (has_Inf (has_neg (has_neg (ring environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_104630 (h0 : group (boolean_algebra (ring (has_neg (finset pos))))) : is_simple_group (boolean_algebra (ring (has_neg (finset pos)))) := sorry --non-trivial
lemma new_lemma_104631 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_ssubset.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_ssubset.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_104632 (h0 : has_ssubset fun_info -> has_ssubset fun_info -> bool) : is_dec_refl h0 := sorry --non-trivial
lemma new_lemma_104633 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_104634 (h0 : filter (normed_comm_ring (add_comm_monoid environment.implicit_infer_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_104635 (h0 : not (topological_space (non_unital_non_assoc_semiring string.iterator_imp) -> false)) : @t0_space.{0} (non_unital_non_assoc_semiring.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (non_unital_non_assoc_semiring.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_104636 (h0 : functor.add_const (topological_space (has_inv empty)) empty) (h1 : function.extfun Type measurable_space) : @opens_measurable_space.{0} (has_inv.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_inv.{0} empty)) empty h0) (@function.extfun_app.{2 1} Type measurable_space.{0} h1 (has_inv.{0} empty))  := sorry --non-trivial
lemma new_lemma_104637 (h0 : not (function.extfun Type topological_space -> false)) : @preirreducible_space.{0} (complete_linear_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (complete_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_104638 (h0 : ordered_comm_monoid (finset (finset environment.implicit_infer_kind))) : has_exists_mul_of_le (finset (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_104639 (h0 : complete_lattice (canonically_ordered_add_monoid empty)) : is_atomistic (canonically_ordered_add_monoid empty) := sorry --non-trivial
lemma new_lemma_104640 (h0 : topological_space (linear_ordered_comm_ring (linear_ordered_comm_ring congr_arg_kind))) : discrete_topology (linear_ordered_comm_ring (linear_ordered_comm_ring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_104641 (h0 : functor.add_const (ring (linear_order unsigned)) empty) : @strong_rank_condition.{0} (linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (linear_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_104642 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (partial_order empty)) := sorry --non-trivial
lemma new_lemma_104643 (h0 : topological_space (has_add (ring pos))) : normal_space (has_add (ring pos)) := sorry --non-trivial
lemma new_lemma_104644 (h0 : functor.add_const (cancel_comm_monoid_with_zero (normed_linear_ordered_group empty)) empty) : @unique_factorization_monoid.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (normed_linear_ordered_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_104645 (h0 : add_group (has_neg_part name)) : is_add_cyclic (has_neg_part name) := sorry --non-trivial
lemma new_lemma_104646 (h0 : ring (distrib (has_lt string_imp))) : strong_rank_condition (distrib (has_lt string_imp)) := sorry --non-trivial
lemma new_lemma_104647 (h0 : topological_space (ordered_comm_ring (finset Type))) : discrete_topology (ordered_comm_ring (finset Type)) := sorry --non-trivial
lemma new_lemma_104648 (h0 : complete_lattice (denumerable (distrib (has_nnnorm linarith.ineq)))) : is_compactly_generated (denumerable (distrib (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_104649 (h0 : function.extfun Type group) : @group.fg.{0} (with_one.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (with_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_104650 (h0 : complete_lattice (ring pos)) : is_atomistic (ring pos) := sorry --non-trivial
lemma new_lemma_104651 (h0 : topological_space (semigroup (option empty))) : totally_separated_space (semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_104652 (h0 : topological_space (has_pos_part (has_pos_part (has_pos_part Type)))) : irreducible_space (has_pos_part (has_pos_part (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_104653 (h0 : topological_space (has_bot real)) : path_connected_space (has_bot real) := sorry --non-trivial
lemma new_lemma_104654 (h0 : function.extfun Type group) : @group.fg.{0} (@id.{2} Type fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (@id.{2} Type fun_info))  := sorry --non-trivial
lemma new_lemma_104655 (h0 : topological_space (complete_semilattice_Sup congr_arg_kind)) : discrete_topology (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_104656 (h0 : ring (add_cancel_monoid (mul_one_class linarith.comp))) : rank_condition (add_cancel_monoid (mul_one_class linarith.comp)) := sorry --non-trivial
lemma new_lemma_104657 (h0 : functor.add_const (topological_space (has_neg pos)) Type) : @t1_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_104658 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_104659 (h0 : functor.add_const (topological_space (generalized_boolean_algebra Type)) linarith.comp) : @irreducible_space.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_104660 (h0 : topological_space (canonically_ordered_comm_semiring (option pos))) : irreducible_space (canonically_ordered_comm_semiring (option pos)) := sorry --non-trivial
lemma new_lemma_104661 (h0 : functor.add_const (ordered_add_comm_monoid (finset Type)) (has_add linarith.comp)) : @archimedean.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (finset.{1} Type)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_104662 (h0 : ring (normed_field to_additive.value_type)) : strong_rank_condition (normed_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_104663 (h0 : function.extfun Type group) : @group.fg.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_104664 (h0 : ring (semi_normed_ring (random_gen (random_gen char)))) : rank_condition (semi_normed_ring (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_104665 (h0 : functor.add_const (topological_space (ordered_comm_ring Type)) linarith.comp) : @sequential_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_104666 (h0 : functor.add_const (group (is_R_or_C unsigned)) (semiring empty)) : @normalizer_condition.{0} (is_R_or_C.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (is_R_or_C.{0} unsigned)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_104667 (h1 : ring (has_div linarith.ineq)) : strong_rank_condition (has_div linarith.ineq) := sorry --non-trivial
lemma new_lemma_104668 (h0 : filter (has_one (semiring (semiring linarith.comp)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_104669 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} h0 (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_104670 (h1 : add_group (mul_one_class (mul_one_class std_gen))) : is_add_cyclic (mul_one_class (mul_one_class std_gen)) := sorry --non-trivial
lemma new_lemma_104671 (h0 : not (uniform_space (with_bot empty) -> false)) : @complete_space.{0} (with_bot.{0} empty) (@classical.by_contradiction'.{1} (uniform_space.{0} (with_bot.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_104672 (h0 : functor.add_const (ring (plift empty)) empty) : @rank_condition.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (ring.{1} (plift.{1} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_104673 (h0 : ring (normed_group (complete_lattice (random_gen linarith.comp_source)))) : strong_rank_condition (normed_group (complete_lattice (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_104674 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_104675 (h2 : topological_space (normed_field char)) : t0_space (normed_field char) := sorry --non-trivial
lemma new_lemma_104676 (h0 : functor.add_const (group (partial_order num)) unsigned) : @normalizer_condition.{0} (partial_order.{0} num) (@functor.add_const.run.{0 0} (group.{0} (partial_order.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_104677 (h0 : functor.add_const (topological_space (option congr_arg_kind)) unsigned) : @normal_space.{0} (option.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_104678 (h0 : functor.add_const (has_lt auto.case_option) num) : @no_min_order.{0} auto.case_option (@functor.add_const.run.{0 0} (has_lt.{0} auto.case_option) num h0)  := sorry --non-trivial
lemma new_lemma_104679 (h0 : topological_space (has_neg_part (finset name))) : t0_space (has_neg_part (finset name)) := sorry --non-trivial
lemma new_lemma_104680 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_neg.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_neg.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_104681 (h0 : group (sub_neg_monoid (ring pos))) : normalizer_condition (sub_neg_monoid (ring pos)) := sorry --non-trivial
lemma new_lemma_104682 (h1 : filter (distrib_lattice (has_nnnorm (has_nnnorm char)))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_104683 (h0 : functor.add_const (topological_space (mul_zero_class pos)) pos) : @totally_disconnected_space.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_104684 (h0 : topological_space (has_to_string (cancel_monoid (option unsigned)))) : topological_space.separable_space (has_to_string (cancel_monoid (option unsigned))) := sorry --non-trivial
lemma new_lemma_104685 (h0 : topological_space (id (has_norm (semiring linarith.ineq)))) : locally_compact_space (id (has_norm (semiring linarith.ineq))) := sorry --non-trivial
lemma new_lemma_104686 : @totally_disconnected_space.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} ereal))) (cofinite_topology.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} ereal))))  := sorry --non-trivial
lemma new_lemma_104687 (h0 : topological_space (id (has_norm (has_norm num)))) : locally_compact_space (id (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_104688 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_104689 (h0 : topological_space (measurable_space to_additive.value_type)) : locally_compact_space (measurable_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_104690 (h0 : topological_space (boolean_algebra linarith.comp)) : preconnected_space (boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_104691 (h0 : functor.add_const (monoid (semigroup environment.implicit_infer_kind)) (has_add pos)) : @monoid.fg.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (semigroup.{0} environment.implicit_infer_kind)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_104692 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_principal_ideal_ring.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_104693 (h0 : topological_space (add_right_cancel_monoid linarith.comp)) : totally_separated_space (add_right_cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_104694 (h0 : not (group (mul_zero_class unsigned) -> false)) : @is_cyclic.{0} (mul_zero_class.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (mul_zero_class.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_104695 (h0 : topological_space (canonically_ordered_monoid (ordered_comm_monoid linarith.comp))) : totally_separated_space (canonically_ordered_monoid (ordered_comm_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_104696 (h0 : functor.add_const (uniform_space (simple_graph Type)) linarith.comp) : @separated_space.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (simple_graph.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_104697 (h3 : complete_lattice (comm_ring char)) : is_compactly_generated (comm_ring char) := sorry --non-trivial
lemma new_lemma_104698 (h0 : ring (normed_group (has_top (has_inv fun_info)))) : is_domain (normed_group (has_top (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_104699 (h0 : complete_lattice (has_to_string (finset linarith.comp))) : is_atomistic (has_to_string (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_104700 (h0 : add_comm_monoid unsigned -> add_comm_monoid unsigned -> Prop) : total h0 := sorry --non-trivial
lemma new_lemma_104701 (h0 : functor.add_const (uniform_space (preorder num)) num) : @complete_space.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (preorder.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_104702 (h0 : functor.add_const (function.extfun (Type 1) monoid) (ring Type)) : @monoid.fg.{1} (add_group_with_zero_nhd.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) monoid.{1}) (ring.{1} Type) h0) (add_group_with_zero_nhd.{1} Type))  := sorry --non-trivial
lemma new_lemma_104703 (h0 : topological_space (fintype linarith.ineq)) : locally_compact_space (fintype linarith.ineq) := sorry --non-trivial
lemma new_lemma_104704 (h0 : ring (semi_normed_comm_ring (has_nnnorm linarith.comp_source))) : rank_condition (semi_normed_comm_ring (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_104705 (h0 : topological_space (generalized_boolean_algebra (has_neg name))) : sequential_space (generalized_boolean_algebra (has_neg name)) := sorry --non-trivial
lemma new_lemma_104706 (h0 : functor.add_const (topological_space (add_cancel_monoid ennreal)) num) : @normal_space.{0} (add_cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_104707 (h0 : finset (option (option (option (option (option ennreal)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_104708 (h0 : functor.add_const (add_monoid (simple_graph Type)) Type) : @add_monoid.fg.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 1} (add_monoid.{1} (simple_graph.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_104709 (h0 : functor.add_const (uniform_space (has_neg pos)) Type) : @separated_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_neg.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_104710 (h0 : topological_space (has_to_string linarith.comp)) : topological_space.separable_space (has_to_string linarith.comp) := sorry --non-trivial
lemma new_lemma_104711 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} h0 (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_104712 (h0 : functor.add_const (topological_space (pseudo_metric_space unsigned)) (option (option pos))) : @preconnected_space.{0} (pseudo_metric_space.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} unsigned)) (option.{0} (option.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_104713 (h0 : functor.add_const (topological_space (has_neg Type)) Type) : @preirreducible_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_neg.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_104714 (h0 : ring (semi_normed_comm_ring linarith.comp_source)) : strong_rank_condition (semi_normed_comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_104715 (h0 : list (cancel_monoid (option congr_arg_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_104716 (h0 : topological_space (has_zero (has_to_string (comm_group Type)))) : preconnected_space (has_zero (has_to_string (comm_group Type))) := sorry --non-trivial
lemma new_lemma_104717 (h1 : function.extfun Type uniform_space) : @complete_space.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} h1 (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_104718 (h0 : has_mem.mem (has_union num) has_zero.zero) : id_rel (multiset.pi.empty (prod (has_union num)) (has_union num) h0) := sorry --non-trivial
lemma new_lemma_104719 (h0 : not (topological_space (has_top linarith.ineq) -> false)) : @t0_space.{0} (has_top.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_104720 (h0 : function.extfun Type (functor.add_const (uniform_space (free_add_monoid unsigned)))) : @separated_space.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (free_add_monoid.{0} unsigned)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (free_add_monoid.{0} unsigned))) h0 num))  := sorry --non-trivial
lemma new_lemma_104721 (h0 : topological_space (linear_order (option (option unsigned)))) : locally_compact_space (linear_order (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_104722 (h0 : functor.add_const (topological_space (linear_ordered_comm_monoid_with_zero empty)) empty) : @preirreducible_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_104723 (h0 : functor.add_const (cancel_comm_monoid_with_zero (plift num)) empty) : @unique_factorization_monoid.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (plift.{1} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_104724 (h0 : add_monoid (canonically_ordered_comm_semiring ennreal)) : add_monoid.fg (canonically_ordered_comm_semiring ennreal) := sorry --non-trivial
lemma new_lemma_104725 (h1 : ring (id congr_arg_kind)) : is_domain (id congr_arg_kind) := sorry --non-trivial
lemma new_lemma_104726 (h0 : topological_space (random_gen (has_inv linarith.comp_source))) : totally_disconnected_space (random_gen (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_104727 (h0 : topological_space (cancel_monoid (finset Type))) : path_connected_space (cancel_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_104728 (h0 : topological_space (has_neg_part (has_nndist (has_nndist ennreal)))) : loc_path_connected_space (has_neg_part (has_nndist (has_nndist ennreal))) := sorry --non-trivial
lemma new_lemma_104729 (h0 : topological_space (id (semiring num))) : irreducible_space (id (semiring num)) := sorry --non-trivial
lemma new_lemma_104730 (h0 : complete_lattice (normed_field linarith.comp_source)) : is_compactly_generated (normed_field linarith.comp_source) := sorry --non-trivial
lemma new_lemma_104731 (h0 : ring (has_top congr_arg_kind)) : strong_rank_condition (has_top congr_arg_kind) := sorry --non-trivial
lemma new_lemma_104732 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (complete_semilattice_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_104733 (h0 : ring (with_zero (random_gen (random_gen (has_ssubset linarith.ineq))))) : rank_condition (with_zero (random_gen (random_gen (has_ssubset linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_104734 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system num)) empty) : @t1_space.{0} (measurable_space.dynkin_system.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_104735 (h0 : complete_lattice (has_zero (add_cancel_monoid environment.implicit_infer_kind))) : is_atomistic (has_zero (add_cancel_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_104736 (h0 : uniform_space (canonically_ordered_comm_semiring (option empty))) : complete_space (canonically_ordered_comm_semiring (option empty)) := sorry --non-trivial
lemma new_lemma_104737 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 group.{0}) (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_104738 (h0 : finset (has_add Type)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_104739 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_104740 (h0 : ring (semi_normed_ring char)) : is_domain (semi_normed_ring char) := sorry --non-trivial
lemma new_lemma_104741 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_104742 (h0 : functor.add_const (topological_space (ring Type)) (semigroup linarith.comp)) : @sequential_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) (semigroup.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_104743 (h1 : uniform_space (measurable_space linarith.comp)) : separated_space (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_104744 (h0 : list (has_ssubset (linear_ordered_add_comm_group (random_gen (random_gen (has_ssubset fun_info)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_104745 (h0 : fin has_zero.zero) : @is_add_cyclic.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (add_group.{1} (boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_104746 (h0 : group (canonically_ordered_monoid (ordered_comm_monoid (has_bot Type)))) : is_simple_group (canonically_ordered_monoid (ordered_comm_monoid (has_bot Type))) := sorry --non-trivial
lemma new_lemma_104747 (h0 : topological_space (normed_group unsigned)) (h1 : preorder (normed_group unsigned)) : order_closed_topology (normed_group unsigned) := sorry --non-trivial
lemma new_lemma_104748 (h0 : list (topological_space (div_inv_monoid linarith.comp_source))) : @t0_space.{0} (div_inv_monoid.{0} linarith.comp_source) (@list.head.{0} (topological_space.{0} (div_inv_monoid.{0} linarith.comp_source)) (@inhabited_topological_space.{0} (div_inv_monoid.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_104749 (h0 : function.extfun (Type 1) topological_space) : @topological_space.separable_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_104750 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (ring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} num))  := sorry --non-trivial
lemma new_lemma_104751 (h0 : has_mem.mem (measurable_space (has_top fun_info)) has_emptyc.emptyc) : @normal_space.{0} (measurable_space.{0} (has_top.{0} fun_info)) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} (has_top.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_104752 (h0 : functor.add_const (topological_space (has_add name)) name) : @normal_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_104753 (h0 : topological_space (has_norm (has_top num))) : t0_space (has_norm (has_top num)) := sorry --non-trivial
lemma new_lemma_104754 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) name) : @totally_separated_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_104755 (h0 : functor.add_const (topological_space (has_Sup congr_arg_kind)) num) : @t0_space.{0} (has_Sup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_104756 (h0 : topological_space (has_to_string environment.implicit_infer_kind)) : regular_space (has_to_string environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_104757 (h0 : ring (add_comm_monoid (finset (has_to_string (finset (finset pos)))))) : is_domain (add_comm_monoid (finset (has_to_string (finset (finset pos))))) := sorry --non-trivial
lemma new_lemma_104758 (h0 : functor.add_const (finset (boolean_algebra linarith.comp)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_104759 (h1 : not (add_group char -> false)) : @is_add_cyclic.{0} char (@classical.by_contradiction'.{1} (add_group.{0} char) h1)  := sorry --non-trivial
lemma new_lemma_104760 (h0 : topological_space (has_neg_part (has_add pos))) : path_connected_space (has_neg_part (has_add pos)) := sorry --non-trivial
lemma new_lemma_104761 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (lex.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (lex.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_104762 (h0 : finset (canonically_ordered_comm_semiring (has_Inf pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_104763 (h0 : ring (has_append char)) : strong_rank_condition (has_append char) := sorry --non-trivial
lemma new_lemma_104764 (h0 : not (functor.add_const Prop (measure_theory.measure_space empty) -> false)) : functor.add_const.run (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_104765 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_104766 (h0 : topological_space (has_add (has_add name))) : t0_space (has_add (has_add name)) := sorry --non-trivial
lemma new_lemma_104767 (h0 : fin has_zero.zero) : @is_noetherian_ring.{1} (canonically_linear_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) semiring.{1}) h0) (canonically_linear_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_104768 (h0 : functor.add_const (complete_lattice (has_neg environment.implicit_infer_kind)) Type) : @is_atomistic.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_neg.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_104769 (h0 : set (add_comm_semigroup reducibility_hints)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_104770 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (complete_semilattice_Sup unsigned)) := sorry --non-trivial
lemma new_lemma_104771 (h0 : function.extfun Type group) : @group.fg.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (has_norm.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_104772 (h0 : topological_space (comm_ring (has_top (has_inv fun_info)))) : path_connected_space (comm_ring (has_top (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_104773 (h0 : topological_space (random_gen (has_norm string_imp))) : t0_space (random_gen (has_norm string_imp)) := sorry --non-trivial
lemma new_lemma_104774 (h0 : functor.comp topological_space comm_group pos) : @totally_separated_space.{0} (comm_group.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_104775 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_add_cyclic.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 add_group.{1}) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_104776 (h0 : topological_space (plift (complete_distrib_lattice unsigned))) : locally_compact_space (plift (complete_distrib_lattice unsigned)) := sorry --non-trivial
lemma new_lemma_104777 (h0 : group (measurable_space (random_gen linarith.ineq))) : group.fg (measurable_space (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_104778 (h1 : not (ring (comm_ring string_imp) -> false)) : @strong_rank_condition.{0} (comm_ring.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (comm_ring.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_104779 (h0 : group (distrib_lattice (has_nnnorm (has_nnnorm (has_ssubset linarith.comp_source))))) : group.fg (distrib_lattice (has_nnnorm (has_nnnorm (has_ssubset linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_104780 (h0 : topological_space (boolean_algebra.core (has_neg Type))) : preirreducible_space (boolean_algebra.core (has_neg Type)) := sorry --non-trivial
lemma new_lemma_104781 (h0 : not (uniform_space (distrib linarith.comp_source) -> false)) : @complete_space.{0} (distrib.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (uniform_space.{0} (distrib.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_104782 (h0 : ordered_comm_monoid (comm_group (has_zero name))) : has_exists_mul_of_le (comm_group (has_zero name)) := sorry --non-trivial
lemma new_lemma_104783 (h0 : functor.add_const (functor.add_const (add_group pos) linarith.comp) Type) : @is_add_cyclic.{0} pos (@functor.add_const.run.{0 0} (add_group.{0} pos) linarith.comp (@functor.add_const.run.{0 1} (functor.add_const.{0 0} (add_group.{0} pos) linarith.comp) Type h0))  := sorry --non-trivial
lemma new_lemma_104784 (h0 : ring (semi_normed_ring (has_lt (has_nnnorm linarith.ineq)))) : rank_condition (semi_normed_ring (has_lt (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_104785 (h0 : ring (has_Inf (has_add (has_add (has_add pos))))) : strong_rank_condition (has_Inf (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_104786 (h1 : add_group (add_monoid char)) : is_add_cyclic (add_monoid char) := sorry --non-trivial
lemma new_lemma_104787 (h0 : functor.add_const (add_monoid (ordered_comm_ring name)) Type) : @add_monoid.fg.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 1} (add_monoid.{0} (ordered_comm_ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_104788 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_104789 (h0 : topological_space (has_ssubset (denumerable (comm_ring to_additive.value_type)))) : totally_disconnected_space (has_ssubset (denumerable (comm_ring to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_104790 (h0 : ring (finset (semigroup environment.implicit_infer_kind))) : is_principal_ideal_ring (finset (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_104791 (h0 : add_group (has_append (metric_space char))) : is_add_cyclic (has_append (metric_space char)) := sorry --non-trivial
lemma new_lemma_104792 (h1 : set auto.case_option) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_104793 (h0 : uniform_space (omega_complete_partial_order congr_arg_kind)) : separated_space (omega_complete_partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_104794 (h0 : ring (ring (boolean_algebra.core (has_add environment.implicit_infer_kind)))) : rank_condition (ring (boolean_algebra.core (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_104795 (h0 : fin has_zero.zero) : @monoid.fg.{0} (add_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (monoid.{0} (add_comm_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_104796 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) linarith.comp) : @discrete_topology.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_104797 (h2 : ring (has_emptyc linarith.comp)) : is_domain (has_emptyc linarith.comp) := sorry --non-trivial
lemma new_lemma_104798 (h0 : not (ring (simple_graph fun_info) -> false)) : @strong_rank_condition.{0} (simple_graph.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (simple_graph.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_104799 (h1 : topological_space (nondiscrete_normed_field (add_comm_semigroup linarith.ineq))) (h2 : set (nondiscrete_normed_field (add_comm_semigroup linarith.ineq))) : is_path_connected h2 := sorry --non-trivial
lemma new_lemma_104800 (h0 : functor.add_const (cancel_comm_monoid_with_zero (monoid pos)) pos) : @unique_factorization_monoid.{0} (monoid.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_104801 (h0 : complete_lattice (add_cancel_monoid Type)) : is_atomistic (add_cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_104802 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (add_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_104803 (h0 : topological_space (ordered_comm_monoid (sub_neg_monoid real))) : normal_space (ordered_comm_monoid (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_104804 (h0 : topological_space (has_bot (ordered_comm_ring pos))) : topological_space.separable_space (has_bot (ordered_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_104805 (h0 : function.extfun Type ring) : @is_domain.{0} (ring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_104806 (h0 : uniform_space (ordered_comm_group (semiring empty))) : separated_space (ordered_comm_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_104807 (h0 : topological_space (has_add (has_add Type))) : discrete_topology (has_add (has_add Type)) := sorry --non-trivial
lemma new_lemma_104808 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (complete_distrib_lattice.{0} real) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (complete_distrib_lattice.{0} real))  := sorry --non-trivial
lemma new_lemma_104809 (h0 : ring (dlist (random_gen linarith.comp_source))) : strong_rank_condition (dlist (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_104810 (h0 : complete_lattice (normed_comm_ring (has_add (has_add (has_add pos))))) : is_atomistic (normed_comm_ring (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_104811 (h0 : functor.add_const (group (option pos)) unsigned) : @is_cyclic.{0} (option.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (option.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_104812 (h0 : functor.add_const (complete_lattice (has_neg_part environment.implicit_infer_kind)) Type) : @is_compactly_generated.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_neg_part.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_104813 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (ring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} num))  := sorry --non-trivial
lemma new_lemma_104814 (h0 : functor.add_const (ordered_comm_monoid (has_neg pos)) Type) : @has_exists_mul_of_le.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (has_neg.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_104815 (h0 : functor.add_const (uniform_space (left_cancel_monoid num)) unsigned) : @separated_space.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (left_cancel_monoid.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_104816 (h0 : functor.add_const (topological_space (free_add_monoid num)) empty) : @locally_compact_space.{0} (free_add_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_104817 (h1 : topological_space (semiring congr_arg_kind)) : irreducible_space (semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_104818 (h0 : topological_space (comm_semigroup (sub_neg_monoid Type))) : t1_space (comm_semigroup (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_104819 (h0 : functor.add_const (complete_lattice (simple_graph Type)) Type) : @is_compactly_generated.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (simple_graph.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_104820 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) (has_add Type)) : @irreducible_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} pos)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_104821 (h0 : topological_space (add_left_cancel_semigroup (has_norm (random_gen fun_info)))) : totally_separated_space (add_left_cancel_semigroup (has_norm (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_104822 (h0 : functor.add_const (topological_space (normed_comm_ring congr_arg_kind)) num) : @t0_space.{0} (normed_comm_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_104823 (h0 : add_group (left_cancel_semigroup congr_arg_kind)) : is_add_cyclic (left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_104824 (h0 : complete_lattice (normed_lattice_add_comm_group real)) : is_compactly_generated (normed_lattice_add_comm_group real) := sorry --non-trivial
lemma new_lemma_104825 (h0 : monoid (monoid congr_arg_kind)) : monoid.fg (monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_104826 (h0 : complete_lattice (has_compl (random_gen linarith.ineq))) : is_compactly_generated (has_compl (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_104827 (h0 : group (ordered_comm_monoid (sub_neg_monoid name))) : is_simple_group (ordered_comm_monoid (sub_neg_monoid name)) := sorry --non-trivial
lemma new_lemma_104828 (h0 : monoid (normed_lattice_add_comm_group (has_Inf pos))) : monoid.fg (normed_lattice_add_comm_group (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_104829 (h0 : topological_space (comm_group name)) : loc_path_connected_space (comm_group name) := sorry --non-trivial
lemma new_lemma_104830 (h2 : semiring linarith.ineq) (h3 : linarith.ineq) : even h3 := sorry --non-trivial
lemma new_lemma_104831 (h0 : finset (has_dist num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_104832 (h0 : topological_space (measurable_space.dynkin_system (option unsigned))) : preirreducible_space (measurable_space.dynkin_system (option unsigned)) := sorry --non-trivial
lemma new_lemma_104833 (h0 : topological_space (has_bot (has_add (has_Inf Type)))) : irreducible_space (has_bot (has_add (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_104834 (h0 : topological_space (generalized_boolean_algebra (ring linarith.comp))) : preconnected_space (generalized_boolean_algebra (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_104835 (h0 : topological_space (metric_space unsigned)) : topological_space.separable_space (metric_space unsigned) := sorry --non-trivial
lemma new_lemma_104836 (h0 : functor.add_const (filter (has_zero unsigned)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_104837 (h0 : topological_space (has_nndist (option name))) : sequential_space (has_nndist (option name)) := sorry --non-trivial
lemma new_lemma_104838 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_domain.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_104839 (h0 : ring (has_append (has_ssubset char))) : is_domain (has_append (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_104840 (h0 : monoid (has_neg (has_to_string Type))) : monoid.fg (has_neg (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_104841 (h0 : not (cancel_comm_monoid_with_zero (plift unsigned) -> false)) : @unique_factorization_monoid.{1} (plift.{1} unsigned) (@classical.by_contradiction'.{2} (cancel_comm_monoid_with_zero.{1} (plift.{1} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_104842 (h0 : not (ring (mul_one_class string_imp) -> false)) : @rank_condition.{0} (mul_one_class.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (mul_one_class.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_104843 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_104844 (h0 : functor.add_const (function.extfun Type semiring) linarith.comp) : @is_noetherian_ring.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) linarith.comp h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_104845 (h0 : ring (topological_space (has_ssubset (random_gen (random_gen char))))) : rank_condition (topological_space (has_ssubset (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_104846 (h0 : uniform_space (boolean_algebra (has_add name))) : complete_space (boolean_algebra (has_add name)) := sorry --non-trivial
lemma new_lemma_104847 (h1 : topological_space (has_ssubset (random_gen char))) : totally_disconnected_space (has_ssubset (random_gen char)) := sorry --non-trivial
lemma new_lemma_104848 (h0 : prod (add_group congr_arg_kind) (add_group congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_104849 (h0 : function.extfun Type topological_space) : @regular_space.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_104850 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_104851 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_104852 (h0 : ring (linear_ordered_comm_group unsigned)) : is_principal_ideal_ring (linear_ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_104853 (h0 : not (filter unsigned -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_104854 (h1 : has_neg (mul_one_class environment.projection_info)) (h2 : measurable_space (mul_one_class environment.projection_info)) : has_measurable_neg (mul_one_class environment.projection_info) := sorry --non-trivial
lemma new_lemma_104855 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) Type) : @complete_lattice.is_Sup_finite_compact.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) Type h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_104856 (h0 : not (filter (has_norm empty) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_104857 (h0 : functor.add_const (finset (is_R_or_C num)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_104858 (h0 : topological_space (canonically_ordered_monoid char)) : totally_disconnected_space (canonically_ordered_monoid char) := sorry --non-trivial
lemma new_lemma_104859 (h1 : topological_space (has_emptyc (has_top congr_arg_kind))) : totally_disconnected_space (has_emptyc (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_104860 (h0 : topological_space (sub_neg_monoid (has_neg name))) : locally_compact_space (sub_neg_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_104861 (h1 : complete_lattice (normed_group linarith.ineq)) : complete_lattice.is_Sup_finite_compact (normed_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_104862 (h0 : topological_space (has_neg_part (has_to_string unsigned))) : preconnected_space (has_neg_part (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_104863 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @t0_space.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_104864 (h0 : functor.add_const (function.extfun Type uniform_space) Type) : @separated_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) Type h0) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_104865 (h0 : ordered_comm_monoid (ordered_comm_ring (has_Inf pos))) : has_exists_mul_of_le (ordered_comm_ring (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_104866 (h0 : not (topological_space linarith.comp -> false)) : @locally_compact_space.{0} linarith.comp (@classical.by_contradiction'.{1} (topological_space.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_104867 (h0 : ring (linear_ordered_add_comm_group (random_gen (random_gen char)))) : strong_rank_condition (linear_ordered_add_comm_group (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_104868 (h0 : complete_lattice (with_bot (has_top num))) : is_atomistic (with_bot (has_top num)) := sorry --non-trivial
lemma new_lemma_104869 (h0 : ring (has_top (has_sdiff unsigned))) : is_domain (has_top (has_sdiff unsigned)) := sorry --non-trivial
lemma new_lemma_104870 (h0 : group (comm_semigroup (has_bot (has_bot (comm_semigroup (comm_semigroup real)))))) : group.fg (comm_semigroup (has_bot (has_bot (comm_semigroup (comm_semigroup real))))) := sorry --non-trivial
lemma new_lemma_104871 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_104872 (h1 : group (has_norm linarith.comp_source)) : normalizer_condition (has_norm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_104873 (h0 : functor.add_const (group (boolean_algebra unsigned)) environment.implicit_infer_kind) : @is_cyclic.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_104874 (h0 : topological_space (comm_group (ring (has_neg (has_neg (has_neg linarith.comp)))))) : t0_space (comm_group (ring (has_neg (has_neg (has_neg linarith.comp))))) := sorry --non-trivial
lemma new_lemma_104875 (h0 : topological_space (has_top (random_gen (random_gen num)))) : totally_disconnected_space (has_top (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_104876 (h0 : add_group (has_star (option (option unsigned)))) : is_add_cyclic (has_star (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_104877 (h0 : functor.add_const (group (has_to_string Type)) pos) : @group.fg.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_to_string.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_104878 (h0 : topological_space (linear_ordered_semiring empty)) : irreducible_space (linear_ordered_semiring empty) := sorry --non-trivial
lemma new_lemma_104879 (h0 : topological_space (normed_group (has_norm num))) : discrete_topology (normed_group (has_norm num)) := sorry --non-trivial
lemma new_lemma_104880 (h0 : list (linear_ordered_comm_group (option num))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_104881 (h0 : functor.add_const (uniform_space (bin_tree empty)) empty) : @separated_space.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (bin_tree.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_104882 (h0 : functor.add_const (topological_space (cancel_monoid environment.implicit_infer_kind)) name) : @sequential_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_104883 (h0 : topological_space (has_neg environment.implicit_infer_kind)) : t1_space (has_neg environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_104884 (h0 : ring (comm_ring to_additive.value_type)) : strong_rank_condition (comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_104885 (h2 : ring (comm_ring (metric_space linarith.comp_source))) : is_domain (comm_ring (metric_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_104886 (h0 : topological_space (has_pos_part (has_neg linarith.comp))) : irreducible_space (has_pos_part (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_104887 (h0 : monoid (add_comm_monoid (option (option (option unsigned))))) : monoid.fg (add_comm_monoid (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_104888 (h0 : topological_space (has_norm (random_gen fun_info))) : totally_disconnected_space (has_norm (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_104889 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (normed_lattice_add_comm_group.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_104890 (h0 : ring (add_right_cancel_monoid (semiring (semiring (semiring empty))))) : is_domain (add_right_cancel_monoid (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_104891 (h0 : ring (normed_field (has_nnnorm (has_lt (has_ssubset string_imp))))) : is_domain (normed_field (has_nnnorm (has_lt (has_ssubset string_imp)))) := sorry --non-trivial
lemma new_lemma_104892 (h0 : list (ordered_comm_ring (finset linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_104893 (h0 : functor.add_const (add_monoid (metric_space num)) unsigned) : @add_monoid.fg.{0} (metric_space.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (metric_space.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_104894 (h0 : uniform_space (canonically_ordered_add_monoid (option (option (option (option empty)))))) : separated_space (canonically_ordered_add_monoid (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_104895 (h0 : functor.add_const (group (boolean_algebra.core Type)) name) : @is_simple_group.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (boolean_algebra.core.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_104896 (h0 : functor.add_const (list (cancel_monoid name)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_104897 (h0 : topological_space (has_to_string (comm_group Type))) : totally_separated_space (has_to_string (comm_group Type)) := sorry --non-trivial
lemma new_lemma_104898 (h0 : functor.comp topological_space ring name) : @totally_separated_space.{0} (ring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_104899 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (sub_neg_monoid.{0} pos) (@matrix.vec_empty.{0} (complete_lattice.{0} (sub_neg_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_104900 (h0 : uniform_space (simple_graph (has_neg name))) : separated_space (simple_graph (has_neg name)) := sorry --non-trivial
lemma new_lemma_104901 (h0 : not (group (add_right_cancel_monoid unsigned) -> false)) : @normalizer_condition.{0} (add_right_cancel_monoid.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (add_right_cancel_monoid.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_104902 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_zero.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_zero.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_104903 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_nndist.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} num))  := sorry --non-trivial
lemma new_lemma_104904 (h0 : add_group (linear_ordered_comm_ring (semiring (semiring (semiring (semiring congr_arg_kind)))))) : is_add_cyclic (linear_ordered_comm_ring (semiring (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_104905 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (option.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (option.{0} num))  := sorry --non-trivial
lemma new_lemma_104906 (h0 : ring (comm_ring (has_inv to_additive.value_type))) : is_domain (comm_ring (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_104907 (h0 : functor.add_const (group (ordered_ring unsigned)) (option empty)) : @normalizer_condition.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (ordered_ring.{0} unsigned)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_104908 (h0 : topological_space (generalized_boolean_algebra (finset (boolean_algebra.core linarith.comp)))) : irreducible_space (generalized_boolean_algebra (finset (boolean_algebra.core linarith.comp))) := sorry --non-trivial
lemma new_lemma_104909 (h0 : ordered_add_comm_monoid (left_cancel_semigroup unsigned)) : archimedean (left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_104910 (h0 : topological_space (cancel_monoid (has_add environment.implicit_infer_kind))) : regular_space (cancel_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_104911 (h0 : topological_space (pseudo_emetric_space enat)) : path_connected_space (pseudo_emetric_space enat) := sorry --non-trivial
lemma new_lemma_104912 (h0 : ring (mul_one_class fun_info)) : is_domain (mul_one_class fun_info) := sorry --non-trivial
lemma new_lemma_104913 (h0 : function.extfun Type ring) : @rank_condition.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_104914 (h0 : add_group (complete_semilattice_Sup to_additive.value_type)) : is_add_cyclic (complete_semilattice_Sup to_additive.value_type) := sorry --non-trivial
lemma new_lemma_104915 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_104916 (h0 : topological_space (mul_one_class (normed_field (mul_one_class (add_comm_semigroup enat))))) : t0_space (mul_one_class (normed_field (mul_one_class (add_comm_semigroup enat)))) := sorry --non-trivial
lemma new_lemma_104917 (h0 : monoid (with_one (random_gen (has_top fun_info)))) : monoid.fg (with_one (random_gen (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_104918 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_104919 (h0 : cancel_comm_monoid_with_zero (boolean_algebra.core (option (option unsigned)))) : unique_factorization_monoid (boolean_algebra.core (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_104920 (h0 : ordered_comm_monoid (has_pos_part (has_add pos))) : has_exists_mul_of_le (has_pos_part (has_add pos)) := sorry --non-trivial
lemma new_lemma_104921 (h0 : ring (has_top (semiring linarith.comp))) : rank_condition (has_top (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_104922 (h0 : topological_space (boolean_algebra (sub_neg_monoid pos))) : normal_space (boolean_algebra (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_104923 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_104924 (h0 : functor.add_const (topological_space (id unsigned)) empty) : @locally_compact_space.{0} (@id.{2} Type unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (@id.{2} Type unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_104925 (h0 : topological_space (simple_graph (has_add Type))) : totally_separated_space (simple_graph (has_add Type)) := sorry --non-trivial
lemma new_lemma_104926 (h0 : has_to_string (has_neg (has_to_string Type)) -> has_to_string (has_neg (has_to_string Type)) -> Prop) : is_antisymm (has_to_string (has_neg (has_to_string Type))) h0 := sorry --non-trivial
lemma new_lemma_104927 (h0 : group (semigroup (option (option ennreal)))) : is_simple_group (semigroup (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_104928 (h0 : functor.add_const (finset (has_neg linarith.comp)) (finset (has_neg Type))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_104929 (h0 : group (normed_group (has_top (has_top to_additive.value_type)))) : is_cyclic (normed_group (has_top (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_104930 (h0 : topological_space (normed_comm_ring (has_neg_part (finset (has_add (finset (has_add Type))))))) : t1_space (normed_comm_ring (has_neg_part (finset (has_add (finset (has_add Type)))))) := sorry --non-trivial
lemma new_lemma_104931 (h0 : functor.add_const (topological_space (has_add Type)) environment.implicit_infer_kind) : @totally_disconnected_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_104932 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_104933 (h0 : monoid (canonically_ordered_comm_semiring (option unsigned))) : monoid.fg (canonically_ordered_comm_semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_104934 (h0 : functor.add_const (function.extfun Type complete_lattice) name) : @is_compactly_generated.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) name h0) environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_104935 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_104936 (h0 : functor.add_const (function.extfun Type semiring) (finset Type)) : @is_noetherian_ring.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type semiring.{0}) (finset.{1} Type) h0) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_104937 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem add_group)) : @is_add_cyclic.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_104938 (h0 : ring (dlist (random_gen (random_gen string_imp)))) : is_domain (dlist (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_104939 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (linear_ordered_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_104940 (h0 : topological_space (has_one linarith.comp)) : locally_compact_space (has_one linarith.comp) := sorry --non-trivial
lemma new_lemma_104941 (h0 : topological_space (random_gen (has_norm to_additive.value_type))) : path_connected_space (random_gen (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_104942 (h0 : group (canonically_ordered_monoid (comm_semigroup (has_bot (comm_semigroup pos))))) : group.fg (canonically_ordered_monoid (comm_semigroup (has_bot (comm_semigroup pos)))) := sorry --non-trivial
lemma new_lemma_104943 (h0 : topological_space (canonically_linear_ordered_monoid (ordered_comm_monoid (has_Inf Type)))) : path_connected_space (canonically_linear_ordered_monoid (ordered_comm_monoid (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_104944 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (with_bot.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_104945 (h0 : topological_space (has_add (has_pos_part (mul_one_class linarith.comp)))) : regular_space (has_add (has_pos_part (mul_one_class linarith.comp))) := sorry --non-trivial
lemma new_lemma_104946 (h0 : topological_space (boolean_algebra (has_add (has_add (semigroup pos))))) : totally_disconnected_space (boolean_algebra (has_add (has_add (semigroup pos)))) := sorry --non-trivial
lemma new_lemma_104947 (h0 : function.extfun Type group) : @is_simple_group.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_104948 (h0 : group (complete_semilattice_Sup (semiring unsigned))) : is_cyclic (complete_semilattice_Sup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_104949 (h0 : ring (has_compl (random_gen (has_ssubset char)))) : rank_condition (has_compl (random_gen (has_ssubset char))) := sorry --non-trivial
lemma new_lemma_104950 (h0 : uniform_space (semigroup (has_neg linarith.comp))) : separated_space (semigroup (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_104951 (h0 : topological_space (add_cancel_monoid (has_add name))) : preirreducible_space (add_cancel_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_104952 (h0 : topological_space (encodable to_additive.value_type)) : locally_compact_space (encodable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_104953 (h0 : ring (normed_field (has_nnnorm reducibility_hints))) : is_domain (normed_field (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_104954 (h0 : has_lt (linear_ordered_comm_group_with_zero char)) : no_max_order (linear_ordered_comm_group_with_zero char) := sorry --non-trivial
lemma new_lemma_104955 (h0 : topological_space (semigroup (option (cancel_monoid ennreal)))) : sequential_space (semigroup (option (cancel_monoid ennreal))) := sorry --non-trivial
lemma new_lemma_104956 (h0 : topological_space (finset (ring Type))) : normal_space (finset (ring Type)) := sorry --non-trivial
lemma new_lemma_104957 (h0 : fin has_zero.zero) : @preirreducible_space.{0} pos (@matrix.vec_empty.{0} (topological_space.{0} pos) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_104958 (h0 : list (normed_comm_ring (normed_comm_ring (ring pos)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_104959 (h0 : complete_lattice (boolean_algebra (ring pos))) : is_compactly_generated (boolean_algebra (ring pos)) := sorry --non-trivial
lemma new_lemma_104960 (h0 : not (topological_space (topological_space fun_info) -> false)) : @totally_disconnected_space.{0} (topological_space.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (topological_space.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_104961 (h0 : topological_space (distrib_lattice (random_gen (with_bot string_imp)))) : t0_space (distrib_lattice (random_gen (with_bot string_imp))) := sorry --non-trivial
lemma new_lemma_104962 (h0 : ring (has_one (random_gen empty))) : is_principal_ideal_ring (has_one (random_gen empty)) := sorry --non-trivial
lemma new_lemma_104963 (h0 : complete_lattice (semigroup (has_add unsigned))) : is_compactly_generated (semigroup (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_104964 (h0 : ring (has_ssubset (mul_one_class reducibility_hints))) : rank_condition (has_ssubset (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_104965 (h0 : functor.add_const (topological_space (mul_zero_class name)) name) : @regular_space.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_104966 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_104967 (h2 : complete_lattice (semi_normed_ring char)) : is_compactly_generated (semi_normed_ring char) := sorry --non-trivial
lemma new_lemma_104968 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_104969 (h0 : group (canonically_ordered_comm_semiring (option empty))) : normalizer_condition (canonically_ordered_comm_semiring (option empty)) := sorry --non-trivial
lemma new_lemma_104970 (h0 : functor.add_const (ring Type) (has_Inf pos)) : @is_domain.{1} Type (@functor.add_const.run.{1 0} (ring.{1} Type) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_104971 (h0 : option (group (random_gen (comm_ring to_additive.value_type)))) (h1 : group (random_gen (comm_ring to_additive.value_type))) : is_cyclic (random_gen (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_104972 (h0 : group (semigroup (comm_group pos))) : group.fg (semigroup (comm_group pos)) := sorry --non-trivial
lemma new_lemma_104973 (h0 : topological_space (has_top (add_right_cancel_monoid unsigned))) : irreducible_space (has_top (add_right_cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_104974 (h0 : topological_space (add_comm_monoid (add_comm_monoid pos))) : t1_space (add_comm_monoid (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_104975 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_104976 (h0 : topological_space (semigroup (has_to_string Type))) : preirreducible_space (semigroup (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_104977 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_Inf pos)) (has_add linarith.comp)) : @unique_factorization_monoid.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_Inf.{0} pos)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_104978 (h0 : functor.add_const (finset (has_nndist Type)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_104979 (h0 : ordered_add_comm_monoid (complete_distrib_lattice (has_nndist name))) : archimedean (complete_distrib_lattice (has_nndist name)) := sorry --non-trivial
lemma new_lemma_104980 (h0 : add_monoid (canonically_ordered_comm_semiring congr_arg_kind)) : add_monoid.fg (canonically_ordered_comm_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_104981 (h0 : functor.add_const (topological_space (has_nndist pos)) (option pos)) : @preirreducible_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_104982 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (complete_linear_order empty)) := sorry --non-trivial
lemma new_lemma_104983 (h0 : topological_space (add_cancel_monoid empty)) : t0_space (add_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_104984 (h0 : function.extfun Type (functor.add_const (ordered_comm_monoid (has_neg_part environment.implicit_infer_kind)))) : @has_exists_mul_of_le.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_neg_part.{0} environment.implicit_infer_kind)) (has_add.{0} name) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ordered_comm_monoid.{0} (has_neg_part.{0} environment.implicit_infer_kind))) h0 (has_add.{0} name)))  := sorry --non-trivial
lemma new_lemma_104985 (h0 : topological_space (distrib (has_ssubset enat))) : path_connected_space (distrib (has_ssubset enat)) := sorry --non-trivial
lemma new_lemma_104986 (h2 : preorder enat) (h3 : set enat) : set.is_pwo h3 := sorry --non-trivial
lemma new_lemma_104987 (h0 : cancel_comm_monoid_with_zero (generalized_boolean_algebra (has_pos_part linarith.comp))) : unique_factorization_monoid (generalized_boolean_algebra (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_104988 (h0 : functor.add_const (cancel_comm_monoid_with_zero (boolean_algebra.core name)) Type) : @unique_factorization_monoid.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (boolean_algebra.core.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_104989 (h0 : add_monoid (cancel_monoid ennreal)) : add_monoid.fg (cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_104990 (h0 : topological_space (mul_zero_class (semiring (semiring empty)))) : locally_compact_space (mul_zero_class (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_104991 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_104992 (h0 : topological_space (has_nnnorm enat)) (h1 : preorder (has_nnnorm enat)) : order_closed_topology (has_nnnorm enat) := sorry --non-trivial
lemma new_lemma_104993 (h0 : functor.add_const (function.extfun Type ring) name) : @is_principal_ideal_ring.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) name h0) (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_104994 (h0 : functor.add_const (topological_space (has_nndist pos)) pos) : @t0_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_104995 (h0 : functor.add_const (topological_space (has_to_string pos)) name) : @totally_disconnected_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_104996 (h2 : complete_lattice (add_cancel_comm_monoid char)) : is_compactly_generated (add_cancel_comm_monoid char) := sorry --non-trivial
lemma new_lemma_104997 (h0 : fin has_zero.zero) : @t1_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_104998 (h0 : functor.add_const (topological_space (comm_group unsigned)) linarith.comp) : @regular_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_104999 (h0 : enat -> enat -> Prop) : pairwise h0 := sorry --non-trivial
lemma new_lemma_105000 (h0 : functor.add_const (topological_space (mul_zero_class Type)) Type) : @sequential_space.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (mul_zero_class.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_105001 (h0 : uniform_space (normed_linear_ordered_group unsigned)) : separated_space (normed_linear_ordered_group unsigned) := sorry --non-trivial
lemma new_lemma_105002 (h0 : topological_space (comm_semigroup Type)) : discrete_topology (comm_semigroup Type) := sorry --non-trivial
lemma new_lemma_105003 (h0 : topological_space (with_bot (has_inv (has_inv linarith.ineq)))) : totally_disconnected_space (with_bot (has_inv (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_105004 (h0 : ring (has_add ennreal)) : strong_rank_condition (has_add ennreal) := sorry --non-trivial
lemma new_lemma_105005 (h0 : functor.add_const (group (option empty)) (semiring empty)) : @normalizer_condition.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (option.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_105006 (h0 : functor.add_const (filter (ring Type)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_105007 (h0 : function.extfun (Type 1) topological_space) : @locally_compact_space.{1} (plift.{1} congr_arg_kind) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (plift.{1} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_105008 (h0 : uniform_space (has_to_string (option name))) : separated_space (has_to_string (option name)) := sorry --non-trivial
lemma new_lemma_105009 (h0 : uniform_space (with_one (semiring unsigned))) : complete_space (with_one (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_105010 (h0 : not (has_mem.mem (linear_ordered_semiring num) has_emptyc.emptyc -> false)) : @complete_space.{0} (linear_ordered_semiring.{0} num) (@finset.pi.empty.{1 0} Type uniform_space.{0} (linear_ordered_semiring.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_105011 (h0 : has_mem.mem group has_emptyc.emptyc) : @is_cyclic.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_105012 (h0 : topological_space (group_with_zero (option num))) : totally_disconnected_space (group_with_zero (option num)) := sorry --non-trivial
lemma new_lemma_105013 (h3 : filter (distrib_lattice (comm_ring fun_info))) : filter.ne_bot h3 := sorry --non-trivial
lemma new_lemma_105014 (h0 : function.extfun Type uniform_space) : @complete_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type uniform_space.{0} h0 linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_105015 (h0 : ring (has_bot congr_arg_kind)) : strong_rank_condition (has_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_105016 (h0 : functor.add_const (ring (has_add stieltjes_function)) (has_neg (ring environment.implicit_infer_kind))) : @is_domain.{0} (has_add.{0} stieltjes_function) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} stieltjes_function)) (has_neg.{0} (ring.{0} environment.implicit_infer_kind)) h0)  := sorry --non-trivial
lemma new_lemma_105017 (h0 : uniform_space (has_neg (has_pos_part (has_nndist (finset environment.implicit_infer_kind))))) : separated_space (has_neg (has_pos_part (has_nndist (finset environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_105018 (h0 : function.extfun nat fin) : @complete_lattice.is_Sup_finite_compact.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type complete_lattice.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_105019 (h1 : complete_lattice (has_nnnorm (has_top char))) : complete_lattice.is_Sup_finite_compact (has_nnnorm (has_top char)) := sorry --non-trivial
lemma new_lemma_105020 (h0 : functor.add_const (topological_space (boolean_algebra.core linarith.comp)) (has_neg Type)) : @path_connected_space.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_105021 (h0 : function.extfun (Type 1) topological_space) : @path_connected_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_105022 (h0 : complete_lattice (has_add (sub_neg_monoid Type))) : is_compactly_generated (has_add (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_105023 (h0 : functor.add_const (list (has_add environment.implicit_infer_kind)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_105024 (h0 : functor.add_const (ring (has_neg environment.implicit_infer_kind)) (finset linarith.comp)) : @is_domain.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} environment.implicit_infer_kind)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_105025 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @discrete_topology.{1} (canonically_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (canonically_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_105026 (h0 : add_group (has_bot (has_add linarith.comp))) : is_add_cyclic (has_bot (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_105027 (h1 : function.extfun Type uniform_space) : @complete_space.{0} (with_one.{0} (with_bot.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type uniform_space.{0} h1 (with_one.{0} (with_bot.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_105028 (h0 : functor.comp topological_space add_comm_monoid environment.implicit_infer_kind) : @totally_disconnected_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} add_comm_monoid.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_105029 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (finset.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (finset.{0} real))  := sorry --non-trivial
lemma new_lemma_105030 (h0 : functor.add_const (topological_space (has_zero Type)) (has_neg linarith.comp)) : @discrete_topology.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_105031 (h0 : topological_space (encodable (random_gen (random_gen (random_gen (random_gen linarith.ineq)))))) : locally_compact_space (encodable (random_gen (random_gen (random_gen (random_gen linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_105032 (h0 : function.extfun Type group) : @group.fg.{0} (dlist.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (dlist.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_105033 (h0 : complete_lattice (has_top (random_gen congr_arg_kind))) : is_atomistic (has_top (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_105034 (h0 : functor.add_const (list (add_comm_monoid name)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_105035 (h0 : measurable_space (simple_graph linarith.ineq)) (h1 : filter (simple_graph linarith.ineq)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_105036 (h0 : function.extfun nat fin) : @separated_space.{0} (canonically_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (uniform_space.{0} (canonically_ordered_monoid.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_105037 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @locally_compact_space.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_105038 (h0 : topological_space (canonically_ordered_monoid name)) : sequential_space (canonically_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_105039 (h0 : ring (distrib_lattice (has_nnnorm to_additive.value_type))) : is_domain (distrib_lattice (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_105040 (h0 : functor.add_const (group (has_Inf linarith.comp)) name) : @group.fg.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_Inf.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_105041 (h0 : ring (has_add (option (option (option unsigned))))) : is_principal_ideal_ring (has_add (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_105042 (h0 : add_monoid (add_group (semiring (semiring (has_norm (semiring (semiring (semiring unsigned)))))))) : add_monoid.fg (add_group (semiring (semiring (has_norm (semiring (semiring (semiring unsigned))))))) := sorry --non-trivial
lemma new_lemma_105043 (h0 : topological_space (canonically_linear_ordered_monoid (has_neg name))) : path_connected_space (canonically_linear_ordered_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_105044 (h0 : fin has_zero.zero) : @t1_space.{0} (ordered_comm_ring.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_105045 (h0 : topological_space (distrib_lattice (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) : path_connected_space (distrib_lattice (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_105046 (h0 : topological_space (has_zero (has_to_string environment.implicit_infer_kind))) : irreducible_space (has_zero (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_105047 (h0 : group (dlist (has_top linarith.ineq))) : is_cyclic (dlist (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_105048 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_105049 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_inter.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} empty))  := sorry --non-trivial
lemma new_lemma_105050 (h0 : complete_lattice (has_inv string_imp)) : is_atomistic (has_inv string_imp) := sorry --non-trivial
lemma new_lemma_105051 (h2 : function.extfun Type topological_space) : @irreducible_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h2 (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_105052 (h1 : ring (random_gen (has_nnnorm fun_info))) : strong_rank_condition (random_gen (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_105053 (h0 : not (has_mem.mem (with_one linarith.ineq) has_emptyc.emptyc -> false)) : @group.fg.{0} (with_one.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type group.{0} (with_one.{0} linarith.ineq) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} linarith.ineq) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_105054 (h0 : complete_lattice (add_comm_monoid num)) : complete_lattice.is_Sup_finite_compact (add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_105055 (h0 : filter (nondiscrete_normed_field (has_nnnorm fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_105056 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_105057 (h0 : topological_space (add_comm_monoid (has_add pos))) : preirreducible_space (add_comm_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_105058 (h0 : functor.add_const (topological_space (semigroup Type)) Type) : @loc_path_connected_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (semigroup.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_105059 (h0 : function.extfun Type (functor.add_const (filter pos))) : countable_Inter_filter (functor.add_const.run (function.extfun_app h0 name)) := sorry --non-trivial
lemma new_lemma_105060 (h0 : ring (normed_lattice_add_comm_group (has_Inf (sub_neg_monoid real)))) : rank_condition (normed_lattice_add_comm_group (has_Inf (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_105061 (h0 : cancel_comm_monoid_with_zero (partial_order (semiring (semiring unsigned)))) : unique_factorization_monoid (partial_order (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_105062 (h0 : function.extfun Type topological_space) : @regular_space.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_105063 (h0 : topological_space (comm_semigroup (has_bot (has_add real)))) : sequential_space (comm_semigroup (has_bot (has_add real))) := sorry --non-trivial
lemma new_lemma_105064 (h0 : ring (metric_space (has_norm linarith.comp))) : rank_condition (metric_space (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_105065 (h0 : topological_space (has_bot (has_Inf (has_pos_part (has_Inf (has_add (has_add (has_add pos)))))))) : t1_space (has_bot (has_Inf (has_pos_part (has_Inf (has_add (has_add (has_add pos))))))) := sorry --non-trivial
lemma new_lemma_105066 (h0 : functor.add_const (topological_space (add_left_cancel_semigroup unsigned)) empty) : @t0_space.{0} (add_left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_105067 (h0 : functor.add_const (list (add_cancel_monoid Type)) environment.implicit_infer_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_105068 (h0 : functor.add_const (topological_space (normed_comm_ring name)) name) : @t1_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_105069 (h0 : group (comm_ring (comm_ring (random_gen linarith.comp_source)))) : normalizer_condition (comm_ring (comm_ring (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_105070 (h0 : functor.add_const (topological_space (ring empty)) unsigned) : @loc_path_connected_space.{0} (ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_105071 (h0 : semiring (ordered_comm_ring (has_Inf name))) : is_noetherian_ring (ordered_comm_ring (has_Inf name)) := sorry --non-trivial
lemma new_lemma_105072 (h0 : functor.add_const (function.extfun (Type 1) ring) linarith.comp) : @strong_rank_condition.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) linarith.comp h0) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_105073 (h0 : ring (with_one (random_gen linarith.comp))) : is_domain (with_one (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_105074 (h0 : functor.add_const (topological_space (has_add Type)) pos) : @loc_path_connected_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_105075 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @path_connected_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_105076 (h0 : topological_space (ring (has_add unsigned))) : totally_disconnected_space (ring (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_105077 (h0 : monoid (finset (boolean_algebra linarith.comp))) : monoid.fg (finset (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_105078 (h0 : not (ring (normed_field string.iterator_imp) -> false)) : @rank_condition.{0} (normed_field.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (ring.{0} (normed_field.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_105079 (h0 : function.extfun Type group) : @is_cyclic.{0} (complete_linear_order.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_105080 (h0 : complete_lattice (linear_ordered_semiring (random_gen linarith.ineq))) : complete_lattice.is_Sup_finite_compact (linear_ordered_semiring (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_105081 (h0 : functor.add_const (add_group (finset pos)) name) : @is_add_cyclic.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (finset.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_105082 (h0 : functor.add_const (ordered_add_comm_monoid (has_Inf pos)) (ring Type)) : @archimedean.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (has_Inf.{0} pos)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_105083 (h0 : topological_space (generalized_boolean_algebra (has_neg Type))) : t0_space (generalized_boolean_algebra (has_neg Type)) := sorry --non-trivial
lemma new_lemma_105084 (h1 : ring num) : strong_rank_condition num := sorry --non-trivial
lemma new_lemma_105085 (h0 : ordered_comm_monoid (add_cancel_monoid (ring (has_pos_part (has_to_string (finset pos)))))) : has_exists_mul_of_le (add_cancel_monoid (ring (has_pos_part (has_to_string (finset pos))))) := sorry --non-trivial
lemma new_lemma_105086 (h0 : topological_space (boolean_algebra.core (has_add (finset pos)))) : t1_space (boolean_algebra.core (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_105087 (h0 : add_monoid auto.case_option) : add_monoid.fg auto.case_option := sorry --non-trivial
lemma new_lemma_105088 (h0 : not (topological_space (has_top unsigned) -> false)) : @locally_compact_space.{0} (has_top.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_105089 (h0 : ring ennreal) : is_domain ennreal := sorry --non-trivial
lemma new_lemma_105090 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) h0) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_105091 (h0 : add_group (nondiscrete_normed_field (mul_one_class environment.projection_info))) : is_add_cyclic (nondiscrete_normed_field (mul_one_class environment.projection_info)) := sorry --non-trivial
lemma new_lemma_105092 (h0 : functor.add_const (add_group (has_edist unsigned)) (semiring empty)) : @is_add_cyclic.{0} (has_edist.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (has_edist.{0} unsigned)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_105093 (h0 : functor.add_const (function.extfun (Type 1) filter) (has_Inf (has_pos_part (has_pos_part linarith.comp)))) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (finset Type)) := sorry --non-trivial
lemma new_lemma_105094 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_105095 (h2 : set (add_comm_semigroup std_gen)) : set.finite h2 := sorry --non-trivial
lemma new_lemma_105096 (h0 : topological_space (pseudo_metric_space (semigroup ennreal))) : path_connected_space (pseudo_metric_space (semigroup ennreal)) := sorry --non-trivial
lemma new_lemma_105097 (h0 : topological_space (has_Inf (ring Type))) : regular_space (has_Inf (ring Type)) := sorry --non-trivial
lemma new_lemma_105098 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_105099 (h0 : functor.add_const (semiring (boolean_algebra linarith.comp)) unsigned) : @is_noetherian_ring.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (boolean_algebra.{0} linarith.comp)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_105100 (h0 : topological_space (has_bot (option (option unsigned)))) : discrete_topology (has_bot (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_105101 (h0 : semiring (has_bot (has_Inf pos))) : is_noetherian_ring (has_bot (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_105102 (h0 : functor.add_const (function.extfun Type add_group) linarith.comp) : @is_add_cyclic.{0} (finset.{0} (has_pos_part.{0} (has_pos_part.{0} linarith.comp))) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) linarith.comp h0) (finset.{0} (has_pos_part.{0} (has_pos_part.{0} linarith.comp))))  := sorry --non-trivial
lemma new_lemma_105103 (h0 : topological_space (has_neg (has_add Type))) : t1_space (has_neg (has_add Type)) := sorry --non-trivial
lemma new_lemma_105104 (h1 : not (topological_space bool -> false)) (h2 : set bool) : is_preirreducible h2 := sorry --non-trivial
lemma new_lemma_105105 (h0 : ring (distrib_lattice (has_nnnorm char))) : strong_rank_condition (distrib_lattice (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_105106 (h0 : set (add_comm_semigroup ereal -> mul_one_class linarith.ineq)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_105107 (h0 : functor.add_const (topological_space (has_add linarith.comp)) (has_pos_part linarith.comp)) : @t0_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) (has_pos_part.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_105108 (h1 : group (complete_semilattice_Sup (random_gen string_imp))) : is_cyclic (complete_semilattice_Sup (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_105109 (h0 : functor.add_const (ordered_add_comm_monoid (generalized_boolean_algebra Type)) pos) : @archimedean.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (generalized_boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_105110 (h0 : group (linear_ordered_add_comm_group (has_nnnorm linarith.comp_source))) : group.fg (linear_ordered_add_comm_group (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_105111 (h0 : set (distrib (group_with_zero linarith.ineq))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_105112 (h0 : functor.add_const (add_group (finset linarith.comp)) linarith.comp) : @is_add_cyclic.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (finset.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_105113 (h0 : functor.comp topological_space has_add pos) : @discrete_topology.{0} (has_add.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_add.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_105114 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (linear_ordered_comm_monoid_with_zero unsigned)) := sorry --non-trivial
lemma new_lemma_105115 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_105116 (h0 : functor.comp topological_space has_to_string pos) : @normal_space.{0} (has_to_string.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_105117 (h1 : ring (uniform_space (semi_normed_comm_ring reducibility_hints))) : strong_rank_condition (uniform_space (semi_normed_comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_105118 (h0 : add_group (add_comm_monoid (boolean_algebra.core (has_add (add_comm_monoid pos))))) : is_add_cyclic (add_comm_monoid (boolean_algebra.core (has_add (add_comm_monoid pos)))) := sorry --non-trivial
lemma new_lemma_105119 (h0 : list (has_top (has_ssubset to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_105120 (h0 : ring (uniform_space (finset (semi_normed_comm_ring char)))) : is_domain (uniform_space (finset (semi_normed_comm_ring char))) := sorry --non-trivial
lemma new_lemma_105121 (h0 : functor.add_const (ring (has_dist unsigned)) unsigned) : @strong_rank_condition.{0} (has_dist.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_dist.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_105122 (h0 : complete_lattice (random_gen (metric_space (semiring empty)))) : is_compactly_generated (random_gen (metric_space (semiring empty))) := sorry --non-trivial
lemma new_lemma_105123 (h0 : functor.add_const (functor.add_const (complete_lattice (comm_group unsigned)) Type) Type) : @is_compactly_generated.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 1} (complete_lattice.{0} (comm_group.{0} unsigned)) Type (@functor.add_const.run.{0 1} (functor.add_const.{0 1} (complete_lattice.{0} (comm_group.{0} unsigned)) Type) Type h0))  := sorry --non-trivial
lemma new_lemma_105124 (h0 : not (topological_space (complete_linear_order unsigned) -> false)) : @topological_space.separable_space.{0} (complete_linear_order.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_linear_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_105125 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_105126 (h0 : topological_space (with_one (has_norm linarith.comp))) : discrete_topology (with_one (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_105127 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (non_assoc_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (non_assoc_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_105128 (h0 : cancel_comm_monoid_with_zero (with_one num)) : unique_factorization_monoid (with_one num) := sorry --non-trivial
lemma new_lemma_105129 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) (has_neg Type)) : @locally_compact_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_105130 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} linarith.comp (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_105131 (h0 : ring (comm_semigroup linarith.comp)) : rank_condition (comm_semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_105132 (h0 : monoid (has_pos_part (has_add (has_Inf real)))) : monoid.fg (has_pos_part (has_add (has_Inf real))) := sorry --non-trivial
lemma new_lemma_105133 (h0 : function.extfun Type topological_space) : @t0_space.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_105134 (h0 : ring (normed_field (has_compl (has_lt to_additive.value_type)))) : rank_condition (normed_field (has_compl (has_lt to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_105135 (h1 : ring (has_emptyc linarith.comp)) : is_domain (has_emptyc linarith.comp) := sorry --non-trivial
lemma new_lemma_105136 (h1 : add_group (distrib to_additive.value_type)) : is_add_cyclic (distrib to_additive.value_type) := sorry --non-trivial
lemma new_lemma_105137 (h0 : ring (normed_field (mul_one_class fun_info))) : rank_condition (normed_field (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_105138 (h0 : add_group (has_nndist congr_arg_kind)) : is_add_cyclic (has_nndist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_105139 (h0 : monoid (has_sub empty)) : monoid.fg (has_sub empty) := sorry --non-trivial
lemma new_lemma_105140 (h0 : not (topological_space (measurable_space.dynkin_system empty) -> false)) : @path_connected_space.{0} (measurable_space.dynkin_system.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.dynkin_system.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_105141 (h0 : topological_space (measurable_space (has_top (semiring empty)))) : irreducible_space (measurable_space (has_top (semiring empty))) := sorry --non-trivial
lemma new_lemma_105142 (h0 : add_group (has_div (mul_one_class reducibility_hints))) : is_add_cyclic (has_div (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_105143 (h0 : topological_space (has_add (topological_space fun_info))) : path_connected_space (has_add (topological_space fun_info)) := sorry --non-trivial
lemma new_lemma_105144 (h3 : add_group (distrib_lattice (random_gen fun_info))) : is_add_cyclic (distrib_lattice (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_105145 (h0 : not (complete_lattice (has_div to_additive.value_type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_div.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_div.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_105146 (h0 : functor.add_const (topological_space (add_group unsigned)) unsigned) : @t1_space.{0} (add_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_105147 (h0 : topological_space (add_cancel_monoid (has_Inf (has_Inf Type)))) : loc_path_connected_space (add_cancel_monoid (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_105148 (h0 : topological_space (ordered_ring (semiring (semiring (semiring num))))) : irreducible_space (ordered_ring (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_105149 (h0 : complete_lattice (linear_ordered_comm_group_with_zero char)) : is_compactly_generated (linear_ordered_comm_group_with_zero char) := sorry --non-trivial
lemma new_lemma_105150 (h0 : functor.add_const (complete_lattice (canonically_ordered_comm_semiring name)) Type) : @is_compactly_generated.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (canonically_ordered_comm_semiring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_105151 (h0 : topological_space (has_star (add_group (semiring (semiring congr_arg_kind))))) : totally_separated_space (has_star (add_group (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_105152 (h0 : not (filter (add_monoid string_imp) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_105153 (h2 : add_group (semi_normed_comm_ring (has_nnnorm to_additive.value_type))) : is_add_cyclic (semi_normed_comm_ring (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_105154 (h0 : add_group (has_inv string_imp)) : is_add_cyclic (has_inv string_imp) := sorry --non-trivial
lemma new_lemma_105155 (h0 : function.extfun nat fin) : @is_compactly_generated.{0} (add_comm_monoid.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (add_comm_monoid.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_105156 (h0 : semiring (boolean_algebra (has_pos_part pos))) : is_noetherian_ring (boolean_algebra (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_105157 (h0 : topological_space (finset (has_neg Type))) : normal_space (finset (has_neg Type)) := sorry --non-trivial
lemma new_lemma_105158 (h0 : uniform_space (canonically_ordered_comm_semiring Type)) : complete_space (canonically_ordered_comm_semiring Type) := sorry --non-trivial
lemma new_lemma_105159 (h0 : has_le (normed_field reducibility_hints)) : no_top_order (normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_105160 (h0 : not (ring string_imp -> false)) : @is_domain.{0} string_imp (@classical.by_contradiction'.{1} (ring.{0} string_imp) h0)  := sorry --non-trivial
lemma new_lemma_105161 (h2 : complete_lattice (has_nnnorm to_additive.value_type)) : is_compactly_generated (has_nnnorm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_105162 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (is_R_or_C.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (is_R_or_C.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_105163 (h0 : complete_lattice (has_add (option unsigned))) : complete_lattice.is_Sup_finite_compact (has_add (option unsigned)) := sorry --non-trivial
lemma new_lemma_105164 (h0 : add_group (mul_one_class (mul_one_class linarith.ineq))) : is_add_cyclic (mul_one_class (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_105165 (h0 : functor.add_const (topological_space (mul_zero_class Type)) (normed_comm_ring pos)) : @path_connected_space.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (mul_zero_class.{1} Type)) (normed_comm_ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_105166 (h0 : topological_space (has_nndist congr_arg_kind)) : totally_separated_space (has_nndist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_105167 (h0 : topological_space (ordered_comm_monoid (has_Inf (has_Inf (ordered_comm_monoid Type))))) : t1_space (ordered_comm_monoid (has_Inf (has_Inf (ordered_comm_monoid Type)))) := sorry --non-trivial
lemma new_lemma_105168 (h0 : fin has_zero.zero) : @irreducible_space.{0} (has_pos_part.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_105169 (h0 : uniform_space (option ennreal)) : separated_space (option ennreal) := sorry --non-trivial
lemma new_lemma_105170 (h0 : topological_space (finset (finset Type))) : loc_path_connected_space (finset (finset Type)) := sorry --non-trivial
lemma new_lemma_105171 (h0 : measurable_space environment.implicit_infer_kind) (h1 : has_inf environment.implicit_infer_kind) : has_measurable_inf environment.implicit_infer_kind := sorry --non-trivial
lemma new_lemma_105172 (h0 : function.extfun Type (functor.add_const (topological_space (comm_monoid empty)))) : @loc_path_connected_space.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (comm_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_105173 (h0 : add_group (has_le (mul_one_class (semiring linarith.ineq)))) : is_add_cyclic (has_le (mul_one_class (semiring linarith.ineq))) := sorry --non-trivial
lemma new_lemma_105174 (h0 : functor.add_const (ring (add_cancel_monoid pos)) ennreal) : @is_domain.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_105175 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) pos) : @topological_space.separable_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_105176 (h1 : ring (denumerable char)) : is_domain (denumerable char) := sorry --non-trivial
lemma new_lemma_105177 (h0 : functor.add_const (fin has_zero.zero) real) : @strong_rank_condition.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (generalized_boolean_algebra.{1} Type)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) real h0))  := sorry --non-trivial
lemma new_lemma_105178 (h0 : monoid (canonically_linear_ordered_monoid (has_Inf pos))) : monoid.fg (canonically_linear_ordered_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_105179 (h0 : ordered_add_comm_monoid (has_pos_part (has_add (has_add (sub_neg_monoid real))))) : archimedean (has_pos_part (has_add (has_add (sub_neg_monoid real)))) := sorry --non-trivial
lemma new_lemma_105180 (h0 : functor.comp ring has_neg_part name) : @is_principal_ideal_ring.{0} (has_neg_part.{0} name) (@functor.comp.run.{0 0 0} ring.{0} has_neg_part.{0} name h0)  := sorry --non-trivial
lemma new_lemma_105181 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_105182 (h0 : functor.add_const (functor.add_const (uniform_space (has_zero name)) linarith.comp) linarith.comp) : @complete_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_zero.{0} name)) linarith.comp (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (uniform_space.{0} (has_zero.{0} name)) linarith.comp) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_105183 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_105184 (h0 : not (filter (has_sub unsigned) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_105185 (h0 : topological_space (has_le (normed_field string.iterator_imp))) : path_connected_space (has_le (normed_field string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_105186 (h0 : functor.add_const (topological_space (free_add_monoid congr_arg_kind)) unsigned) : @preirreducible_space.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_105187 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_105188 (h0 : topological_space (has_neg_part (option ennreal))) : irreducible_space (has_neg_part (option ennreal)) := sorry --non-trivial
lemma new_lemma_105189 (h2 : topological_space (semi_normed_comm_ring char)) : t0_space (semi_normed_comm_ring char) := sorry --non-trivial
lemma new_lemma_105190 (h0 : functor.add_const (ring (boolean_algebra.core environment.implicit_infer_kind)) linarith.comp) : @strong_rank_condition.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_105191 (h0 : ring (mul_one_class linarith.comp_source)) : strong_rank_condition (mul_one_class linarith.comp_source) := sorry --non-trivial
lemma new_lemma_105192 (h0 : function.extfun (Type 1) add_group) : @is_add_cyclic.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} h0 (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_105193 (h0 : topological_space (monoid congr_arg_kind)) : loc_path_connected_space (monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_105194 (h0 : topological_space (has_Inf (has_Inf (has_Inf real)))) : totally_separated_space (has_Inf (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_105195 (h0 : function.extfun nat fin) : @archimedean.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (ordered_add_comm_monoid.{1} (sub_neg_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_105196 (h0 : not (topological_space (measure_theory.measure_space congr_arg_kind) -> false)) : @path_connected_space.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (measure_theory.measure_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_105197 (h0 : has_add (ring ennreal) -> has_add (ring ennreal) -> Prop) : is_symm (has_add (ring ennreal)) h0 := sorry --non-trivial
lemma new_lemma_105198 (h0 : functor.comp finset boolean_algebra.core name) : finset.nonempty (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_105199 (h0 : ring (is_R_or_C (semiring (semiring num)))) : is_principal_ideal_ring (is_R_or_C (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_105200 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_105201 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) environment.implicit_infer_kind) : @locally_compact_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_105202 (h0 : functor.add_const (list (canonically_ordered_comm_semiring Type)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_105203 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_sub congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_105204 (h0 : ring (add_monoid (has_nnnorm linarith.comp_source))) : strong_rank_condition (add_monoid (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_105205 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra linarith.comp)) linarith.comp) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_105206 (h0 : group (has_Inf (has_neg name))) : group.fg (has_Inf (has_neg name)) := sorry --non-trivial
lemma new_lemma_105207 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) (finset (finset pos))) : @irreducible_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) (finset.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_105208 (h0 : functor.add_const (uniform_space (comm_group environment.implicit_infer_kind)) pos) : @separated_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (comm_group.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_105209 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_105210 (h0 : not (filter (has_star num) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_105211 (h0 : monoid (measurable_space (random_gen (random_gen (has_inv (random_gen linarith.ineq)))))) : monoid.fg (measurable_space (random_gen (random_gen (has_inv (random_gen linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_105212 (h1 : filter (linear_ordered_add_comm_group (random_gen (random_gen to_additive.value_type)))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_105213 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_norm.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_norm.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_105214 (h0 : uniform_space (has_nndist (has_to_string linarith.comp))) : separated_space (has_nndist (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_105215 (h0 : functor.add_const (semiring (normed_comm_ring pos)) Type) : @is_noetherian_ring.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (semiring.{0} (normed_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_105216 (h0 : ordered_semiring (local_equiv string_imp string_imp)) (h1 : fintype (set string_imp)) : std_simplex (local_equiv string_imp string_imp) (set string_imp) local_equiv.of_set := sorry --non-trivial
lemma new_lemma_105217 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring name)) name) : @strong_rank_condition.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (canonically_ordered_comm_semiring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_105218 (h0 : topological_space (finset (has_add (normed_comm_ring Type)))) : totally_disconnected_space (finset (has_add (normed_comm_ring Type))) := sorry --non-trivial
lemma new_lemma_105219 (h0 : topological_space (topological_space (has_ssubset string_imp))) : t0_space (topological_space (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_105220 (h0 : complete_lattice (semigroup (has_neg environment.implicit_infer_kind))) : is_compactly_generated (semigroup (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_105221 (h0 : topological_space (finset pos)) : preirreducible_space (finset pos) := sorry --non-trivial
lemma new_lemma_105222 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_105223 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_105224 (h0 : not (complete_lattice (with_bot char) -> false)) : @is_compactly_generated.{0} (with_bot.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_bot.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_105225 (h0 : complete_lattice (filter (semiring empty))) : is_compactly_generated (filter (semiring empty)) := sorry --non-trivial
lemma new_lemma_105226 (h0 : ring (has_nndist (comm_group Type))) : rank_condition (has_nndist (comm_group Type)) := sorry --non-trivial
lemma new_lemma_105227 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_105228 (h0 : not (topological_space (metric_space linarith.comp) -> false)) : @locally_compact_space.{0} (metric_space.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_105229 (h0 : function.extfun Type group) : @normalizer_condition.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_105230 (h0 : ring (has_sub (semiring num))) : strong_rank_condition (has_sub (semiring num)) := sorry --non-trivial
lemma new_lemma_105231 (h1 : topological_space (measurable_space.dynkin_system char)) : totally_disconnected_space (measurable_space.dynkin_system char) := sorry --non-trivial
lemma new_lemma_105232 (h0 : ring (filter (option (option unsigned)))) : rank_condition (filter (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_105233 (h0 : complete_lattice (non_assoc_semiring congr_arg_kind)) : is_compactly_generated (non_assoc_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_105234 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (has_pos_part.{0} pos) (@matrix.vec_empty.{0} (group.{0} (has_pos_part.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_105235 (h0 : semiring (ordered_comm_ring (has_bot Type))) : is_noetherian_ring (ordered_comm_ring (has_bot Type)) := sorry --non-trivial
lemma new_lemma_105236 (h0 : not (add_group (has_inv linarith.ineq) -> false)) : @is_add_cyclic.{0} (has_inv.{0} linarith.ineq) (@classical.by_contradiction'.{1} (add_group.{0} (has_inv.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_105237 (h0 : topological_space (id (random_gen (random_gen to_additive.value_type)))) : locally_compact_space (id (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_105238 (h0 : add_group (has_nndist Type)) : is_add_cyclic (has_nndist Type) := sorry --non-trivial
lemma new_lemma_105239 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_105240 (h0 : ordered_comm_monoid (ordered_comm_ring (has_add (has_add (has_add linarith.comp))))) : has_exists_mul_of_le (ordered_comm_ring (has_add (has_add (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_105241 (h0 : functor.add_const (group (semigroup Type)) pos) : @is_cyclic.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (semigroup.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_105242 (h0 : function.extfun (Type 1) (functor.add_const (topological_space environment.implicit_infer_kind))) : @totally_disconnected_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 1} (topological_space.{0} environment.implicit_infer_kind) Type (@function.extfun_app.{3 1} (Type 1) (functor.add_const.{0 1} (topological_space.{0} environment.implicit_infer_kind)) h0 Type))  := sorry --non-trivial
lemma new_lemma_105243 (h0 : ring (linear_ordered_comm_monoid_with_zero num)) : rank_condition (linear_ordered_comm_monoid_with_zero num) := sorry --non-trivial
lemma new_lemma_105244 (h0 : has_mem.mem (normed_group (semiring empty)) has_emptyc.emptyc) : @monoid.fg.{0} (normed_group.{0} (semiring.{0} empty)) (@finset.pi.empty.{1 0} Type monoid.{0} (normed_group.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_105245 (h0 : functor.add_const (function.extfun Type uniform_space) name) : @separated_space.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) name h0) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_105246 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (normed_linear_ordered_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_linear_ordered_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_105247 (h0 : filter (has_neg_part pos)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_105248 (h0 : functor.add_const (function.extfun (Type 1) ring) name) : @is_principal_ideal_ring.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) name h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_105249 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (normed_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_105250 (h0 : ring (add_left_cancel_semigroup (option unsigned))) : is_domain (add_left_cancel_semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_105251 (h1 : add_group (has_neg string_imp)) : is_add_cyclic (has_neg string_imp) := sorry --non-trivial
lemma new_lemma_105252 (h0 : ring (has_ssubset (comm_ring linarith.ineq))) : rank_condition (has_ssubset (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_105253 (h0 : functor.add_const (ring (boolean_algebra.core environment.implicit_infer_kind)) linarith.comp) : @is_domain.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_105254 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_105255 (h0 : finset (ring Type)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_105256 (h0 : functor.add_const (topological_space (boolean_algebra pos)) pos) : @totally_disconnected_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_105257 (h0 : filter (ring (comm_group (semigroup name)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_105258 (h0 : functor.add_const (topological_space (canonically_ordered_monoid linarith.comp)) name) : @loc_path_connected_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_105259 (h0 : functor.add_const (topological_space (has_to_string ennreal)) unsigned) : @totally_disconnected_space.{0} (has_to_string.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_105260 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_dist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_105261 (h0 : uniform_space (has_Sup (semiring (semiring (semiring (semiring empty)))))) : separated_space (has_Sup (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_105262 (h0 : function.extfun (Type 1) topological_space) : @topological_space.separable_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_105263 (h2 : ring (simple_graph to_additive.value_type)) : is_domain (simple_graph to_additive.value_type) := sorry --non-trivial
lemma new_lemma_105264 (h0 : functor.add_const (function.extfun Type ring) Type) : @strong_rank_condition.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_105265 (h0 : semiring (has_star unsigned)) : is_noetherian_ring (has_star unsigned) := sorry --non-trivial
lemma new_lemma_105266 (h0 : group (has_nnnorm string_imp)) : group.fg (has_nnnorm string_imp) := sorry --non-trivial
lemma new_lemma_105267 (h0 : topological_space (has_one (id (id (id (id linarith.comp)))))) : totally_separated_space (has_one (id (id (id (id linarith.comp))))) := sorry --non-trivial
lemma new_lemma_105268 (h0 : topological_space (measure_theory.measure_space congr_arg_kind)) : irreducible_space (measure_theory.measure_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_105269 (h0 : topological_space (linear_ordered_add_comm_group (random_gen (has_compl char)))) : totally_disconnected_space (linear_ordered_add_comm_group (random_gen (has_compl char))) := sorry --non-trivial
lemma new_lemma_105270 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (measure_theory.measure_space.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (measure_theory.measure_space.{0} num))  := sorry --non-trivial
lemma new_lemma_105271 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_105272 (h0 : ring (linear_ordered_add_comm_group_with_top fun_info)) : is_domain (linear_ordered_add_comm_group_with_top fun_info) := sorry --non-trivial
lemma new_lemma_105273 (h0 : ordered_comm_monoid (ordered_comm_monoid pos)) : has_exists_mul_of_le (ordered_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_105274 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (distrib_lattice.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (distrib_lattice.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_105275 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (ring Type)) := sorry --non-trivial
lemma new_lemma_105276 (h0 : topological_space (has_nndist (has_to_string (has_to_string pos)))) : t1_space (has_nndist (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_105277 (h0 : complete_lattice (non_unital_non_assoc_semiring (mul_one_class enat))) : is_compactly_generated (non_unital_non_assoc_semiring (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_105278 (h0 : functor.add_const (topological_space (add_comm_monoid name)) pos) : @path_connected_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_105279 (h0 : list (mul_zero_class (semiring congr_arg_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_105280 (h0 : topological_space (measurable_space (random_gen linarith.ineq))) : path_connected_space (measurable_space (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_105281 (h0 : topological_space (comm_group (finset pos))) : locally_compact_space (comm_group (finset pos)) := sorry --non-trivial
lemma new_lemma_105282 (h0 : complete_lattice (semigroup (comm_group name))) : is_atomistic (semigroup (comm_group name)) := sorry --non-trivial
lemma new_lemma_105283 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) pos) : @archimedean.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) pos h0) (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_105284 (h0 : not (function.extfun Type complete_lattice -> false)) : is_atomistic (measurable_space fun_info) := sorry --non-trivial
lemma new_lemma_105285 (h0 : function.extfun Type group) : @group.fg.{0} (distrib_lattice.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (distrib_lattice.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_105286 (h0 : functor.add_const (functor.add_const (group pos) pos) (option unsigned)) : @group.fg.{0} pos (@functor.add_const.run.{0 0} (group.{0} pos) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (group.{0} pos) pos) (option.{0} unsigned) h0))  := sorry --non-trivial
lemma new_lemma_105287 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_105288 (h0 : functor.add_const (ring (has_pos_part pos)) linarith.comp) : @is_domain.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_pos_part.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_105289 (h0 : set (has_neg_part string.iterator_imp -> enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_105290 (h1 : topological_space (non_unital_non_assoc_semiring string.iterator_imp)) : totally_disconnected_space (non_unital_non_assoc_semiring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_105291 (h0 : functor.add_const (group (comm_group Type)) (has_nndist environment.implicit_infer_kind)) : @group.fg.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (comm_group.{1} Type)) (has_nndist.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_105292 (h0 : functor.add_const (topological_space (has_add name)) pos) : @normal_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_105293 (h0 : functor.add_const (ring (finset Type)) Type) : @strong_rank_condition.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (finset.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_105294 (h5 : has_lt (normed_field char)) : no_max_order (normed_field char) := sorry --non-trivial
lemma new_lemma_105295 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_105296 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_105297 (h0 : topological_space (has_pos_part (has_pos_part (has_add pos)))) : locally_compact_space (has_pos_part (has_pos_part (has_add pos))) := sorry --non-trivial
lemma new_lemma_105298 (h0 : add_comm_group (add_right_cancel_monoid num)) (h1 : topological_space (add_comm_group.total_positive_cone (add_right_cancel_monoid num))) : totally_separated_space (add_comm_group.total_positive_cone (add_right_cancel_monoid num)) := sorry --non-trivial
lemma new_lemma_105299 (h0 : functor.add_const (ordered_add_comm_monoid (has_zero linarith.comp)) environment.implicit_infer_kind) : @archimedean.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_zero.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_105300 (h0 : group (id (has_norm fun_info))) : is_cyclic (id (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_105301 (h0 : add_group (has_top linarith.comp)) : is_add_cyclic (has_top linarith.comp) := sorry --non-trivial
lemma new_lemma_105302 (h0 : topological_space (canonically_ordered_comm_semiring (has_add name))) : preirreducible_space (canonically_ordered_comm_semiring (has_add name)) := sorry --non-trivial
lemma new_lemma_105303 (h0 : add_monoid (boolean_algebra.core num)) : add_monoid.fg (boolean_algebra.core num) := sorry --non-trivial
lemma new_lemma_105304 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (mul_zero_class.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (mul_zero_class.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_105305 (h0 : complete_lattice (finset num)) : is_compactly_generated (finset num) := sorry --non-trivial
lemma new_lemma_105306 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} to_additive.value_type (@function.extfun_app.{2 1} Type topological_space.{0} h0 to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_105307 (h0 : prod (ordered_cancel_add_comm_monoid pos) (ordered_cancel_add_comm_monoid pos)) : set.diagonal (ordered_cancel_add_comm_monoid pos) h0 := sorry --non-trivial
lemma new_lemma_105308 (h0 : ring (has_nndist (boolean_algebra.core (has_nndist name)))) : rank_condition (has_nndist (boolean_algebra.core (has_nndist name))) := sorry --non-trivial
lemma new_lemma_105309 (h0 : topological_space (finset (has_nndist Type))) : preconnected_space (finset (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_105310 (h0 : functor.comp topological_space cancel_monoid name) : @regular_space.{0} (cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_105311 (h0 : filter (ring (add_comm_monoid Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_105312 (h0 : topological_space (measurable_space (semiring unsigned))) : preirreducible_space (measurable_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_105313 (h0 : not (complete_lattice (has_well_founded congr_arg_kind) -> false)) : @complete_lattice.is_Sup_finite_compact.{1} (has_well_founded.{1} congr_arg_kind) (@classical.by_contradiction'.{2} (complete_lattice.{1} (has_well_founded.{1} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_105314 (h0 : list (distrib_lattice (has_inv fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_105315 (h1 : topological_space (complete_semilattice_Sup linarith.ineq)) : path_connected_space (complete_semilattice_Sup linarith.ineq) := sorry --non-trivial
lemma new_lemma_105316 (h0 : ring (has_Sup (option (option (option (option (option unsigned))))))) : rank_condition (has_Sup (option (option (option (option (option unsigned)))))) := sorry --non-trivial
lemma new_lemma_105317 (h0 : functor.add_const (filter (ring name)) environment.implicit_infer_kind) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_105318 (h0 : topological_space (has_pos_part (ring (ordered_ring linarith.comp)))) : sequential_space (has_pos_part (ring (ordered_ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_105319 (h0 : semiring (with_one (semiring linarith.comp))) : is_noetherian_ring (with_one (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_105320 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_105321 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_105322 (h0 : functor.add_const (topological_space (has_well_founded congr_arg_kind)) empty) : @totally_disconnected_space.{1} (has_well_founded.{1} congr_arg_kind) (@functor.add_const.run.{1 0} (topological_space.{1} (has_well_founded.{1} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_105323 (h2 : group (complete_semilattice_Sup (with_one congr_arg_kind))) : normalizer_condition (complete_semilattice_Sup (with_one congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_105324 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) name) : @totally_separated_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_105325 (h1 : group (with_one (random_gen to_additive.value_type))) : is_cyclic (with_one (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_105326 (h0 : group (complete_semilattice_Sup linarith.ineq)) : normalizer_condition (complete_semilattice_Sup linarith.ineq) := sorry --non-trivial
lemma new_lemma_105327 (h0 : add_group (distrib string.iterator_imp)) : is_add_cyclic (distrib string.iterator_imp) := sorry --non-trivial
lemma new_lemma_105328 (h0 : functor.add_const (topological_space (has_inter num)) unsigned) : @totally_separated_space.{0} (has_inter.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_inter.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_105329 (h0 : topological_space (has_nnnorm (random_gen fun_info))) : totally_disconnected_space (has_nnnorm (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_105330 (h0 : not (topological_space (add_right_cancel_monoid empty) -> false)) : @t0_space.{0} (add_right_cancel_monoid.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (add_right_cancel_monoid.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_105331 (h0 : add_group (complete_distrib_lattice (has_add (has_add Type)))) : is_add_cyclic (complete_distrib_lattice (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_105332 (h0 : group (left_cancel_monoid num)) : normalizer_condition (left_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_105333 (h0 : functor.add_const (uniform_space (ordered_comm_ring name)) (boolean_algebra.core linarith.comp)) : @complete_space.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_comm_ring.{0} name)) (boolean_algebra.core.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_105334 (h0 : prod (has_dist unsigned) (has_dist unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_105335 (h0 : group (has_bot (has_add pos))) : is_simple_group (has_bot (has_add pos)) := sorry --non-trivial
lemma new_lemma_105336 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (measure_theory.measure_space.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} h0 (measure_theory.measure_space.{0} num))  := sorry --non-trivial
lemma new_lemma_105337 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_neg Type)) : @locally_compact_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_neg.{1} Type) h0) Type)  := sorry --non-trivial
lemma new_lemma_105338 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (omega_complete_partial_order.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (omega_complete_partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_105339 (h0 : functor.comp topological_space pseudo_metric_space ennreal) : @t0_space.{0} (pseudo_metric_space.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} pseudo_metric_space.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_105340 (h0 : ring (has_to_string (has_add (has_add Type)))) : is_principal_ideal_ring (has_to_string (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_105341 (h1 : filter (with_zero (has_nnnorm char))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_105342 (h2 : complete_lattice (encodable (random_gen string_imp))) : is_compactly_generated (encodable (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_105343 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_105344 (h0 : monoid (has_nndist environment.implicit_infer_kind)) : monoid.fg (has_nndist environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_105345 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_105346 (h0 : functor.add_const (add_group (has_zero (has_neg_part (has_neg_part pos)))) linarith.comp) : @is_add_cyclic.{0} (has_zero.{0} (has_neg_part.{0} (has_neg_part.{0} pos))) (@functor.add_const.run.{0 0} (add_group.{0} (has_zero.{0} (has_neg_part.{0} (has_neg_part.{0} pos)))) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_105347 (h0 : topological_space (canonically_ordered_comm_semiring (has_nndist ennreal))) : loc_path_connected_space (canonically_ordered_comm_semiring (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_105348 (h0 : functor.add_const (topological_space (boolean_algebra.core empty)) empty) : @path_connected_space.{0} (boolean_algebra.core.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_105349 (h0 : function.extfun Type (functor.add_const (topological_space ennreal))) : locally_compact_space ennreal := sorry --non-trivial
lemma new_lemma_105350 (h0 : list (plift (semiring num))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_105351 (h0 : finset (complete_distrib_lattice (has_add (finset pos)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_105352 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (bin_tree.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (bin_tree.{0} num))  := sorry --non-trivial
lemma new_lemma_105353 (h1 : complete_lattice (id (with_bot string_imp))) : complete_lattice.is_Sup_finite_compact (id (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_105354 (h0 : not (complete_lattice (linear_ordered_add_comm_group linarith.ineq) -> false)) : @is_compactly_generated.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_add_comm_group.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_105355 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (pseudo_metric_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_105356 (h0 : topological_space (normed_comm_ring (option unsigned))) : preirreducible_space (normed_comm_ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_105357 (h0 : monoid (has_to_string (has_add (has_add (comm_group Type))))) : monoid.fg (has_to_string (has_add (has_add (comm_group Type)))) := sorry --non-trivial
lemma new_lemma_105358 (h0 : complete_lattice (normed_group (random_gen linarith.ineq))) : is_compactly_generated (normed_group (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_105359 (h0 : functor.add_const (topological_space (mul_zero_class unsigned)) congr_arg_kind) : @normal_space.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_105360 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @complete_lattice.is_Sup_finite_compact.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 complete_lattice.{1}) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_105361 (h0 : functor.add_const (list (normed_comm_ring pos)) (has_neg Type)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_105362 (h0 : add_group (boolean_algebra.core (finset unsigned))) : is_add_cyclic (boolean_algebra.core (finset unsigned)) := sorry --non-trivial
lemma new_lemma_105363 (h0 : list (normed_comm_ring (comm_group pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_105364 (h0 : add_monoid (semiring (random_gen num))) : add_monoid.fg (semiring (random_gen num)) := sorry --non-trivial
lemma new_lemma_105365 (h0 : ring (has_to_string (has_to_string unsigned))) : strong_rank_condition (has_to_string (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_105366 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (ordered_cancel_add_comm_monoid.{0} (option.{0} pos)) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (ordered_cancel_add_comm_monoid.{0} (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_105367 (h0 : has_mem.mem (with_bot num) has_emptyc.emptyc) : @is_domain.{0} (with_bot.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (with_bot.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_105368 (h0 : ordered_comm_monoid (has_pos_part (has_add (finset (ring pos))))) : has_exists_mul_of_le (has_pos_part (has_add (finset (ring pos)))) := sorry --non-trivial
lemma new_lemma_105369 (h0 : uniform_space (distrib (mul_one_class (has_nnnorm (random_gen (random_gen reducibility_hints)))))) : complete_space (distrib (mul_one_class (has_nnnorm (random_gen (random_gen reducibility_hints))))) := sorry --non-trivial
lemma new_lemma_105370 (h0 : list (normed_comm_ring (has_zero linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_105371 (h0 : functor.add_const (finset (has_pos_part name)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_105372 (h0 : topological_space (has_zero (has_add pos))) : t0_space (has_zero (has_add pos)) := sorry --non-trivial
lemma new_lemma_105373 (h0 : ring (non_assoc_semiring (option (option unsigned)))) : is_domain (non_assoc_semiring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_105374 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @discrete_topology.{0} (monoid_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (monoid_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_105375 (h0 : cancel_comm_monoid_with_zero (has_zero (boolean_algebra linarith.comp))) : unique_factorization_monoid (has_zero (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_105376 (h0 : complete_lattice (with_zero string_imp)) : complete_lattice.is_Sup_finite_compact (with_zero string_imp) := sorry --non-trivial
lemma new_lemma_105377 (h0 : functor.add_const (filter (ring linarith.comp)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_105378 (h0 : topological_space (ring (normed_comm_ring (finset linarith.comp)))) : sequential_space (ring (normed_comm_ring (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_105379 (h0 : group (dlist (has_inv linarith.ineq))) : is_cyclic (dlist (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_105380 (h0 : functor.add_const (ring (add_comm_monoid name)) ennreal) : @strong_rank_condition.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} name)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_105381 (h0 : ring (has_append (random_gen to_additive.value_type))) : strong_rank_condition (has_append (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_105382 (h1 : topological_space (comm_ring (random_gen reducibility_hints))) : t0_space (comm_ring (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_105383 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (ring.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} num))))))) (@function.extfun_app.{2 1} Type ring.{0} h0 (ring.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} num))))))))  := sorry --non-trivial
lemma new_lemma_105384 (h0 : topological_space (distrib_lattice (has_ssubset to_additive.value_type))) : irreducible_space (distrib_lattice (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_105385 (h0 : uniform_space (comm_monoid (option (option (option empty))))) : complete_space (comm_monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_105386 (h0 : topological_space (uniform_space string_imp)) : totally_disconnected_space (uniform_space string_imp) := sorry --non-trivial
lemma new_lemma_105387 (h0 : functor.add_const (filter (has_to_string name)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_105388 (h0 : pnat) (h1 : with_bot empty) (h2 : ne h1 has_bot.bot) : pnat.coprime h0 (empty.elim (with_bot.unbot h1 h2)) := sorry --non-trivial
lemma new_lemma_105389 (h0 : monoid (has_zero (has_neg (has_to_string (ring environment.implicit_infer_kind))))) : monoid.fg (has_zero (has_neg (has_to_string (ring environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_105390 (h0 : list (with_bot (random_gen (random_gen fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_105391 (h0 : topological_space std_gen) (h1 : measurable_space std_gen) (h2 : measure_theory.measure std_gen) : measure_theory.measure.is_open_pos_measure h2 := sorry --non-trivial
lemma new_lemma_105392 (h0 : not (topological_space (with_bot linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (with_bot.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_105393 (h0 : complete_lattice (distrib_lattice (fintype linarith.ineq))) : is_compactly_generated (distrib_lattice (fintype linarith.ineq)) := sorry --non-trivial
lemma new_lemma_105394 (h0 : function.extfun (Type 1) group) : @is_cyclic.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_105395 (h0 : ring (linear_ordered_add_comm_group (random_gen (random_gen fun_info)))) : is_domain (linear_ordered_add_comm_group (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_105396 (h0 : has_mem.mem uniform_space has_emptyc.emptyc) : @separated_space.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} h0) (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_105397 (h0 : functor.add_const (functor.add_const (topological_space Type) Type) pos) : @discrete_topology.{1} Type (@functor.add_const.run.{1 1} (topological_space.{1} Type) Type (@functor.add_const.run.{1 0} (functor.add_const.{1 1} (topological_space.{1} Type) Type) pos h0))  := sorry --non-trivial
lemma new_lemma_105398 (h0 : group (has_bot (has_add (has_pos_part (has_bot (has_Inf (has_Inf Type))))))) : is_simple_group (has_bot (has_add (has_pos_part (has_bot (has_Inf (has_Inf Type)))))) := sorry --non-trivial
lemma new_lemma_105399 (h0 : list (has_to_string (has_to_string (finset Type)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_105400 (h0 : ring (linear_ordered_comm_group_with_zero string.iterator_imp)) : is_domain (linear_ordered_comm_group_with_zero string.iterator_imp) := sorry --non-trivial
lemma new_lemma_105401 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @normalizer_condition.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_105402 (h0 : functor.add_const (ring (free_add_monoid empty)) empty) : @strong_rank_condition.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (free_add_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_105403 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_105404 (h0 : topological_space (add_left_cancel_semigroup empty)) : normal_space (add_left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_105405 (h0 : function.extfun Type (functor.add_const (topological_space pos))) : @loc_path_connected_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) ennreal (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} pos)) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_105406 (h0 : uniform_space (has_bot (option empty))) : complete_space (has_bot (option empty)) := sorry --non-trivial
lemma new_lemma_105407 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (finset.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_105408 (h1 : ring (has_neg_part char)) : rank_condition (has_neg_part char) := sorry --non-trivial
lemma new_lemma_105409 (h0 : group (canonically_ordered_comm_semiring (finset name))) : is_cyclic (canonically_ordered_comm_semiring (finset name)) := sorry --non-trivial
lemma new_lemma_105410 (h0 : functor.add_const (complete_lattice (mul_zero_class unsigned)) unsigned) : @is_atomistic.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (mul_zero_class.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_105411 (h0 : topological_space (ordered_ring (semiring (semiring (semiring (semiring empty)))))) : path_connected_space (ordered_ring (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_105412 (h0 : functor.add_const (prod ennreal ennreal) ennreal) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_105413 (h0 : comm_semiring fun_info) (h1 : polynomial fun_info) : polynomial.is_primitive h1 := sorry --non-trivial
lemma new_lemma_105414 (h0 : not (topological_space (left_cancel_semigroup congr_arg_kind) -> false)) : @totally_disconnected_space.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (left_cancel_semigroup.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_105415 (h0 : topological_space (add_cancel_comm_monoid (has_lt reducibility_hints))) : t0_space (add_cancel_comm_monoid (has_lt reducibility_hints)) := sorry --non-trivial
lemma new_lemma_105416 (h4 : not (ring (has_ssubset string_imp) -> false)) : @rank_condition.{0} (has_ssubset.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (has_ssubset.{0} string_imp)) h4)  := sorry --non-trivial
lemma new_lemma_105417 (h0 : complete_lattice (has_neg (has_pos_part linarith.comp))) : complete_lattice.is_Sup_finite_compact (has_neg (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_105418 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra Type)) environment.implicit_infer_kind) : @archimedean.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (boolean_algebra.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_105419 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_105420 (h0 : semiring (ring (has_pos_part (has_pos_part linarith.comp)))) : is_noetherian_ring (ring (has_pos_part (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_105421 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (filter empty)) := sorry --non-trivial
lemma new_lemma_105422 (h0 : topological_space (generalized_boolean_algebra (sub_neg_monoid name))) : normal_space (generalized_boolean_algebra (sub_neg_monoid name)) := sorry --non-trivial
lemma new_lemma_105423 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} h0 (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_105424 (h0 : add_group (measurable_space (semiring (semiring unsigned)))) : is_add_cyclic (measurable_space (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_105425 (h0 : group (has_Inf (has_add pos))) : is_cyclic (has_Inf (has_add pos)) := sorry --non-trivial
lemma new_lemma_105426 (h0 : not (has_mem.mem (random_gen fun_info) has_emptyc.emptyc -> false)) : @is_compactly_generated.{0} (random_gen.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (random_gen.{0} fun_info) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} fun_info) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_105427 (h0 : uniform_space (has_norm (has_top linarith.comp_source))) : separated_space (has_norm (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_105428 (h1 : functor.comp topological_space fintype string_imp) : @totally_disconnected_space.{0} (fintype.{0} string_imp) (@functor.comp.run.{0 0 0} topological_space.{0} fintype.{0} string_imp h1)  := sorry --non-trivial
lemma new_lemma_105429 (h0 : monoid (with_bot (random_gen (has_top (has_top num))))) : monoid.fg (with_bot (random_gen (has_top (has_top num)))) := sorry --non-trivial
lemma new_lemma_105430 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_105431 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring ennreal)) name) : @normal_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_105432 (h0 : topological_space (ordered_comm_ring (has_neg name))) : loc_path_connected_space (ordered_comm_ring (has_neg name)) := sorry --non-trivial
lemma new_lemma_105433 (h0 : functor.add_const (complete_lattice (has_pos_part Type)) name) : @complete_lattice.is_Sup_finite_compact.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_pos_part.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_105434 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_105435 (h0 : topological_space (add_cancel_monoid (finset (has_to_string (has_to_string pos))))) : loc_path_connected_space (add_cancel_monoid (finset (has_to_string (has_to_string pos)))) := sorry --non-trivial
lemma new_lemma_105436 (h0 : set (add_comm_semigroup (nondiscrete_normed_field string.iterator_imp) -> add_comm_semigroup enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_105437 (h0 : group (linear_ordered_comm_group (option pos))) : group.fg (linear_ordered_comm_group (option pos)) := sorry --non-trivial
lemma new_lemma_105438 (h0 : topological_space (has_add (has_add Type))) : totally_disconnected_space (has_add (has_add Type)) := sorry --non-trivial
lemma new_lemma_105439 (h0 : list (has_dist (option (option (option empty))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_105440 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (dlist.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (dlist.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_105441 (h0 : monoid (with_bot (has_top (has_top fun_info)))) : monoid.fg (with_bot (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_105442 (h0 : function.extfun Type (functor.comp semiring complete_distrib_lattice)) : @is_noetherian_ring.{0} (complete_distrib_lattice.{0} pos) (@functor.comp.run.{0 0 0} semiring.{0} complete_distrib_lattice.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} semiring.{0} complete_distrib_lattice.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_105443 (h0 : group (measurable_space (random_gen (random_gen (random_gen linarith.comp_source))))) : normalizer_condition (measurable_space (random_gen (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_105444 (h0 : ring (add_left_cancel_monoid (random_gen (random_gen char)))) : rank_condition (add_left_cancel_monoid (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_105445 (h0 : set (set ereal)) (h1 : ereal) : set.sInter h0 h1 := sorry --non-trivial
lemma new_lemma_105446 (h0 : topological_space (normed_comm_ring (has_add (has_add pos)))) : locally_compact_space (normed_comm_ring (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_105447 (h0 : ring (dlist (random_gen fun_info))) : rank_condition (dlist (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_105448 (h0 : has_zero (option ennreal) -> has_zero (option ennreal) -> Prop) : is_symm (has_zero (option ennreal)) h0 := sorry --non-trivial
lemma new_lemma_105449 (h1 : ring (random_gen char)) : strong_rank_condition (random_gen char) := sorry --non-trivial
lemma new_lemma_105450 (h0 : ring (measurable_space.dynkin_system (option (finset name)))) : is_principal_ideal_ring (measurable_space.dynkin_system (option (finset name))) := sorry --non-trivial
lemma new_lemma_105451 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_105452 (h0 : functor.add_const (finset (normed_comm_ring unsigned)) (option empty)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_105453 (h0 : group (finset pos)) : group.fg (finset pos) := sorry --non-trivial
lemma new_lemma_105454 (h0 : ring (finset (finset (has_sdiff (has_add Type))))) : is_domain (finset (finset (has_sdiff (has_add Type)))) := sorry --non-trivial
lemma new_lemma_105455 (h0 : semiring (mul_one_class (add_comm_semigroup linarith.ineq))) (h1 : ideal (mul_one_class (add_comm_semigroup linarith.ineq))) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_105456 (h0 : topological_space (ordered_cancel_add_comm_monoid congr_arg_kind)) : topological_space.separable_space (ordered_cancel_add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_105457 (h0 : topological_space (cancel_monoid (comm_group (comm_group name)))) : t0_space (cancel_monoid (comm_group (comm_group name))) := sorry --non-trivial
lemma new_lemma_105458 (h0 : group (has_compl (topological_space linarith.ineq))) : is_cyclic (has_compl (topological_space linarith.ineq)) := sorry --non-trivial
lemma new_lemma_105459 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_simple_group.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_105460 (h0 : filter (has_zero linarith.comp)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_105461 (h0 : ring (distrib_lattice (random_gen string_imp))) : is_domain (distrib_lattice (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_105462 (h0 : add_group (has_neg (add_left_cancel_monoid linarith.comp))) : is_add_cyclic (has_neg (add_left_cancel_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_105463 (h0 : not (ring (normed_field linarith.comp_source) -> false)) : @is_domain.{0} (normed_field.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (normed_field.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_105464 (h0 : functor.add_const (list (semigroup pos)) environment.implicit_infer_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_105465 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) fun_info) := sorry --non-trivial
lemma new_lemma_105466 (h0 : set (has_lt (mul_one_class (mul_one_class enat)))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_105467 (h0 : topological_space (add_cancel_monoid (has_neg (has_neg name)))) : topological_space.separable_space (add_cancel_monoid (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_105468 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_nndist unsigned)) := sorry --non-trivial
lemma new_lemma_105469 (h0 : topological_space (has_top (id empty))) : locally_compact_space (has_top (id empty)) := sorry --non-trivial
lemma new_lemma_105470 (h0 : functor.add_const (uniform_space (free_add_monoid empty)) num) : @separated_space.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (free_add_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_105471 (h0 : complete_lattice (has_lt (mul_one_class (mul_one_class linarith.ineq)))) : complete_lattice.is_Sup_finite_compact (has_lt (mul_one_class (mul_one_class linarith.ineq))) := sorry --non-trivial
lemma new_lemma_105472 (h0 : topological_space (comm_semigroup real)) : sequential_space (comm_semigroup real) := sorry --non-trivial
lemma new_lemma_105473 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (simple_graph.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_105474 (h0 : list (has_emptyc (has_inv to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_105475 (h0 : ordered_comm_monoid (has_top (has_ssubset (has_inv (random_gen to_additive.value_type))))) (h1 : set (ordered_comm_monoid (has_top (has_ssubset (has_inv (random_gen to_additive.value_type)))))) : set.mem h0 h1 := sorry --non-trivial
lemma new_lemma_105476 (h0 : has_lt (add_comm_semigroup (mul_one_class string.iterator_imp))) : no_max_order (add_comm_semigroup (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_105477 (h0 : functor.add_const (add_group (complete_distrib_lattice Type)) name) : @is_add_cyclic.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (complete_distrib_lattice.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_105478 (h0 : complete_lattice (id (has_norm empty))) : is_compactly_generated (id (has_norm empty)) := sorry --non-trivial
lemma new_lemma_105479 (h0 : topological_space (canonically_ordered_comm_semiring (has_nndist Type))) : topological_space.separable_space (canonically_ordered_comm_semiring (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_105480 (h0 : not (has_mem.mem (with_bot fun_info) has_emptyc.emptyc -> false)) : @totally_disconnected_space.{0} (with_bot.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} fun_info) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} fun_info) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_105481 (h0 : functor.add_const (ordered_comm_monoid Type) Type) : @has_exists_mul_of_le.{1} Type (@functor.add_const.run.{1 1} (ordered_comm_monoid.{1} Type) Type h0)  := sorry --non-trivial
lemma new_lemma_105482 (h0 : topological_space (semigroup linarith.comp)) : loc_path_connected_space (semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_105483 (h0 : finset (normed_comm_ring (comm_monoid (comm_monoid (ring unsigned))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_105484 (h0 : functor.add_const (complete_lattice (has_nndist name)) name) : @is_compactly_generated.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_105485 (h0 : semiring (left_cancel_monoid num)) : is_noetherian_ring (left_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_105486 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_105487 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_nndist.{0} (option.{0} (option.{0} pos))) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_nndist.{0} (option.{0} (option.{0} pos))))  := sorry --non-trivial
lemma new_lemma_105488 (h0 : finset (add_group unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_105489 (h0 : complete_lattice (finset (option (option pos)))) : is_compactly_generated (finset (option (option pos))) := sorry --non-trivial
lemma new_lemma_105490 (h0 : topological_space (add_comm_monoid ennreal)) : totally_separated_space (add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_105491 (h0 : topological_space (has_to_string (has_pos_part Type))) : t0_space (has_to_string (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_105492 (h0 : functor.add_const (group (add_comm_monoid pos)) environment.implicit_infer_kind) : @is_simple_group.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (add_comm_monoid.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_105493 (h0 : preorder string.iterator_imp) (h2 : Prop) : set.is_pwo (id (fun (h1 : string.iterator_imp), h2)) := sorry --non-trivial
lemma new_lemma_105494 (h2 : ring (linear_ordered_add_comm_group fun_info)) : strong_rank_condition (linear_ordered_add_comm_group fun_info) := sorry --non-trivial
lemma new_lemma_105495 (h0 : add_group (has_Inf (has_Inf real))) : is_add_cyclic (has_Inf (has_Inf real)) := sorry --non-trivial
lemma new_lemma_105496 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) h0) (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_105497 (h0 : ring (generalized_boolean_algebra (has_nndist pos))) : strong_rank_condition (generalized_boolean_algebra (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_105498 (h0 : ring (fintype linarith.comp_source)) : rank_condition (fintype linarith.comp_source) := sorry --non-trivial
lemma new_lemma_105499 (h0 : ordered_add_comm_monoid (has_Inf real)) : archimedean (has_Inf real) := sorry --non-trivial
lemma new_lemma_105500 (h1 : ring (is_R_or_C char)) : is_domain (is_R_or_C char) := sorry --non-trivial
lemma new_lemma_105501 (h0 : complete_lattice (mul_one_class (add_comm_semigroup ereal))) : complete_lattice.is_Sup_finite_compact (mul_one_class (add_comm_semigroup ereal)) := sorry --non-trivial
lemma new_lemma_105502 (h0 : ring (ordered_comm_ring (has_pos_part (has_Inf pos)))) : rank_condition (ordered_comm_ring (has_pos_part (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_105503 (h0 : functor.add_const (cancel_comm_monoid_with_zero (left_cancel_monoid empty)) empty) : @unique_factorization_monoid.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (left_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_105504 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring ennreal)) name) : @t0_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_105505 (h0 : topological_space (comm_group environment.implicit_infer_kind)) : t1_space (comm_group environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_105506 (h0 : functor.add_const (list (as_linear_order empty)) empty) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_105507 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_add_cyclic.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 add_group.{1}) (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_105508 (h0 : fin has_zero.zero) : @is_cyclic.{1} (ring.{1} Type) (@matrix.vec_empty.{1} (group.{1} (ring.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))))  := sorry --non-trivial
lemma new_lemma_105509 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @complete_space.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 uniform_space.{1}) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_105510 (h0 : add_monoid (complete_linear_order empty)) : add_monoid.fg (complete_linear_order empty) := sorry --non-trivial
lemma new_lemma_105511 (h0 : topological_space (has_to_string (has_nndist (ring pos)))) : path_connected_space (has_to_string (has_nndist (ring pos))) := sorry --non-trivial
lemma new_lemma_105512 (h0 : uniform_space (complete_distrib_lattice real)) : separated_space (complete_distrib_lattice real) := sorry --non-trivial
lemma new_lemma_105513 (h0 : add_group (has_top (has_norm (has_norm fun_info)))) : is_add_cyclic (has_top (has_norm (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_105514 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_105515 (h0 : uniform_space (has_sdiff empty)) : complete_space (has_sdiff empty) := sorry --non-trivial
lemma new_lemma_105516 (h0 : functor.add_const (ordered_add_comm_monoid (comm_group name)) name) : @archimedean.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (comm_group.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_105517 (h0 : ring (semi_normed_ring (mul_one_class reducibility_hints))) : rank_condition (semi_normed_ring (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_105518 (h0 : topological_space (has_add (has_to_string pos))) : regular_space (has_add (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_105519 (h0 : fin has_zero.zero) : @is_cyclic.{1} (finset.{1} Type) (@matrix.vec_empty.{1} (group.{1} (finset.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_105520 (h0 : cancel_comm_monoid_with_zero (simple_graph (finset (finset Type)))) : unique_factorization_monoid (simple_graph (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_105521 (h0 : functor.add_const (topological_space (ring linarith.comp)) pos) : @path_connected_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_105522 (h0 : functor.comp ring normed_comm_ring pos) : @strong_rank_condition.{0} (normed_comm_ring.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} normed_comm_ring.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_105523 (h0 : uniform_space (plift (semiring (semiring (semiring (semiring congr_arg_kind)))))) : complete_space (plift (semiring (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_105524 (h0 : functor.add_const (function.extfun Type add_monoid) environment.implicit_infer_kind) : @add_monoid.fg.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) environment.implicit_infer_kind h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_105525 (h0 : not (ring (complete_semilattice_Sup to_additive.value_type) -> false)) : @strong_rank_condition.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (complete_semilattice_Sup.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_105526 (h0 : ring (semiring empty)) : is_principal_ideal_ring (semiring empty) := sorry --non-trivial
lemma new_lemma_105527 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) Type) : @topological_space.separable_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (add_cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_105528 (h1 : set linarith.comp_source) : set.finite h1 := sorry --non-trivial
lemma new_lemma_105529 (h0 : function.extfun Type group) : @is_simple_group.{0} ennreal (@function.extfun_app.{2 1} Type group.{0} h0 ennreal)  := sorry --non-trivial
lemma new_lemma_105530 (h0 : ordered_comm_monoid (has_add (has_add (has_to_string pos)))) : has_exists_mul_of_le (has_add (has_add (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_105531 (h0 : topological_space (random_gen empty)) : path_connected_space (random_gen empty) := sorry --non-trivial
lemma new_lemma_105532 (h0 : topological_space (filter (option (option (option (option (option (option unsigned)))))))) : t1_space (filter (option (option (option (option (option (option unsigned))))))) := sorry --non-trivial
lemma new_lemma_105533 (h0 : topological_space (metric_space num)) : locally_compact_space (metric_space num) := sorry --non-trivial
lemma new_lemma_105534 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) linarith.comp) : @complete_space.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) uniform_space.{1}) linarith.comp h0) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_105535 (h0 : set (simple_graph (mul_one_class environment.projection_info))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_105536 (h0 : topological_space (non_unital_non_assoc_semiring (mul_one_class fun_info))) (h1 : preorder (non_unital_non_assoc_semiring (mul_one_class fun_info))) : order_closed_topology (non_unital_non_assoc_semiring (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_105537 (h0 : topological_space (monoid pos)) : normal_space (monoid pos) := sorry --non-trivial
lemma new_lemma_105538 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_105539 (h0 : not (group (has_nnnorm char) -> false)) : @group.fg.{0} (has_nnnorm.{0} char) (@classical.by_contradiction'.{1} (group.{0} (has_nnnorm.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_105540 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} znum (@function.extfun_app.{2 1} Type topological_space.{0} h0 znum)  := sorry --non-trivial
lemma new_lemma_105541 (h2 : has_coe (add_comm_semigroup fun_info) Prop) (h3 : add_comm_semigroup fun_info) : @coe_b.{1 1} (add_comm_semigroup.{0} fun_info) Prop h2 h3  := sorry --non-trivial
lemma new_lemma_105542 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (filter.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (filter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_105543 (h0 : topological_space (has_div (mul_one_class enat))) (h1 : add_group (has_div (mul_one_class enat))) : topological_add_group (has_div (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_105544 (h2 : complete_lattice (linear_ordered_add_comm_group fun_info)) : is_compactly_generated (linear_ordered_add_comm_group fun_info) := sorry --non-trivial
lemma new_lemma_105545 (h0 : topological_space (has_pos_part (sub_neg_monoid (ordered_comm_monoid real)))) : preconnected_space (has_pos_part (sub_neg_monoid (ordered_comm_monoid real))) := sorry --non-trivial
lemma new_lemma_105546 (h0 : list (monoid_with_zero pos)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_105547 (h0 : group (linear_ordered_comm_monoid_with_zero (option (option (option (option empty)))))) : is_cyclic (linear_ordered_comm_monoid_with_zero (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_105548 (h0 : functor.add_const (topological_space (add_left_cancel_semigroup congr_arg_kind)) empty) : @totally_separated_space.{0} (add_left_cancel_semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_105549 (h0 : function.extfun nat fin) : @is_cyclic.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))))) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_105550 (h0 : topological_space (normed_comm_ring (has_neg (has_add (has_neg linarith.comp))))) : sequential_space (normed_comm_ring (has_neg (has_add (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_105551 (h0 : group (cancel_monoid (has_neg_part Type))) : is_simple_group (cancel_monoid (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_105552 (h0 : ring (monoid_with_zero pos)) : rank_condition (monoid_with_zero pos) := sorry --non-trivial
lemma new_lemma_105553 (h0 : topological_space (mul_zero_class (semiring unsigned))) : locally_compact_space (mul_zero_class (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_105554 (h0 : functor.add_const (topological_space (semigroup pos)) name) : @totally_separated_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_105555 (h0 : functor.add_const (ring (comm_group unsigned)) name) : @strong_rank_condition.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_105556 (h0 : add_group (mul_one_class (mul_one_class reducibility_hints))) : is_add_cyclic (mul_one_class (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_105557 (h0 : function.extfun (Type 1) filter) : filter.ne_bot (function.extfun_app h0 (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_105558 (h6 : has_lt (has_lt ereal)) : no_max_order (has_lt ereal) := sorry --non-trivial
lemma new_lemma_105559 (h0 : functor.add_const (add_monoid (boolean_algebra pos)) (finset Type)) : @add_monoid.fg.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (add_monoid.{0} (boolean_algebra.{0} pos)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_105560 (h0 : topological_space (add_cancel_monoid (add_cancel_monoid name))) : normal_space (add_cancel_monoid (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_105561 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) linarith.comp) : @discrete_topology.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_105562 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (measure_theory.measure_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measure_theory.measure_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_105563 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_105564 (h0 : functor.add_const (add_group (add_cancel_monoid Type)) (mul_one_class linarith.comp)) : @is_add_cyclic.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (add_cancel_monoid.{1} Type)) (mul_one_class.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_105565 (h0 : semiring (has_edist congr_arg_kind)) : is_noetherian_ring (has_edist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_105566 (h0 : ordered_add_comm_monoid (has_neg (has_add (has_neg (has_neg linarith.comp))))) : archimedean (has_neg (has_add (has_neg (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_105567 (h0 : list (cancel_monoid (option (complete_distrib_lattice (option pos))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_105568 (h0 : semiring (semigroup (has_add (has_nndist linarith.comp)))) : is_noetherian_ring (semigroup (has_add (has_nndist linarith.comp))) := sorry --non-trivial
lemma new_lemma_105569 (h0 : ring (random_gen string_imp)) : strong_rank_condition (random_gen string_imp) := sorry --non-trivial
lemma new_lemma_105570 (h0 : functor.add_const (ring (ordered_comm_ring Type)) (ordered_ring linarith.comp)) : @strong_rank_condition.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (ordered_comm_ring.{1} Type)) (ordered_ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_105571 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_add linarith.comp)) : @topological_space.separable_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_add.{0} linarith.comp) h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_105572 (h0 : add_monoid (sub_neg_monoid (has_bot name))) : add_monoid.fg (sub_neg_monoid (has_bot name)) := sorry --non-trivial
lemma new_lemma_105573 (h1 : not (topological_space (has_append char) -> false)) : @t0_space.{0} (has_append.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (has_append.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_105574 (h0 : group (has_dist (option num))) : is_cyclic (has_dist (option num)) := sorry --non-trivial
lemma new_lemma_105575 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_Sup (semiring empty))) := sorry --non-trivial
lemma new_lemma_105576 (h0 : topological_space (normed_comm_ring unsigned)) : totally_separated_space (normed_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_105577 (h0 : functor.add_const Prop (has_Inf Type)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_105578 (h0 : add_monoid (canonically_ordered_add_monoid (option num))) : add_monoid.fg (canonically_ordered_add_monoid (option num)) := sorry --non-trivial
lemma new_lemma_105579 (h0 : functor.add_const (ring (finset linarith.comp)) environment.implicit_infer_kind) : @rank_condition.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_105580 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_star.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_star.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_105581 (h0 : topological_space (linear_ordered_comm_monoid_with_zero unsigned)) : totally_separated_space (linear_ordered_comm_monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_105582 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (boolean_algebra.core.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.core.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_105583 (h0 : group (with_zero (has_inv string_imp))) : is_cyclic (with_zero (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_105584 (h1 : order_hom nat (topological_space (comm_ring (has_nnnorm (metric_space string_imp))))) : @path_connected_space.{0} (comm_ring.{0} (has_nnnorm.{0} (metric_space.{0} string_imp))) (@monotonic_sequence_limit.{0} (topological_space.{0} (comm_ring.{0} (has_nnnorm.{0} (metric_space.{0} string_imp)))) (@topological_space.partial_order.{0} (comm_ring.{0} (has_nnnorm.{0} (metric_space.{0} string_imp)))) h1)  := sorry --non-trivial
lemma new_lemma_105585 (h0 : uniform_space (has_append (has_nnnorm fun_info))) : complete_space (has_append (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_105586 (h0 : functor.add_const (monoid (left_cancel_monoid unsigned)) (semiring empty)) : @monoid.fg.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (left_cancel_monoid.{0} unsigned)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_105587 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) Type) : @preirreducible_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_105588 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_105589 (h0 : topological_space (normed_group (semiring (semiring (semiring (semiring congr_arg_kind)))))) : irreducible_space (normed_group (semiring (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_105590 (h0 : set (topological_space (add_comm_semigroup ereal) -> string.iterator_imp)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_105591 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_105592 (h0 : topological_space (has_edist (semiring empty))) : locally_compact_space (has_edist (semiring empty)) := sorry --non-trivial
lemma new_lemma_105593 (h0 : functor.add_const (topological_space (semiring empty)) num) : @discrete_topology.{0} (semiring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_105594 (h1 : function.extfun Type topological_space) : @path_connected_space.{0} (with_one.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (with_one.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_105595 (h0 : add_monoid (has_nndist (has_add (has_Inf (has_Inf (has_add Type)))))) : add_monoid.fg (has_nndist (has_add (has_Inf (has_Inf (has_add Type))))) := sorry --non-trivial
lemma new_lemma_105596 (h0 : topological_space (has_neg_part (comm_group name))) : normal_space (has_neg_part (comm_group name)) := sorry --non-trivial
lemma new_lemma_105597 (h1 : topological_space (random_gen (random_gen (random_gen string_imp)))) : path_connected_space (random_gen (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_105598 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_105599 (h0 : complete_lattice (complete_semilattice_Sup (has_top linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (complete_semilattice_Sup (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_105600 (h0 : filter (with_bot unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_105601 (h0 : functor.add_const (topological_space (ring Type)) name) : @regular_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_105602 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_105603 (h0 : functor.add_const (add_group (complete_distrib_lattice linarith.comp)) name) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (complete_distrib_lattice.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_105604 (h1 : set (has_ssubset char)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_105605 (h0 : function.extfun Type group) : @normalizer_condition.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_105606 (h0 : list (add_comm_monoid (sub_neg_monoid linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_105607 (h0 : functor.add_const (function.extfun Type finset) pos) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (normed_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_105608 (h0 : uniform_space (canonically_ordered_comm_semiring unsigned)) : complete_space (canonically_ordered_comm_semiring unsigned) := sorry --non-trivial
lemma new_lemma_105609 (h0 : topological_space (canonically_ordered_comm_semiring (has_add name))) : t1_space (canonically_ordered_comm_semiring (has_add name)) := sorry --non-trivial
lemma new_lemma_105610 (h0 : functor.add_const (topological_space (has_to_string Type)) environment.implicit_infer_kind) : @t1_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_105611 (h0 : functor.add_const (semiring (has_to_string pos)) (has_neg pos)) : @is_noetherian_ring.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (has_to_string.{0} pos)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_105612 (h1 : complete_lattice (has_add string_imp)) : is_compactly_generated (has_add string_imp) := sorry --non-trivial
lemma new_lemma_105613 (h0 : topological_space (semi_normed_ring enat)) : totally_disconnected_space (semi_normed_ring enat) := sorry --non-trivial
lemma new_lemma_105614 (h0 : cancel_comm_monoid_with_zero linarith.comp) : unique_factorization_monoid linarith.comp := sorry --non-trivial
lemma new_lemma_105615 (h0 : functor.add_const (function.extfun Type ring) environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) environment.implicit_infer_kind h0) (comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_105616 (h0 : group (has_Inf (has_add (boolean_algebra name)))) : is_cyclic (has_Inf (has_add (boolean_algebra name))) := sorry --non-trivial
lemma new_lemma_105617 (h0 : function.extfun Type topological_space) : @t1_space.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_105618 (h0 : monoid (has_pos_part (has_add Type))) : monoid.fg (has_pos_part (has_add Type)) := sorry --non-trivial
lemma new_lemma_105619 (h0 : functor.add_const (ordered_add_comm_monoid (ordered_comm_ring pos)) Type) : @archimedean.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (ordered_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_105620 (h0 : ring (linear_ordered_ring char)) : rank_condition (linear_ordered_ring char) := sorry --non-trivial
lemma new_lemma_105621 (h1 : not (filter (has_nnnorm char) -> false)) : filter.ne_bot (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_105622 (h0 : filter (ordered_comm_ring Type)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_105623 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @sequential_space.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_105624 (h0 : group (omega_complete_partial_order num)) : normalizer_condition (omega_complete_partial_order num) := sorry --non-trivial
lemma new_lemma_105625 (h0 : filter (has_add (semigroup linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_105626 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (preorder.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (preorder.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_105627 (h0 : ring (normed_group (has_nnnorm linarith.ineq))) : strong_rank_condition (normed_group (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_105628 (h0 : functor.add_const (complete_lattice (add_cancel_monoid unsigned)) num) : @complete_lattice.is_Sup_finite_compact.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_105629 (h0 : functor.add_const (topological_space (finset Type)) environment.implicit_infer_kind) : @normal_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_105630 (h0 : topological_space (add_comm_monoid (has_add Type))) : t0_space (add_comm_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_105631 (h0 : ring (has_nnnorm (mul_one_class (mul_one_class string.iterator_imp)))) : is_domain (has_nnnorm (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_105632 (h0 : topological_space (comm_ring (has_compl to_additive.value_type))) : topological_space.separable_space (comm_ring (has_compl to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_105633 (h0 : topological_space (canonically_ordered_monoid real)) : preirreducible_space (canonically_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_105634 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @path_connected_space.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_105635 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_105636 (h0 : not (topological_space (simple_graph to_additive.value_type) -> false)) : @path_connected_space.{0} (simple_graph.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (simple_graph.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_105637 (h0 : topological_space (has_norm (has_norm (has_norm congr_arg_kind)))) : preirreducible_space (has_norm (has_norm (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_105638 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (complete_linear_order unsigned)) := sorry --non-trivial
lemma new_lemma_105639 (h0 : ring (pseudo_metric_space pos)) : rank_condition (pseudo_metric_space pos) := sorry --non-trivial
lemma new_lemma_105640 (h0 : linarith.comp_source -> linarith.comp_source -> Prop) : is_extensional linarith.comp_source h0 := sorry --non-trivial
lemma new_lemma_105641 (h0 : complete_lattice (linear_ordered_semiring linarith.ineq)) : is_compactly_generated (linear_ordered_semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_105642 (h2 : set (add_comm_semigroup ereal -> char)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_105643 (h0 : group (add_comm_monoid ennreal)) : is_simple_group (add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_105644 (h0 : ring (has_to_string (has_add linarith.comp))) : is_principal_ideal_ring (has_to_string (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_105645 (h0 : not (complete_lattice (dlist fun_info) -> false)) : @is_compactly_generated.{0} (dlist.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (dlist.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_105646 (h0 : functor.add_const (ring (has_neg Type)) (has_add pos)) : @rank_condition.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_neg.{1} Type)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_105647 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_105648 (h0 : function.extfun Type (functor.add_const (monoid (left_cancel_monoid unsigned)))) : @monoid.fg.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (left_cancel_monoid.{0} unsigned)) (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty)))) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (monoid.{0} (left_cancel_monoid.{0} unsigned))) h0 (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty))))))  := sorry --non-trivial
lemma new_lemma_105649 (h0 : group (generalized_boolean_algebra (ring linarith.comp))) : group.fg (generalized_boolean_algebra (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_105650 (h0 : topological_space (comm_group unsigned)) : sequential_space (comm_group unsigned) := sorry --non-trivial
lemma new_lemma_105651 (h0 : ring (ordered_comm_monoid (ordered_comm_ring (has_add Type)))) : is_domain (ordered_comm_monoid (ordered_comm_ring (has_add Type))) := sorry --non-trivial
lemma new_lemma_105652 (h0 : fin has_zero.zero) : @discrete_topology.{0} (ordered_comm_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_105653 (h0 : ordered_comm_monoid (semigroup (has_add Type))) : has_exists_mul_of_le (semigroup (has_add Type)) := sorry --non-trivial
lemma new_lemma_105654 (h0 : topological_space (add_semigroup (option empty))) : totally_disconnected_space (add_semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_105655 (h0 : monoid (add_semigroup (option (option empty)))) : monoid.fg (add_semigroup (option (option empty))) := sorry --non-trivial
lemma new_lemma_105656 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @preconnected_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_105657 (h0 : not (group (semi_normed_comm_ring to_additive.value_type) -> false)) : @is_cyclic.{0} (semi_normed_comm_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (semi_normed_comm_ring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_105658 (h0 : topological_space (add_comm_monoid (has_add pos))) : topological_space.separable_space (add_comm_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_105659 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (ring.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ring.{0} num))  := sorry --non-trivial
lemma new_lemma_105660 (h0 : not (complete_lattice (random_gen string_imp) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (random_gen.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_105661 (h0 : topological_space (has_zero (has_add (has_add Type)))) : t0_space (has_zero (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_105662 (h0 : ring (random_gen (random_gen (has_nnnorm to_additive.value_type)))) : rank_condition (random_gen (random_gen (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_105663 (h0 : monoid (has_to_string (has_to_string (comm_group (has_add environment.implicit_infer_kind))))) : monoid.fg (has_to_string (has_to_string (comm_group (has_add environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_105664 (h0 : measurable_space std_gen) (h1 : has_div std_gen) : subsingleton (has_measurable_div₂ std_gen) := sorry --non-trivial
lemma new_lemma_105665 (h0 : complete_lattice (linear_ordered_add_comm_group (has_nnnorm linarith.ineq))) : complete_lattice.is_Sup_finite_compact (linear_ordered_add_comm_group (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_105666 (h0 : has_mem.mem (has_norm congr_arg_kind) has_emptyc.emptyc) : @is_atomistic.{0} (has_norm.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_norm.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_105667 (h0 : topological_space (has_pos_part (has_Inf name))) : t1_space (has_pos_part (has_Inf name)) := sorry --non-trivial
lemma new_lemma_105668 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @preirreducible_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_105669 (h0 : topological_space (has_pos_part (has_neg (finset pos)))) : preirreducible_space (has_pos_part (has_neg (finset pos))) := sorry --non-trivial
lemma new_lemma_105670 (h0 : ring (normed_group (semiring empty))) : is_principal_ideal_ring (normed_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_105671 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_principal_ideal_ring.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_105672 (h0 : option (add_group (div_inv_monoid fun_info))) (h1 : add_group (div_inv_monoid fun_info)) : is_add_cyclic (div_inv_monoid fun_info) := sorry --non-trivial
lemma new_lemma_105673 (h0 : functor.add_const (topological_space (linear_ordered_field ennreal)) num) : @normal_space.{0} (linear_ordered_field.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_105674 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (dlist.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (dlist.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_105675 (h1 : filter (random_gen char)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_105676 (h0 : topological_space (ordered_cancel_add_comm_monoid num)) : loc_path_connected_space (ordered_cancel_add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_105677 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) name) : @normal_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_105678 (h0 : functor.add_const (topological_space (ordered_comm_monoid Type)) name) : @sequential_space.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_105679 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_105680 (h0 : ring (semi_normed_comm_ring (mul_one_class to_additive.value_type))) : strong_rank_condition (semi_normed_comm_ring (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_105681 (h0 : topological_space (canonically_ordered_add_monoid (option (option empty)))) : irreducible_space (canonically_ordered_add_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_105682 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_105683 (h0 : group (has_to_string (has_to_string (boolean_algebra pos)))) : is_simple_group (has_to_string (has_to_string (boolean_algebra pos))) := sorry --non-trivial
lemma new_lemma_105684 (h0 : group (has_add (has_pos_part pos))) : is_cyclic (has_add (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_105685 (h2 : measurable_space (uniform_space string.iterator_imp)) (h3 : filter (uniform_space string.iterator_imp)) : filter.is_measurably_generated h3 := sorry --non-trivial
lemma new_lemma_105686 (h0 : not (monoid (mul_zero_class empty) -> false)) : @monoid.fg.{0} (mul_zero_class.{0} empty) (@classical.by_contradiction'.{1} (monoid.{0} (mul_zero_class.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_105687 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (boolean_algebra.core.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (boolean_algebra.core.{0} empty))  := sorry --non-trivial
lemma new_lemma_105688 (h0 h1 : multiset (linear_ordered_comm_group_with_zero to_additive.value_type)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_105689 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (linear_ordered_add_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_add_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_105690 (h0 : linarith.comp_source -> linarith.comp_source -> Prop) : is_trans linarith.comp_source h0 := sorry --non-trivial
lemma new_lemma_105691 (h0 : topological_space (generalized_boolean_algebra (has_Inf pos))) : t1_space (generalized_boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_105692 (h0 : ring (has_bot (has_add (has_add pos)))) : is_principal_ideal_ring (has_bot (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_105693 (h0 : complete_lattice (add_comm_monoid congr_arg_kind)) : is_compactly_generated (add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_105694 (h0 : topological_space (with_bot (random_gen (random_gen (random_gen (random_gen linarith.ineq)))))) : locally_compact_space (with_bot (random_gen (random_gen (random_gen (random_gen linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_105695 (h0 : list (has_Sup (semiring (semiring (semiring unsigned))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_105696 (h0 : not (uniform_space (linear_ordered_comm_group_with_zero reducibility_hints) -> false)) : @complete_space.{0} (linear_ordered_comm_group_with_zero.{0} reducibility_hints) (@classical.by_contradiction'.{1} (uniform_space.{0} (linear_ordered_comm_group_with_zero.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_105697 (h0 : functor.add_const (list (has_zero unsigned)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_105698 (h0 : topological_space enat) (h1 : has_sub enat) : has_continuous_sub enat := sorry --non-trivial
lemma new_lemma_105699 (h0 : monoid (has_top (random_gen fun_info))) : monoid.fg (has_top (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_105700 (h0 : ring (linear_ordered_add_comm_group (has_norm (random_gen (random_gen linarith.ineq))))) : is_domain (linear_ordered_add_comm_group (has_norm (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_105701 (h0 : filter (linear_ordered_comm_ring (semiring (semiring unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_105702 (h0 : topological_space (sub_neg_monoid (has_Inf (has_Inf name)))) : t1_space (sub_neg_monoid (has_Inf (has_Inf name))) := sorry --non-trivial
lemma new_lemma_105703 (h1 : filter (encodable string_imp)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_105704 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_105705 (h0 : Prop -> ereal) (h1 : matrix (sum char char) (sum string char) (coe_sort (set.range h0))) (h2 : char) (h3 : string) : set.range_splitting h0 (matrix.to_blocks₂₁ h1 h2 h3) := sorry --non-trivial
lemma new_lemma_105706 (h0 : function.extfun Type (functor.comp topological_space cancel_monoid)) : @regular_space.{0} (cancel_monoid.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} cancel_monoid.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_105707 (h0 : functor.add_const (ring (normed_comm_ring name)) linarith.comp) : @rank_condition.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_105708 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_105709 (h0 : complete_lattice (comm_group environment.implicit_infer_kind)) : is_compactly_generated (comm_group environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_105710 (h0 : filter (has_nndist (finset pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_105711 (h0 : complete_lattice (ring (has_neg (has_zero Type)))) : complete_lattice.is_Sup_finite_compact (ring (has_neg (has_zero Type))) := sorry --non-trivial
lemma new_lemma_105712 (h0 : not (topological_space (linear_ordered_semiring linarith.ineq) -> false)) : @discrete_topology.{0} (linear_ordered_semiring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_105713 (h0 : functor.add_const (ring (pseudo_emetric_space unsigned)) empty) : @is_principal_ideal_ring.{0} (pseudo_emetric_space.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (pseudo_emetric_space.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_105714 (h0 : complete_lattice (mul_zero_class (semiring empty))) : is_compactly_generated (mul_zero_class (semiring empty)) := sorry --non-trivial
lemma new_lemma_105715 (h0 : functor.add_const (topological_space (left_cancel_semigroup empty)) (option empty)) : @discrete_topology.{0} (left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_105716 (h0 : functor.add_const (uniform_space pos) (normed_comm_ring pos)) : @complete_space.{0} pos (@functor.add_const.run.{0 0} (uniform_space.{0} pos) (normed_comm_ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_105717 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (add_semigroup.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (add_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_105718 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (free_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (free_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_105719 (h0 : functor.add_const (list (has_to_string name)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_105720 (h0 : functor.add_const (topological_space (has_pos_part Type)) pos) : @topological_space.separable_space.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_pos_part.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_105721 (h0 : topological_space (has_Inf (has_Inf real))) : normal_space (has_Inf (has_Inf real)) := sorry --non-trivial
lemma new_lemma_105722 (h0 : ring (semi_normed_comm_ring (mul_one_class reducibility_hints))) : is_domain (semi_normed_comm_ring (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_105723 (h0 : function.extfun Type ring) : @is_domain.{0} (monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_105724 (h0 : topological_space (ordered_comm_monoid pos)) : t1_space (ordered_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_105725 (h0 : functor.add_const (uniform_space (semigroup linarith.comp)) Type) : @separated_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (semigroup.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_105726 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_inter.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_inter.{0} empty))  := sorry --non-trivial
lemma new_lemma_105727 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_105728 (h0 : set (has_lt char)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_105729 (h0 : functor.add_const (filter (finset ennreal)) ennreal) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_105730 (h0 : uniform_space (with_bot (has_norm linarith.comp))) : complete_space (with_bot (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_105731 (h0 : add_group (canonically_ordered_add_monoid (option empty))) : is_add_cyclic (canonically_ordered_add_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_105732 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (canonically_ordered_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (canonically_ordered_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_105733 (h0 : has_mem.mem (id num) has_emptyc.emptyc) : @locally_compact_space.{0} (@id.{2} Type num) (@finset.pi.empty.{1 0} Type topological_space.{0} (@id.{2} Type num) h0)  := sorry --non-trivial
lemma new_lemma_105734 (h0 : topological_space (ring (has_Inf (has_Inf linarith.comp)))) : totally_disconnected_space (ring (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_105735 (h0 : functor.add_const (topological_space (has_pos_part Type)) Type) : @t0_space.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_pos_part.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_105736 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} unsigned (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) unsigned)  := sorry --non-trivial
lemma new_lemma_105737 (h0 : functor.add_const (list (add_cancel_monoid ennreal)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_105738 (h0 : functor.add_const (ordered_add_comm_monoid (add_cancel_monoid Type)) (has_neg pos)) : @archimedean.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (add_cancel_monoid.{1} Type)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_105739 (h1 : topological_space (encodable (has_nnnorm string_imp))) : path_connected_space (encodable (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_105740 (h0 : fin has_zero.zero) : @monoid.fg.{0} (add_comm_monoid.{0} real) (@matrix.vec_empty.{0} (monoid.{0} (add_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_105741 (h0 : ring (canonically_ordered_comm_semiring linarith.comp)) : rank_condition (canonically_ordered_comm_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_105742 (h0 : topological_space (normed_comm_ring (has_neg linarith.comp))) : topological_space.separable_space (normed_comm_ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_105743 (h0 : functor.add_const (finset (semiring empty)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_105744 (h0 : group (id to_additive.value_type)) : is_cyclic (id to_additive.value_type) := sorry --non-trivial
lemma new_lemma_105745 (h0 : topological_space (option empty)) : topological_space.separable_space (option empty) := sorry --non-trivial
lemma new_lemma_105746 (h0 : ring (has_bot (ordered_comm_monoid (boolean_algebra pos)))) : is_principal_ideal_ring (has_bot (ordered_comm_monoid (boolean_algebra pos))) := sorry --non-trivial
lemma new_lemma_105747 (h0 : functor.add_const (topological_space (has_zero Type)) Type) : @totally_separated_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_zero.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_105748 (h0 : functor.comp topological_space has_to_string name) : @t0_space.{0} (has_to_string.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} name h0)  := sorry --non-trivial
lemma new_lemma_105749 (h0 : functor.add_const (group (has_neg_part Type)) name) : @is_cyclic.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_neg_part.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_105750 (h0 : topological_space (ordered_cancel_add_comm_monoid (has_neg unsigned))) : totally_disconnected_space (ordered_cancel_add_comm_monoid (has_neg unsigned)) := sorry --non-trivial
lemma new_lemma_105751 (h0 : functor.add_const (complete_lattice (boolean_algebra.core pos)) environment.implicit_infer_kind) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_105752 (h0 : function.extfun Type group) : @normalizer_condition.{0} (non_assoc_semiring.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (non_assoc_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_105753 (h0 : ring (has_nndist (has_to_string name))) : is_principal_ideal_ring (has_nndist (has_to_string name)) := sorry --non-trivial
lemma new_lemma_105754 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_105755 (h0 : ring (generalized_boolean_algebra (finset (has_pos_part (has_pos_part pos))))) : strong_rank_condition (generalized_boolean_algebra (finset (has_pos_part (has_pos_part pos)))) := sorry --non-trivial
lemma new_lemma_105756 (h0 : ordered_add_comm_monoid (has_bot (has_add (has_add real)))) : archimedean (has_bot (has_add (has_add real))) := sorry --non-trivial
lemma new_lemma_105757 (h0 : topological_space (has_append reducibility_hints)) : t0_space (has_append reducibility_hints) := sorry --non-trivial
lemma new_lemma_105758 (h0 : functor.add_const (topological_space (cancel_monoid pos)) linarith.comp) : @totally_separated_space.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_105759 (h0 : topological_space (random_gen (semiring linarith.comp))) : locally_compact_space (random_gen (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_105760 (h0 : not (topological_space (with_zero char) -> false)) (h1 : has_add (with_zero char)) : @has_continuous_add.{0} (with_zero.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (with_zero.{0} char)) h0) h1  := sorry --non-trivial
lemma new_lemma_105761 (h0 : topological_space (with_one (with_bot to_additive.value_type))) : path_connected_space (with_one (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_105762 (h0 : not (uniform_space (random_gen to_additive.value_type) -> false)) : @separated_space.{0} (random_gen.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (uniform_space.{0} (random_gen.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_105763 (h0 : has_mem.mem (has_norm linarith.comp_source) has_emptyc.emptyc) : @totally_separated_space.{0} (has_norm.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_105764 (h0 : ordered_add_comm_monoid (canonically_linear_ordered_monoid (has_neg (has_neg name)))) : archimedean (canonically_linear_ordered_monoid (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_105765 (h0 : prod (has_inter (option (option empty))) (has_inter (option (option empty)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_105766 (h0 : ring (has_to_string (ring (has_Inf pos)))) : strong_rank_condition (has_to_string (ring (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_105767 (h0 : functor.add_const (group (boolean_algebra pos)) (has_zero linarith.comp)) : @group.fg.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} pos)) (has_zero.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_105768 (h0 : topological_space (has_Inf (has_zero Type))) : locally_compact_space (has_Inf (has_zero Type)) := sorry --non-trivial
lemma new_lemma_105769 (h0 : measurable_space (option (option (option ennreal)))) (h1 : has_add (option (option (option ennreal)))) (h2 : measure_theory.measure (option (option (option ennreal)))) : measure_theory.measure.is_add_left_invariant h2 := sorry --non-trivial
lemma new_lemma_105770 (h0 : topological_space (has_one (semiring (semiring unsigned)))) : totally_disconnected_space (has_one (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_105771 (h0 : topological_space (generalized_boolean_algebra (semigroup Type))) : locally_compact_space (generalized_boolean_algebra (semigroup Type)) := sorry --non-trivial
lemma new_lemma_105772 (h0 : ring (has_nndist (finset (has_to_string (has_to_string name))))) : strong_rank_condition (has_nndist (finset (has_to_string (has_to_string name)))) := sorry --non-trivial
lemma new_lemma_105773 (h0 : add_group (random_gen (has_inv string_imp))) : is_add_cyclic (random_gen (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_105774 (h0 : function.extfun (topological_space (semigroup ennreal)) (fun (x : topological_space (semigroup ennreal)), Prop)) (h1 : Exists (fun (x : topological_space (semigroup ennreal)), function.extfun_app h0 x)) : @irreducible_space.{0} (semigroup.{0} ennreal) (@classical.some.{1} (topological_space.{0} (semigroup.{0} ennreal)) (@function.extfun_app.{1 1} (topological_space.{0} (semigroup.{0} ennreal)) (λ (x : topological_space.{0} (semigroup.{0} ennreal)), Prop) h0) h1)  := sorry --non-trivial
lemma new_lemma_105775 (h1 : topological_space (topological_space char)) (h2 : preorder (topological_space char)) : order_topology (topological_space char) := sorry --non-trivial
lemma new_lemma_105776 (h0 : uniform_space (has_bot (has_neg (has_neg (has_neg (has_neg (has_neg Type))))))) : complete_space (has_bot (has_neg (has_neg (has_neg (has_neg (has_neg Type)))))) := sorry --non-trivial
lemma new_lemma_105777 (h0 : not (topological_space (topological_space linarith.ineq) -> false)) : @locally_compact_space.{0} (topological_space.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (topological_space.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_105778 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (add_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} h0 (add_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_105779 (h0 : topological_space (id (has_inv string_imp))) : path_connected_space (id (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_105780 (h0 : topological_space (comm_group (add_cancel_monoid name))) : totally_disconnected_space (comm_group (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_105781 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_105782 (h0 : not (filter (linear_ordered_semiring empty) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_105783 (h0 : ring (with_bot (random_gen (comm_ring linarith.ineq)))) : is_domain (with_bot (random_gen (comm_ring linarith.ineq))) := sorry --non-trivial
lemma new_lemma_105784 (h1 : ring (random_gen linarith.ineq)) : strong_rank_condition (random_gen linarith.ineq) := sorry --non-trivial
lemma new_lemma_105785 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (cancel_comm_monoid_with_zero.{1} (normed_lattice_add_comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_105786 (h0 : functor.add_const (complete_lattice (boolean_algebra unsigned)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_105787 (h0 : group (group_with_zero (option ennreal))) : normalizer_condition (group_with_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_105788 (h0 : topological_space (cancel_monoid (has_add Type))) : path_connected_space (cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_105789 (h0 : functor.add_const (topological_space (has_star num)) (semiring empty)) : @topological_space.separable_space.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} num)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_105790 (h0 : ring (plift congr_arg_kind)) : rank_condition (plift congr_arg_kind) := sorry --non-trivial
lemma new_lemma_105791 (h0 : functor.add_const (ring (normed_linear_ordered_group empty)) unsigned) : @is_domain.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (normed_linear_ordered_group.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_105792 (h0 : semiring (add_comm_semigroup enat)) (h2 : ideal (add_comm_semigroup enat)) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_105793 (h0 : list (finset (finset (finset (finset (finset name)))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_105794 (h0 : topological_space (comm_ring (has_ssubset to_additive.value_type))) : path_connected_space (comm_ring (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_105795 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_add.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_105796 (h0 : functor.add_const (topological_space (ring unsigned)) pos) : @preirreducible_space.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_105797 (h0 : topological_space (boolean_algebra.core (has_neg name))) : topological_space.separable_space (boolean_algebra.core (has_neg name)) := sorry --non-trivial
lemma new_lemma_105798 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (complete_linear_order.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_105799 (h0 : functor.add_const (topological_space (semigroup name)) linarith.comp) : @sequential_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_105800 (h0 : group (linear_ordered_add_comm_group (denumerable linarith.ineq))) : is_cyclic (linear_ordered_add_comm_group (denumerable linarith.ineq)) := sorry --non-trivial
lemma new_lemma_105801 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_105802 (h2 : group (has_ssubset to_additive.value_type)) : is_cyclic (has_ssubset to_additive.value_type) := sorry --non-trivial
lemma new_lemma_105803 (h0 : complete_lattice (has_add congr_arg_kind)) : is_atomistic (has_add congr_arg_kind) := sorry --non-trivial
lemma new_lemma_105804 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_105805 (h0 : monoid (plift (linear_ordered_cancel_comm_monoid unsigned))) : monoid.fg (plift (linear_ordered_cancel_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_105806 (h0 : functor.add_const (uniform_space (has_Inf Type)) pos) : @separated_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_Inf.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_105807 (h0 : group (add_cancel_monoid environment.implicit_infer_kind)) : is_simple_group (add_cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_105808 (h0 : finset (has_Inf (ring (has_add (has_Inf linarith.comp))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_105809 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_105810 (h0 : topological_space (canonically_linear_ordered_monoid (has_add linarith.comp))) : locally_compact_space (canonically_linear_ordered_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_105811 (h0 : ring (dlist (has_nnnorm (has_ssubset fun_info)))) : is_domain (dlist (has_nnnorm (has_ssubset fun_info))) := sorry --non-trivial
lemma new_lemma_105812 (h0 : not (complete_lattice (complete_semilattice_Sup congr_arg_kind) -> false)) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (complete_semilattice_Sup.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_105813 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_105814 (h0 : ring (has_nndist (option (option (option (ring (option (ring pos)))))))) : strong_rank_condition (has_nndist (option (option (option (ring (option (ring pos))))))) := sorry --non-trivial
lemma new_lemma_105815 (h0 : function.extfun Type (functor.comp topological_space has_neg_part)) : @locally_compact_space.{0} (has_neg_part.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_neg_part.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_105816 (h0 : functor.add_const (ring (add_cancel_monoid name)) (finset (finset linarith.comp))) : @is_domain.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} name)) (finset.{0} (finset.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_105817 (h0 : functor.add_const (ring (semigroup environment.implicit_infer_kind)) name) : @rank_condition.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_105818 (h0 : functor.add_const (group (has_neg pos)) pos) : @normalizer_condition.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_105819 (h0 : set (set (has_top linarith.comp_source))) : is_countably_spanning h0 := sorry --non-trivial
lemma new_lemma_105820 (h0 : uniform_space (has_lt (mul_one_class string.iterator_imp))) : complete_space (has_lt (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_105821 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_105822 (h0 : topological_space (comm_semigroup (has_add linarith.comp))) : preirreducible_space (comm_semigroup (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_105823 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (measure_theory.measure_space.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (measure_theory.measure_space.{0} num))  := sorry --non-trivial
lemma new_lemma_105824 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @preirreducible_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_105825 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (metric_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_105826 (h0 : topological_space (comm_group name)) : locally_compact_space (comm_group name) := sorry --non-trivial
lemma new_lemma_105827 (h2 : topological_space fun_info) : t0_space fun_info := sorry --non-trivial
lemma new_lemma_105828 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @t1_space.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_pos_part.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_105829 (h0 : add_monoid (comm_group (has_to_string (has_to_string pos)))) : add_monoid.fg (comm_group (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_105830 (h0 : complete_lattice (normed_field (mul_one_class reducibility_hints))) : complete_lattice.is_Sup_finite_compact (normed_field (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_105831 (h0 : topological_space (mul_zero_class (option unsigned))) : t0_space (mul_zero_class (option unsigned)) := sorry --non-trivial
lemma new_lemma_105832 (h0 : has_mem.mem group has_emptyc.emptyc) : @normalizer_condition.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_105833 (h0 : complete_lattice (has_neg (has_to_string (has_neg_part unsigned)))) : is_compactly_generated (has_neg (has_to_string (has_neg_part unsigned))) := sorry --non-trivial
lemma new_lemma_105834 (h0 : filter (ordered_comm_monoid (has_neg name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_105835 (h0 : topological_space (has_top (has_union num))) : preirreducible_space (has_top (has_union num)) := sorry --non-trivial
lemma new_lemma_105836 (h0 : functor.add_const (group (free_add_monoid empty)) empty) : @is_cyclic.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (free_add_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_105837 (h0 : topological_space (semigroup environment.implicit_infer_kind)) : totally_separated_space (semigroup environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_105838 (h0 : fin has_zero.zero) : @monoid.fg.{0} (ordered_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (monoid.{0} (ordered_comm_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_105839 (h0 : has_to_string (pseudo_metric_space ennreal) -> has_to_string (pseudo_metric_space ennreal) -> Prop) : is_symm (has_to_string (pseudo_metric_space ennreal)) h0 := sorry --non-trivial
lemma new_lemma_105840 (h2 : topological_space (normed_field char)) : path_connected_space (normed_field char) := sorry --non-trivial
lemma new_lemma_105841 (h0 : complete_lattice (semiring (random_gen (has_top fun_info)))) : is_compactly_generated (semiring (random_gen (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_105842 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_105843 (h0 : functor.add_const (filter (boolean_algebra name)) (has_to_string (ring (ring pos)))) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_105844 (h0 : topological_space (ordered_ring num)) : locally_compact_space (ordered_ring num) := sorry --non-trivial
lemma new_lemma_105845 (h0 : ring (semigroup (option pos))) : strong_rank_condition (semigroup (option pos)) := sorry --non-trivial
lemma new_lemma_105846 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (ordered_comm_ring real)) := sorry --non-trivial
lemma new_lemma_105847 (h0 : has_lt (add_comm_semigroup linarith.ineq)) : no_max_order (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_105848 (h0 : ordered_add_comm_monoid (has_inner unsigned (option (option unsigned)))) : archimedean (has_inner unsigned (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_105849 (h0 : finset (normed_lattice_add_comm_group (has_Inf real))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_105850 (h0 : topological_space (has_one unsigned)) : totally_disconnected_space (has_one unsigned) := sorry --non-trivial
lemma new_lemma_105851 (h0 : topological_space (ring (has_neg name))) : locally_compact_space (ring (has_neg name)) := sorry --non-trivial
lemma new_lemma_105852 (h0 : topological_space (semigroup (ring Type))) : t0_space (semigroup (ring Type)) := sorry --non-trivial
lemma new_lemma_105853 (h1 : complete_lattice (with_one linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (with_one linarith.comp_source) := sorry --non-trivial
lemma new_lemma_105854 (h0 : functor.add_const (topological_space (has_add ennreal)) num) : @locally_compact_space.{0} (has_add.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_105855 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_inv.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_inv.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_105856 (h0 : list (dlist (has_ssubset (random_gen (has_nnnorm (has_ssubset (random_gen linarith.comp_source))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_105857 (h0 : functor.add_const (add_group (linear_order unsigned)) (semiring empty)) : @is_add_cyclic.{0} (linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (linear_order.{0} unsigned)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_105858 (h2 : add_group (has_div string_imp)) : is_add_cyclic (has_div string_imp) := sorry --non-trivial
lemma new_lemma_105859 (h0 : topological_space (has_Sup (has_bot congr_arg_kind))) : discrete_topology (has_Sup (has_bot congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_105860 (h0 : ring (plift (semiring (semiring unsigned)))) : strong_rank_condition (plift (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_105861 (h0 : functor.comp complete_lattice mul_zero_class name) : @is_atomistic.{0} (mul_zero_class.{0} name) (@functor.comp.run.{0 0 0} complete_lattice.{0} mul_zero_class.{0} name h0)  := sorry --non-trivial
lemma new_lemma_105862 (h0 : topological_space (generalized_boolean_algebra (has_neg pos))) : sequential_space (generalized_boolean_algebra (has_neg pos)) := sorry --non-trivial
lemma new_lemma_105863 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (linear_ordered_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_105864 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_105865 (h0 : uniform_space (has_le (mul_one_class linarith.ineq))) : complete_space (has_le (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_105866 (h0 : not (has_mem.mem (complete_semilattice_Sup num) has_emptyc.emptyc -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (complete_semilattice_Sup.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (complete_semilattice_Sup.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_105867 (h0 : functor.add_const (complete_lattice (has_neg linarith.comp)) (has_add (has_add linarith.comp))) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg.{0} linarith.comp)) (has_add.{0} (has_add.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_105868 (h0 : topological_space (add_cancel_monoid congr_arg_kind)) : loc_path_connected_space (add_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_105869 (h0 : has_mem.mem (has_top (has_norm congr_arg_kind)) has_emptyc.emptyc) : @preirreducible_space.{0} (has_top.{0} (has_norm.{0} congr_arg_kind)) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} (has_norm.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_105870 (h0 : list (ordered_comm_monoid (finset Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_105871 (h0 : ring (has_add (has_nndist pos))) : is_principal_ideal_ring (has_add (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_105872 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_add name)) (has_neg (ring (ring (has_nndist Type))))) : @unique_factorization_monoid.{0} (has_add.{0} name) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (has_add.{0} name)) (has_neg.{1} (ring.{1} (ring.{1} (has_nndist.{1} Type)))) h0)  := sorry --non-trivial
lemma new_lemma_105873 (h0 : topological_space (denumerable (random_gen linarith.comp_source))) : totally_disconnected_space (denumerable (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_105874 (h0 : ring (dlist (random_gen (random_gen to_additive.value_type)))) : rank_condition (dlist (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_105875 (h0 : prod (add_comm_monoid ennreal) (add_comm_monoid ennreal)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_105876 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_105877 (h1 : function.extfun Type topological_space) : @t0_space.{0} char (@function.extfun_app.{2 1} Type topological_space.{0} h1 char)  := sorry --non-trivial
lemma new_lemma_105878 (h1 : add_group (add_monoid (random_gen (random_gen (random_gen char))))) : is_add_cyclic (add_monoid (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_105879 (h0 : function.extfun Type group) : @group.fg.{0} (has_sub.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_sub.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_105880 (h2 : uniform_space (add_comm_semigroup char)) : complete_space (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_105881 (h0 : not (filter (has_ssubset linarith.ineq) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_105882 (h0 : functor.add_const (topological_space (semigroup name)) unsigned) : @regular_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_105883 (h0 : topological_space (has_top (complete_semilattice_Sup string_imp))) : locally_compact_space (has_top (complete_semilattice_Sup string_imp)) := sorry --non-trivial
lemma new_lemma_105884 (h0 : functor.add_const (filter (normed_comm_ring name)) (option unsigned)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_105885 (h0 : ring (dlist char)) : rank_condition (dlist char) := sorry --non-trivial
lemma new_lemma_105886 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @normal_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_105887 (h0 : cancel_comm_monoid_with_zero (pseudo_metric_space (finset (finset environment.implicit_infer_kind)))) : unique_factorization_monoid (pseudo_metric_space (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_105888 (h0 : list (option pos)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_105889 (h0 : functor.comp topological_space has_to_string Type) : @loc_path_connected_space.{1} (has_to_string.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_to_string.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_105890 (h0 : function.extfun nat fin) : @is_compactly_generated.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type complete_lattice.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_105891 (h0 : ordered_comm_monoid (ordered_cancel_add_comm_monoid (option ennreal))) : has_exists_mul_of_le (ordered_cancel_add_comm_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_105892 (h0 : group (topological_space (random_gen string_imp))) : is_cyclic (topological_space (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_105893 (h0 : functor.add_const (function.extfun Type finset) (boolean_algebra Type)) : finset.nonempty (function.extfun_app (functor.add_const.run h0) pos) := sorry --non-trivial
lemma new_lemma_105894 (h0 : functor.add_const (topological_space (semiring congr_arg_kind)) unsigned) : @locally_compact_space.{0} (semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_105895 (h0 : topological_space (boolean_algebra (finset pos))) : sequential_space (boolean_algebra (finset pos)) := sorry --non-trivial
lemma new_lemma_105896 (h0 : cancel_comm_monoid_with_zero (pseudo_metric_space ennreal)) : unique_factorization_monoid (pseudo_metric_space ennreal) := sorry --non-trivial
lemma new_lemma_105897 (h0 : complete_lattice (has_norm (random_gen linarith.comp_source))) : is_atomistic (has_norm (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_105898 (h0 : topological_space (complete_distrib_lattice unsigned)) : irreducible_space (complete_distrib_lattice unsigned) := sorry --non-trivial
lemma new_lemma_105899 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (canonically_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} h0 (canonically_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_105900 (h0 : functor.add_const (topological_space (has_zero pos)) (finset pos)) : @t1_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_105901 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_105902 (h0 : functor.add_const (topological_space (cancel_monoid name)) name) : @sequential_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_105903 (h0 : ordered_comm_monoid (ordered_comm_monoid (has_neg name))) : has_exists_mul_of_le (ordered_comm_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_105904 (h0 : function.extfun Type group) : @is_cyclic.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_105905 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_105906 (h2 : topological_space string_imp) : path_connected_space string_imp := sorry --non-trivial
lemma new_lemma_105907 (h0 : functor.add_const (ordered_comm_monoid (add_comm_monoid environment.implicit_infer_kind)) name) : @has_exists_mul_of_le.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_105908 (h0 : topological_space (has_zero (has_add name))) : path_connected_space (has_zero (has_add name)) := sorry --non-trivial
lemma new_lemma_105909 (h0 : functor.add_const (functor.add_const (ring environment.implicit_infer_kind) linarith.comp) pos) : @is_domain.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (ring.{0} environment.implicit_infer_kind) linarith.comp (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ring.{0} environment.implicit_infer_kind) linarith.comp) pos h0))  := sorry --non-trivial
lemma new_lemma_105910 (h0 : ordered_comm_monoid (simple_graph name)) : has_exists_mul_of_le (simple_graph name) := sorry --non-trivial
lemma new_lemma_105911 (h0 : topological_space (complete_semilattice_Sup (semiring (semiring unsigned)))) : t0_space (complete_semilattice_Sup (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_105912 (h0 : list (canonically_ordered_comm_semiring (option (option (option empty))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_105913 (h0 : option (add_group (id (random_gen linarith.ineq)))) (h1 : add_group (id (random_gen linarith.ineq))) : is_add_cyclic (id (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_105914 (h0 : topological_space (has_star (semiring empty))) : discrete_topology (has_star (semiring empty)) := sorry --non-trivial
lemma new_lemma_105915 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @topological_space.separable_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_105916 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_105917 (h0 : group (comm_monoid congr_arg_kind)) : normalizer_condition (comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_105918 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (complete_linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (complete_linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_105919 (h0 : function.extfun Type (functor.add_const (ordered_add_comm_monoid (free_add_monoid empty)))) : @archimedean.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (free_add_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ordered_add_comm_monoid.{0} (free_add_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_105920 (h0 : uniform_space (has_zero (add_comm_monoid name))) : complete_space (has_zero (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_105921 (h0 : not (topological_space (with_one empty) -> false)) : @totally_separated_space.{0} (with_one.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_105922 (h0 : functor.add_const (topological_space (comm_group Type)) environment.implicit_infer_kind) : @totally_disconnected_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_105923 (h0 : uniform_space (finset (option (option (option pos))))) : complete_space (finset (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_105924 (h0 : ordered_comm_monoid (ring (comm_group name))) : has_exists_mul_of_le (ring (comm_group name)) := sorry --non-trivial
lemma new_lemma_105925 (h0 : topological_space (has_zero (boolean_algebra (has_neg name)))) : path_connected_space (has_zero (boolean_algebra (has_neg name))) := sorry --non-trivial
lemma new_lemma_105926 (h0 : topological_space (boolean_algebra znum)) : preconnected_space (boolean_algebra znum) := sorry --non-trivial
lemma new_lemma_105927 (h0 : add_group (denumerable char)) : add_group.fg (denumerable char) := sorry --non-trivial
lemma new_lemma_105928 (h1 : complete_lattice (has_div linarith.ineq)) : is_compactly_generated (has_div linarith.ineq) := sorry --non-trivial
lemma new_lemma_105929 (h0 : topological_space (has_inv (has_ssubset fun_info))) : totally_disconnected_space (has_inv (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_105930 (h0 : set (semi_normed_ring string.iterator_imp)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_105931 (h0 : prod (canonically_ordered_comm_semiring name) (canonically_ordered_comm_semiring name)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_105932 (h0 : group (ordered_comm_group (option (option empty)))) : group.fg (ordered_comm_group (option (option empty))) := sorry --non-trivial
lemma new_lemma_105933 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @group.fg.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) group.{0}) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_105934 (h0 : complete_lattice (distrib (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) : is_compactly_generated (distrib (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_105935 (h0 : topological_space (has_add (has_pos_part (has_Inf real)))) : path_connected_space (has_add (has_pos_part (has_Inf real))) := sorry --non-trivial
lemma new_lemma_105936 (h0 : functor.add_const (add_group (has_nndist pos)) Type) : @is_add_cyclic.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (add_group.{0} (has_nndist.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_105937 (h0 : functor.add_const (topological_space (boolean_algebra.core environment.implicit_infer_kind)) pos) : @loc_path_connected_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_105938 (h0 : add_monoid (measurable_space.dynkin_system empty)) : add_monoid.fg (measurable_space.dynkin_system empty) := sorry --non-trivial
lemma new_lemma_105939 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (linear_ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (linear_ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_105940 (h0 : complete_lattice (has_bot (sub_neg_monoid name))) : is_atomistic (has_bot (sub_neg_monoid name)) := sorry --non-trivial
lemma new_lemma_105941 (h0 : group (measurable_space (semiring linarith.comp))) : normalizer_condition (measurable_space (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_105942 (h0 : topological_space (complete_distrib_lattice (has_add Type))) : path_connected_space (complete_distrib_lattice (has_add Type)) := sorry --non-trivial
lemma new_lemma_105943 (h0 : functor.add_const (topological_space ennreal) num) : discrete_topology ennreal := sorry --non-trivial
lemma new_lemma_105944 (h0 : functor.add_const (topological_space (is_R_or_C unsigned)) empty) : @totally_disconnected_space.{0} (is_R_or_C.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (is_R_or_C.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_105945 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_105946 (h0 : topological_space (canonically_linear_ordered_monoid (has_neg_part ennreal))) : sequential_space (canonically_linear_ordered_monoid (has_neg_part ennreal)) := sorry --non-trivial
lemma new_lemma_105947 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_105948 (h0 : topological_space (ring (mul_one_class linarith.comp))) : normal_space (ring (mul_one_class linarith.comp)) := sorry --non-trivial
lemma new_lemma_105949 (h0 : functor.add_const (topological_space (normed_comm_ring (has_neg linarith.comp))) name) : @locally_compact_space.{0} (normed_comm_ring.{0} (has_neg.{0} linarith.comp)) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} (has_neg.{0} linarith.comp))) name h0)  := sorry --non-trivial
lemma new_lemma_105950 (h0 : functor.comp topological_space has_neg ennreal) : @discrete_topology.{0} (has_neg.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_105951 (h0 : cancel_comm_monoid_with_zero (linear_ordered_semiring num)) : unique_factorization_monoid (linear_ordered_semiring num) := sorry --non-trivial
lemma new_lemma_105952 (h0 : not (topological_space (add_group empty) -> false)) : @totally_separated_space.{0} (add_group.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (add_group.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_105953 (h1 : add_comm_semigroup fun_info -> add_comm_semigroup fun_info -> Prop) (h2 : filter (add_comm_semigroup fun_info)) : filter.is_bounded h1 h2 := sorry --non-trivial
lemma new_lemma_105954 (h0 : topological_space (has_nndist (finset (finset (finset (finset pos)))))) : totally_disconnected_space (has_nndist (finset (finset (finset (finset pos))))) := sorry --non-trivial
lemma new_lemma_105955 (h0 : topological_space (has_union unsigned)) : normal_space (has_union unsigned) := sorry --non-trivial
lemma new_lemma_105956 (h0 : linear_ordered_field (has_zero pos) -> linear_ordered_field (has_zero pos) -> Prop) : is_symm (linear_ordered_field (has_zero pos)) h0 := sorry --non-trivial
lemma new_lemma_105957 (h0 : ordered_add_comm_monoid real) : archimedean real := sorry --non-trivial
lemma new_lemma_105958 (h0 : functor.add_const (group (has_star empty)) empty) : @group.fg.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (has_star.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_105959 (h0 : functor.add_const (ring (has_dist empty)) (option num)) : @is_principal_ideal_ring.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (has_dist.{0} empty)) (option.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_105960 (h0 : functor.add_const (topological_space (sub_neg_monoid pos)) linarith.comp) : @discrete_topology.{0} (sub_neg_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (sub_neg_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_105961 (h0 : ring (mul_zero_class Type)) : is_domain (mul_zero_class Type) := sorry --non-trivial
lemma new_lemma_105962 (h0 : topological_space (ordered_comm_ring (finset Type))) : loc_path_connected_space (ordered_comm_ring (finset Type)) := sorry --non-trivial
lemma new_lemma_105963 (h0 : functor.add_const (topological_space Type) linarith.comp) : @t0_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_105964 (h0 : topological_space (random_gen to_additive.value_type)) : irreducible_space (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_105965 (h0 : cancel_comm_monoid_with_zero (normed_lattice_add_comm_group (has_add (has_add pos)))) : unique_factorization_monoid (normed_lattice_add_comm_group (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_105966 (h0 : add_monoid (has_to_string (has_to_string unsigned))) : add_monoid.fg (has_to_string (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_105967 (h2 : set (fun_info -> char)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_105968 (h0 : topological_space (ring (has_add (finset (has_nndist pos))))) : t0_space (ring (has_add (finset (has_nndist pos)))) := sorry --non-trivial
lemma new_lemma_105969 (h0 : group (has_emptyc (has_inv fun_info))) : is_cyclic (has_emptyc (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_105970 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_neg_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_105971 (h0 : topological_space (semigroup name)) : sequential_space (semigroup name) := sorry --non-trivial
lemma new_lemma_105972 (h0 : topological_space (normed_group (semiring empty))) : irreducible_space (normed_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_105973 (h0 : functor.comp topological_space boolean_algebra environment.implicit_infer_kind) : @loc_path_connected_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_105974 (h0 : functor.add_const (topological_space (has_to_string name)) linarith.comp) : @totally_disconnected_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_105975 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_zero name)) := sorry --non-trivial
lemma new_lemma_105976 (h0 : ring (boolean_algebra (comm_group Type))) : is_principal_ideal_ring (boolean_algebra (comm_group Type)) := sorry --non-trivial
lemma new_lemma_105977 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_105978 (h0 : uniform_space (finset (normed_comm_ring (finset environment.implicit_infer_kind)))) : complete_space (finset (normed_comm_ring (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_105979 (h0 : cancel_comm_monoid_with_zero (normed_linear_ordered_group empty)) : unique_factorization_monoid (normed_linear_ordered_group empty) := sorry --non-trivial
lemma new_lemma_105980 (h0 : functor.add_const (topological_space (ordered_ring congr_arg_kind)) (semiring congr_arg_kind)) : @irreducible_space.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} congr_arg_kind)) (semiring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_105981 (h0 : topological_space (ring (ring (ring (ring Type))))) : loc_path_connected_space (ring (ring (ring (ring Type)))) := sorry --non-trivial
lemma new_lemma_105982 (h0 : functor.comp topological_space complete_distrib_lattice Type) : @locally_compact_space.{1} (complete_distrib_lattice.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} complete_distrib_lattice.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_105983 (h0 : topological_space (with_one (has_nnnorm fun_info))) : path_connected_space (with_one (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_105984 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_105985 (h0 : finset (has_add (option (option unsigned)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_105986 (h0 : function.extfun Type (functor.comp filter has_nndist)) : filter.ne_bot (functor.comp.run (function.extfun_app h0 ennreal)) := sorry --non-trivial
lemma new_lemma_105987 (h0 : has_inv fun_info -> Prop) : Exists h0 := sorry --non-trivial
lemma new_lemma_105988 (h0 : topological_space (has_emptyc (has_norm linarith.comp))) : locally_compact_space (has_emptyc (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_105989 (h0 : uniform_space (distrib_lattice (random_gen string_imp))) : complete_space (distrib_lattice (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_105990 (h1 : topological_space (topological_space (has_ssubset char))) : path_connected_space (topological_space (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_105991 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (finset empty)) := sorry --non-trivial
lemma new_lemma_105992 (h0 : ring (mul_one_class string_imp)) : strong_rank_condition (mul_one_class string_imp) := sorry --non-trivial
lemma new_lemma_105993 (h0 : functor.add_const (cancel_comm_monoid_with_zero (measurable_space.dynkin_system empty)) unsigned) : @unique_factorization_monoid.{0} (measurable_space.dynkin_system.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (measurable_space.dynkin_system.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_105994 (h0 : functor.comp topological_space canonically_ordered_comm_semiring ennreal) : @normal_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_105995 (h0 : topological_space (normed_group (has_norm (has_norm (has_inv fun_info))))) : path_connected_space (normed_group (has_norm (has_norm (has_inv fun_info)))) := sorry --non-trivial
lemma new_lemma_105996 (h0 : group (boolean_algebra (comm_group unsigned))) : is_simple_group (boolean_algebra (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_105997 (h0 : preorder (add_comm_semigroup fun_info)) (h1 : set (add_comm_semigroup fun_info)) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_105998 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_105999 (h0 : add_monoid (add_comm_monoid environment.implicit_infer_kind)) : add_monoid.fg (add_comm_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_106000 (h0 : functor.add_const (functor.add_const (ordered_add_comm_monoid Type) pos) linarith.comp) : @archimedean.{1} Type (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} Type) pos (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (ordered_add_comm_monoid.{1} Type) pos) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_106001 (h1 : ring (comm_ring string_imp)) : rank_condition (comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_106002 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_106003 (h0 : topological_space (pseudo_emetric_space (option (option unsigned)))) : irreducible_space (pseudo_emetric_space (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_106004 (h0 : function.extfun Type group) : @normalizer_condition.{0} (measurable_space.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (measurable_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_106005 (h0 : topological_space (has_to_string (finset (has_add name)))) : locally_compact_space (has_to_string (finset (has_add name))) := sorry --non-trivial
lemma new_lemma_106006 (h0 : ring (complete_distrib_lattice (finset (has_Inf linarith.comp)))) : strong_rank_condition (complete_distrib_lattice (finset (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_106007 (h0 : functor.add_const (topological_space (sub_neg_monoid environment.implicit_infer_kind)) Type) : @preirreducible_space.{0} (sub_neg_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (sub_neg_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_106008 (h0 : topological_space (finset (has_to_string environment.implicit_infer_kind))) : t1_space (finset (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_106009 (h0 : topological_space (ring (option (option ennreal)))) : t0_space (ring (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_106010 (h0 : function.extfun (Type -> Type) (function.extfun Type)) (h1 : function.extfun linarith.ineq (fun (x : linarith.ineq), Prop)) : @is_preirreducible.{0} linarith.ineq (@id.{1} (topological_space.{0} linarith.ineq) (@id.{1} (topological_space.{0} linarith.ineq) (@id.{1} (topological_space.{0} linarith.ineq) (@id.{1} (topological_space.{0} linarith.ineq) (@id.{1} (topological_space.{0} linarith.ineq) (@id.{1} (topological_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) linarith.ineq))))))) (@function.extfun_app.{1 1} linarith.ineq (λ (x : linarith.ineq), Prop) h1)  := sorry --non-trivial
lemma new_lemma_106011 (h0 : filter (monoid (option empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_106012 (h2 : ring (has_nnnorm ereal)) : is_domain (has_nnnorm ereal) := sorry --non-trivial
lemma new_lemma_106013 (h0 : functor.add_const (filter (semigroup Type)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_106014 (h0 : topological_space (complete_distrib_lattice enat)) : t0_space (complete_distrib_lattice enat) := sorry --non-trivial
lemma new_lemma_106015 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (normed_lattice_add_comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_106016 (h0 : topological_space (id empty)) : locally_compact_space (id empty) := sorry --non-trivial
lemma new_lemma_106017 (h0 : topological_space (has_union (semiring (semiring (linear_ordered_semiring unsigned))))) : preirreducible_space (has_union (semiring (semiring (linear_ordered_semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_106018 (h0 : topological_space (with_bot (has_inv (has_nnnorm (has_nnnorm (has_top fun_info)))))) : t0_space (with_bot (has_inv (has_nnnorm (has_nnnorm (has_top fun_info))))) := sorry --non-trivial
lemma new_lemma_106019 (h1 : ring (metric_space char)) : is_domain (metric_space char) := sorry --non-trivial
lemma new_lemma_106020 (h0 : topological_space (finset (finset (has_nndist name)))) : normal_space (finset (finset (has_nndist name))) := sorry --non-trivial
lemma new_lemma_106021 (h0 : finset (ordered_comm_ring (has_neg name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_106022 (h0 : topological_space (boolean_algebra (finset pos))) : t0_space (boolean_algebra (finset pos)) := sorry --non-trivial
lemma new_lemma_106023 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @topological_space.separable_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_106024 (h0 : functor.add_const (ordered_comm_monoid (has_Inf name)) name) : @has_exists_mul_of_le.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_Inf.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_106025 (h0 : add_group (semigroup environment.implicit_infer_kind)) : is_add_cyclic (semigroup environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_106026 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_106027 (h0 : topological_space (normed_group real)) : t0_space (normed_group real) := sorry --non-trivial
lemma new_lemma_106028 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_106029 (h0 : functor.add_const (topological_space (has_neg pos)) Type) : @totally_disconnected_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_106030 (h0 : topological_space (boolean_algebra (comm_group unsigned))) : totally_separated_space (boolean_algebra (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_106031 (h0 : ring (add_comm_monoid name)) : is_domain (add_comm_monoid name) := sorry --non-trivial
lemma new_lemma_106032 (h0 : functor.add_const (ring (has_add Type)) linarith.comp) : @is_domain.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_add.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_106033 (h0 : topological_space (has_edist (semiring (semiring (semiring num))))) : t0_space (has_edist (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_106034 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (add_comm_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_106035 (h0 : function.extfun Type (functor.comp filter has_zero)) : filter.ne_bot (functor.comp.run (function.extfun_app h0 pos)) := sorry --non-trivial
lemma new_lemma_106036 (h0 : complete_lattice (has_zero (has_to_string (has_to_string (has_neg_part Type))))) : is_compactly_generated (has_zero (has_to_string (has_to_string (has_neg_part Type)))) := sorry --non-trivial
lemma new_lemma_106037 (h0 : functor.comp add_group comm_group (has_add environment.implicit_infer_kind)) : @is_add_cyclic.{0} (comm_group.{0} (has_add.{0} environment.implicit_infer_kind)) (@functor.comp.run.{0 0 0} add_group.{0} comm_group.{0} (has_add.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_106038 (h1 : topological_space (semi_normed_ring (comm_ring char))) : t0_space (semi_normed_ring (comm_ring char)) := sorry --non-trivial
lemma new_lemma_106039 (h0 : group (normed_lattice_add_comm_group (ordered_comm_monoid real))) : normalizer_condition (normed_lattice_add_comm_group (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_106040 (h0 : functor.add_const (topological_space (plift empty)) num) : @path_connected_space.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_106041 (h0 : topological_space (topological_space (random_gen (random_gen (random_gen string_imp))))) : locally_compact_space (topological_space (random_gen (random_gen (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_106042 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_106043 (h3 : prod environment.projection_info environment.projection_info) : set.diagonal environment.projection_info h3 := sorry --non-trivial
lemma new_lemma_106044 (h0 : group (normed_group (has_top (has_top linarith.ineq)))) : normalizer_condition (normed_group (has_top (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_106045 (h0 : complete_lattice (complete_semilattice_Sup (has_ssubset to_additive.value_type))) : is_compactly_generated (complete_semilattice_Sup (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_106046 (h0 : functor.add_const (finset (linear_ordered_cancel_comm_monoid empty)) (semiring unsigned)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_106047 (h0 : topological_space (canonically_linear_ordered_monoid (option ennreal))) : loc_path_connected_space (canonically_linear_ordered_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_106048 (h0 : functor.add_const (ordered_comm_monoid (finset pos)) pos) : @has_exists_mul_of_le.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (finset.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_106049 (h0 : complete_lattice (non_assoc_semiring (option (option unsigned)))) : is_atomistic (non_assoc_semiring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_106050 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_106051 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type monoid.{0} h0 (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_106052 (h0 : fin has_zero.zero) : @topological_space.separable_space.{0} (has_nndist.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (has_nndist.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_106053 (h0 : finset (measurable_space.dynkin_system (semiring empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_106054 (h1 : ring string.iterator_imp) : is_domain string.iterator_imp := sorry --non-trivial
lemma new_lemma_106055 (h0 : ring (normed_field (has_nnnorm (random_gen reducibility_hints)))) : rank_condition (normed_field (has_nnnorm (random_gen reducibility_hints))) := sorry --non-trivial
lemma new_lemma_106056 (h0 : ring (left_cancel_semigroup unsigned)) : strong_rank_condition (left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_106057 (h0 : monoid (is_R_or_C empty)) (h1 : is_R_or_C empty) : squarefree h1 := sorry --non-trivial
lemma new_lemma_106058 (h0 : not (complete_lattice (random_gen fun_info) -> false)) : @is_atomistic.{0} (random_gen.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (random_gen.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_106059 (h0 : not (functor.comp monoid mul_zero_class unsigned -> false)) : @monoid.fg.{0} (mul_zero_class.{0} unsigned) (@functor.comp.run.{0 0 0} monoid.{0} mul_zero_class.{0} unsigned (@classical.by_contradiction'.{1} (functor.comp.{0 0 0} monoid.{0} mul_zero_class.{0} unsigned) h0))  := sorry --non-trivial
lemma new_lemma_106060 (h0 : functor.add_const (ring (finset Type)) pos) : @rank_condition.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (finset.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_106061 (h0 : group (random_gen (has_top num))) : normalizer_condition (random_gen (has_top num)) := sorry --non-trivial
lemma new_lemma_106062 (h0 : group (semiring to_additive.value_type)) : normalizer_condition (semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_106063 (h0 : prod (is_R_or_C (option congr_arg_kind)) (is_R_or_C (option congr_arg_kind))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_106064 (h0 : topological_space (has_neg_part ennreal)) : topological_space.separable_space (has_neg_part ennreal) := sorry --non-trivial
lemma new_lemma_106065 (h0 : group (ring (has_neg (has_nndist (has_norm Type))))) : is_cyclic (ring (has_neg (has_nndist (has_norm Type)))) := sorry --non-trivial
lemma new_lemma_106066 (h0 : function.extfun Type (functor.comp topological_space complete_distrib_lattice)) : @totally_disconnected_space.{0} (complete_distrib_lattice.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} complete_distrib_lattice.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_106067 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (@id.{2} Type to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (@id.{2} Type to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_106068 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_106069 (h0 : ring (add_comm_monoid (add_comm_monoid environment.implicit_infer_kind))) : is_domain (add_comm_monoid (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_106070 (h0 : ordered_add_comm_monoid (comm_group unsigned)) : archimedean (comm_group unsigned) := sorry --non-trivial
lemma new_lemma_106071 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (random_gen.{0} (semiring.{0} (has_norm.{0} (semiring.{0} empty)))) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (random_gen.{0} (semiring.{0} (has_norm.{0} (semiring.{0} empty)))))  := sorry --non-trivial
lemma new_lemma_106072 (h0 : topological_space (has_top (has_inv (random_gen string_imp)))) : locally_compact_space (has_top (has_inv (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_106073 (h0 : list (add_cancel_monoid name)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_106074 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_pos_part name)) := sorry --non-trivial
lemma new_lemma_106075 (h0 : not (ring (simple_graph reducibility_hints) -> false)) : @is_domain.{0} (simple_graph.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (simple_graph.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_106076 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (as_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (as_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_106077 (h0 : ring (pseudo_metric_space (option empty))) : is_domain (pseudo_metric_space (option empty)) := sorry --non-trivial
lemma new_lemma_106078 (h2 : group (has_norm linarith.ineq)) : is_cyclic (has_norm linarith.ineq) := sorry --non-trivial
lemma new_lemma_106079 (h0 : topological_space (has_to_string Type)) : totally_disconnected_space (has_to_string Type) := sorry --non-trivial
lemma new_lemma_106080 (h0 : uniform_space (complete_linear_order (has_norm empty))) : separated_space (complete_linear_order (has_norm empty)) := sorry --non-trivial
lemma new_lemma_106081 (h0 : functor.add_const (ordered_add_comm_monoid (semigroup environment.implicit_infer_kind)) name) : @archimedean.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (semigroup.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_106082 (h0 : topological_space (add_semigroup (option (option empty)))) : t0_space (add_semigroup (option (option empty))) := sorry --non-trivial
lemma new_lemma_106083 (h0 : topological_space (normed_group (random_gen (random_gen (random_gen (random_gen (random_gen fun_info))))))) : t0_space (normed_group (random_gen (random_gen (random_gen (random_gen (random_gen fun_info)))))) := sorry --non-trivial
lemma new_lemma_106084 (h0 : ring (fintype (has_nnnorm (has_nnnorm (random_gen (has_nnnorm linarith.ineq)))))) : rank_condition (fintype (has_nnnorm (has_nnnorm (random_gen (has_nnnorm linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_106085 (h0 : functor.add_const (group (has_zero linarith.comp)) (has_to_string pos)) : @is_simple_group.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} linarith.comp)) (has_to_string.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_106086 (h0 : topological_space (has_append (has_nnnorm (has_nnnorm char)))) : path_connected_space (has_append (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_106087 (h0 : ring (finset (finset environment.implicit_infer_kind))) : rank_condition (finset (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_106088 (h0 : topological_space std_gen) (h1 : std_gen) (h2 : monoid (path h1 h1)) : nonunits (path h1 h1) (path.refl h1) := sorry --non-trivial
lemma new_lemma_106089 (h0 : prod (simple_graph (option congr_arg_kind)) (simple_graph (option congr_arg_kind))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_106090 (h0 : functor.add_const (function.extfun Type topological_space) (has_neg pos)) : @t1_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_neg.{0} pos) h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_106091 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_106092 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @is_domain.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_106093 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_106094 (h0 : ring (option (semiring (semiring empty)))) : rank_condition (option (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_106095 (h0 : group (has_pos_part (has_pos_part name))) : normalizer_condition (has_pos_part (has_pos_part name)) := sorry --non-trivial
lemma new_lemma_106096 (h0 : complete_lattice (semiring (semiring (semiring (semiring linarith.comp))))) : is_atomistic (semiring (semiring (semiring (semiring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_106097 (h0 : functor.add_const (group (has_nndist pos)) name) : @is_simple_group.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_106098 (h0 : function.extfun Type (functor.add_const (topological_space pos))) : @preirreducible_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} pos)) h0 pos))  := sorry --non-trivial
lemma new_lemma_106099 (h0 : topological_space (add_right_cancel_monoid empty)) : t0_space (add_right_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_106100 (h1 : ring (topological_space (has_nnnorm (random_gen string_imp)))) : strong_rank_condition (topological_space (has_nnnorm (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_106101 (h0 : finset (has_neg (finset linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_106102 (h0 : functor.add_const (topological_space (option empty)) num) : @irreducible_space.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_106103 (h0 : has_mem.mem (normed_group linarith.ineq) has_emptyc.emptyc) : @strong_rank_condition.{0} (normed_group.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type ring.{0} (normed_group.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_106104 (h0 : function.extfun Type (functor.comp topological_space mul_zero_class)) : @totally_disconnected_space.{0} (mul_zero_class.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} mul_zero_class.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} mul_zero_class.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_106105 (h0 : topological_space (canonically_ordered_monoid (sub_neg_monoid name))) : preirreducible_space (canonically_ordered_monoid (sub_neg_monoid name)) := sorry --non-trivial
lemma new_lemma_106106 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_106107 (h0 : functor.add_const (ring (generalized_boolean_algebra linarith.comp)) Type) : @is_domain.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (generalized_boolean_algebra.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_106108 (h0 : topological_space (add_cancel_monoid (semiring unsigned))) : path_connected_space (add_cancel_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_106109 (h1 : complete_lattice (has_le (mul_one_class linarith.ineq))) : is_compactly_generated (has_le (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_106110 (h0 : functor.add_const (topological_space (linear_ordered_add_comm_monoid_with_top pos)) linarith.comp) : @preconnected_space.{0} (linear_ordered_add_comm_monoid_with_top.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_add_comm_monoid_with_top.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_106111 (h0 : list (has_pos_part (has_neg name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_106112 (h0 : topological_space (semiring (semiring (semiring empty)))) : locally_compact_space (semiring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_106113 (h0 : complete_lattice (linear_ordered_field (option pos))) : complete_lattice.is_Sup_finite_compact (linear_ordered_field (option pos)) := sorry --non-trivial
lemma new_lemma_106114 (h0 : group (with_one (id empty))) : normalizer_condition (with_one (id empty)) := sorry --non-trivial
lemma new_lemma_106115 (h0 : not (add_monoid (has_top unsigned) -> false)) : @add_monoid.fg.{0} (has_top.{0} unsigned) (@classical.by_contradiction'.{1} (add_monoid.{0} (has_top.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_106116 (h0 : list (ring (mul_one_class linarith.ineq))) (h1 : ne h0 list.nil) : @rank_condition.{0} (mul_one_class.{0} linarith.ineq) (@list.last.{0} (ring.{0} (mul_one_class.{0} linarith.ineq)) h0 h1)  := sorry --non-trivial
lemma new_lemma_106117 (h0 : list (comm_ring fun_info)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_106118 (h0 : function.extfun (finset Type) (has_mem.mem real.angle)) : add_monoid.fg real.angle := sorry --non-trivial
lemma new_lemma_106119 (h0 : not (ring (distrib linarith.ineq) -> false)) : @is_domain.{0} (distrib.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (distrib.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_106120 (h0 : functor.add_const (ring (ring environment.implicit_infer_kind)) pos) : @is_domain.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_106121 (h0 : topological_space (boolean_algebra.core (has_add (has_add unsigned)))) : normal_space (boolean_algebra.core (has_add (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_106122 (h0 : preorder (mul_one_class string.iterator_imp)) (h1 : set (mul_one_class string.iterator_imp)) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_106123 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_106124 (h0 : complete_lattice (has_neg_part (comm_group (comm_group Type)))) : complete_lattice.is_Sup_finite_compact (has_neg_part (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_106125 (h0 : ring (distrib_lattice (dlist linarith.ineq))) : rank_condition (distrib_lattice (dlist linarith.ineq)) := sorry --non-trivial
lemma new_lemma_106126 (h0 : topological_space (with_bot (semiring (has_norm linarith.comp)))) : path_connected_space (with_bot (semiring (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_106127 (h0 : complete_lattice (dlist (has_inv (random_gen to_additive.value_type)))) : complete_lattice.is_Sup_finite_compact (dlist (has_inv (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_106128 (h0 : ring (normed_linear_ordered_group unsigned)) : is_domain (normed_linear_ordered_group unsigned) := sorry --non-trivial
lemma new_lemma_106129 (h0 : topological_space (has_ssubset (has_nnnorm (has_nnnorm fun_info)))) : t0_space (has_ssubset (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_106130 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (bin_tree.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (bin_tree.{0} empty))  := sorry --non-trivial
lemma new_lemma_106131 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : is_noetherian_ring ennreal := sorry --non-trivial
lemma new_lemma_106132 (h0 : uniform_space (complete_semilattice_Sup (random_gen (random_gen to_additive.value_type)))) : complete_space (complete_semilattice_Sup (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_106133 (h0 : functor.add_const (function.extfun Type group) pos) : @is_cyclic.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_106134 (h0 : complete_lattice (has_top (semiring (semiring empty)))) : is_compactly_generated (has_top (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_106135 (h0 : measurable_space (measure_theory.measure_space unsigned)) (h1 : has_mul (measure_theory.measure_space unsigned)) : has_measurable_mul₂ (measure_theory.measure_space unsigned) := sorry --non-trivial
lemma new_lemma_106136 (h0 : has_neg (nondiscrete_normed_field environment.projection_info)) (h1 : measurable_space (nondiscrete_normed_field environment.projection_info)) : has_measurable_neg (nondiscrete_normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_106137 (h0 : functor.add_const (complete_lattice (free_add_monoid congr_arg_kind)) congr_arg_kind) : @is_compactly_generated.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (free_add_monoid.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_106138 (h0 : functor.add_const (function.extfun (Type 1) cancel_comm_monoid_with_zero) linarith.comp) : @unique_factorization_monoid.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1}) linarith.comp h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_106139 (h0 : group (has_nndist (comm_group Type))) : is_simple_group (has_nndist (comm_group Type)) := sorry --non-trivial
lemma new_lemma_106140 (h0 : topological_space (metric_space (has_norm (has_norm empty)))) : locally_compact_space (metric_space (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_106141 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) (has_add Type)) : @regular_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_106142 (h0 : topological_space (has_le reducibility_hints)) : totally_disconnected_space (has_le reducibility_hints) := sorry --non-trivial
lemma new_lemma_106143 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_106144 (h0 : function.extfun Type group) : @is_cyclic.{0} (linear_order.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_106145 (h2 : complete_lattice (has_nnnorm char)) : complete_lattice.is_Sup_finite_compact (has_nnnorm char) := sorry --non-trivial
lemma new_lemma_106146 (h0 : fin has_zero.zero) : @is_simple_group.{0} (complete_distrib_lattice.{0} real) (@matrix.vec_empty.{0} (group.{0} (complete_distrib_lattice.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_106147 (h0 : complete_lattice (with_one (semiring fun_info))) : is_compactly_generated (with_one (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_106148 (h0 : functor.add_const (topological_space (has_Inf Type)) Type) : @preirreducible_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_Inf.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_106149 (h0 : function.extfun Type topological_space) : @normal_space.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_106150 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) Type) : @preconnected_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_106151 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group congr_arg_kind))) : @strong_rank_condition.{0} (normed_group.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type ring.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_106152 (h0 : prod (has_inter congr_arg_kind) (has_inter congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_106153 (h0 : semiring (ordered_comm_ring (has_pos_part (has_Inf (has_add (has_pos_part Type)))))) : is_noetherian_ring (ordered_comm_ring (has_pos_part (has_Inf (has_add (has_pos_part Type))))) := sorry --non-trivial
lemma new_lemma_106154 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_106155 (h0 h1 : list std_gen) : list.is_infix h0 h1 := sorry --non-trivial
lemma new_lemma_106156 (h0 : finset (linear_ordered_comm_ring unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_106157 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_106158 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_106159 (h0 : list (normed_group (random_gen linarith.comp_source))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_106160 (h0 : functor.add_const (ordered_comm_monoid (add_comm_monoid Type)) environment.implicit_infer_kind) : @has_exists_mul_of_le.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (add_comm_monoid.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_106161 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_106162 (h0 : functor.add_const (topological_space (preorder empty)) empty) : @t0_space.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_106163 (h0 : add_monoid (cancel_monoid unsigned)) : add_monoid.fg (cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_106164 (h0 : group (has_sub linarith.comp)) : normalizer_condition (has_sub linarith.comp) := sorry --non-trivial
lemma new_lemma_106165 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_106166 (h1 : set (has_nnnorm std_gen -> linarith.ineq)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_106167 (h0 : filter (has_ssubset to_additive.value_type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_106168 (h0 : set (canonically_linear_ordered_monoid std_gen -> enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_106169 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_106170 (h1 : set ordering) : set.finite h1 := sorry --non-trivial
lemma new_lemma_106171 (h0 : topological_space (has_div (lex linarith.ineq))) : path_connected_space (has_div (lex linarith.ineq)) := sorry --non-trivial
lemma new_lemma_106172 (h0 : prod (linear_ordered_field (has_to_string num)) (linear_ordered_field (has_to_string num))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_106173 (h0 : topological_space (boolean_algebra.core (option empty))) : totally_separated_space (boolean_algebra.core (option empty)) := sorry --non-trivial
lemma new_lemma_106174 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) (has_pos_part pos)) : @loc_path_connected_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) (has_pos_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_106175 (h0 : group (normed_field (has_ssubset (has_ssubset char)))) : is_cyclic (normed_field (has_ssubset (has_ssubset char))) := sorry --non-trivial
lemma new_lemma_106176 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @normal_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_106177 (h2 : filter (linear_ordered_add_comm_group (has_ssubset linarith.ineq))) : filter.ne_bot h2 := sorry --non-trivial
lemma new_lemma_106178 (h0 : has_coe (nondiscrete_normed_field (mul_one_class enat)) Prop) (h1 : nondiscrete_normed_field (mul_one_class enat)) : @coe_b.{1 1} (nondiscrete_normed_field.{0} (mul_one_class.{0} enat)) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_106179 (h0 : uniform_space (has_nndist (has_add linarith.comp))) : separated_space (has_nndist (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_106180 (h0 : list (simple_graph empty)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_106181 (h0 : topological_space (canonically_ordered_comm_semiring pos)) : discrete_topology (canonically_ordered_comm_semiring pos) := sorry --non-trivial
lemma new_lemma_106182 (h0 : functor.add_const (ring (has_nndist empty)) empty) : @is_principal_ideal_ring.{0} (has_nndist.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_106183 (h0 : group (distrib_lattice (random_gen (random_gen (random_gen char))))) : group.fg (distrib_lattice (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_106184 (h0 : topological_space (has_compl (mul_one_class char))) : t0_space (has_compl (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_106185 (h0 : ordered_add_comm_monoid (comm_monoid (option (option (option (option empty)))))) : archimedean (comm_monoid (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_106186 (h0 : not (measurable_space (has_repr linarith.comp) -> false)) (h1 : has_add (has_repr linarith.comp)) : @has_measurable_add.{0} (has_repr.{0} linarith.comp) (@classical.by_contradiction'.{1} (measurable_space.{0} (has_repr.{0} linarith.comp)) h0) h1  := sorry --non-trivial
lemma new_lemma_106187 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_106188 (h0 : cancel_comm_monoid_with_zero (generalized_boolean_algebra (ring (boolean_algebra.core Type)))) : unique_factorization_monoid (generalized_boolean_algebra (ring (boolean_algebra.core Type))) := sorry --non-trivial
lemma new_lemma_106189 (h0 : group (boolean_algebra (has_to_string (has_to_string unsigned)))) : is_simple_group (boolean_algebra (has_to_string (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_106190 (h0 : functor.add_const (function.extfun Type group) (ring (has_neg Type))) : @normalizer_condition.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) (ring.{1} (has_neg.{1} Type)) h0) (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_106191 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_106192 (h0 : semiring (canonically_ordered_add_monoid unsigned)) : is_noetherian_ring (canonically_ordered_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_106193 (h0 : add_monoid (id congr_arg_kind)) : add_monoid.fg (id congr_arg_kind) := sorry --non-trivial
lemma new_lemma_106194 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_106195 (h0 : topological_space (has_dist ennreal)) : totally_separated_space (has_dist ennreal) := sorry --non-trivial
lemma new_lemma_106196 (h0 : topological_space (simple_graph (has_Inf (has_add linarith.comp)))) : preconnected_space (simple_graph (has_Inf (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_106197 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) Type) : @t1_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_106198 (h0 : not (topological_space (normed_group num) -> false)) : @totally_disconnected_space.{0} (normed_group.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_106199 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} linarith.comp_source (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_106200 (h0 : ring (has_ssubset (has_ssubset linarith.comp_source))) : is_domain (has_ssubset (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_106201 (h0 : topological_space (has_edist num)) : t1_space (has_edist num) := sorry --non-trivial
lemma new_lemma_106202 (h0 : not (group char -> false)) : @is_cyclic.{0} char (@classical.by_contradiction'.{1} (group.{0} char) h0)  := sorry --non-trivial
lemma new_lemma_106203 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) (finset pos)) : @t0_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} name)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_106204 (h0 : ring (simple_graph std_gen)) : strong_rank_condition (simple_graph std_gen) := sorry --non-trivial
lemma new_lemma_106205 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (linear_ordered_add_comm_group.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_add_comm_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_106206 (h0 : functor.add_const (list (has_Sup congr_arg_kind)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_106207 (h0 : has_mem.mem (linear_ordered_semiring num) has_emptyc.emptyc) : @totally_disconnected_space.{0} (linear_ordered_semiring.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_106208 (h0 : topological_space (has_lt (has_nnnorm enat))) : t0_space (has_lt (has_nnnorm enat)) := sorry --non-trivial
lemma new_lemma_106209 (h0 : topological_space (has_bot (has_add linarith.comp))) : discrete_topology (has_bot (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_106210 (h0 : topological_space (has_one (semiring num))) : totally_disconnected_space (has_one (semiring num)) := sorry --non-trivial
lemma new_lemma_106211 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_106212 (h0 : complete_lattice (has_Inf (finset (has_Inf (has_Inf (finset Type)))))) : is_compactly_generated (has_Inf (finset (has_Inf (has_Inf (finset Type))))) := sorry --non-trivial
lemma new_lemma_106213 (h2 : not (ring (distrib char) -> false)) : @rank_condition.{0} (distrib.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (distrib.{0} char)) h2)  := sorry --non-trivial
lemma new_lemma_106214 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (measurable_space.dynkin_system.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (measurable_space.dynkin_system.{0} empty))  := sorry --non-trivial
lemma new_lemma_106215 (h0 : uniform_space (has_union linarith.comp)) : separated_space (has_union linarith.comp) := sorry --non-trivial
lemma new_lemma_106216 (h0 : ulower (fin has_zero.zero)) : nat.perfect (matrix.vec_empty (ulower.up h0)) := sorry --non-trivial
lemma new_lemma_106217 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_106218 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (distrib_lattice.{0} (random_gen.{0} fun_info)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (distrib_lattice.{0} (random_gen.{0} fun_info)))  := sorry --non-trivial
lemma new_lemma_106219 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_to_string num)) := sorry --non-trivial
lemma new_lemma_106220 (h0 : complete_lattice (semiring (option unsigned))) : is_atomistic (semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_106221 (h0 : topological_space (has_neg (has_add (finset name)))) : regular_space (has_neg (has_add (finset name))) := sorry --non-trivial
lemma new_lemma_106222 (h0 : not (topological_space (with_bot num) -> false)) : @irreducible_space.{0} (with_bot.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_106223 (h0 : topological_space (has_top (random_gen (complete_semilattice_Sup to_additive.value_type)))) : locally_compact_space (has_top (random_gen (complete_semilattice_Sup to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_106224 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @t0_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_106225 (h0 : functor.add_const (list (has_add pos)) (ring (ring Type))) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_106226 (h0 : complete_lattice (has_compl (has_lt linarith.comp_source))) : is_compactly_generated (has_compl (has_lt linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_106227 (h0 : complete_lattice (monoid ennreal)) : is_compactly_generated (monoid ennreal) := sorry --non-trivial
lemma new_lemma_106228 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_106229 (h0 : topological_space (complete_distrib_lattice (semigroup name))) : loc_path_connected_space (complete_distrib_lattice (semigroup name)) := sorry --non-trivial
lemma new_lemma_106230 (h0 : complete_lattice (linear_ordered_cancel_comm_monoid unsigned)) : complete_lattice.is_Sup_finite_compact (linear_ordered_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_106231 (h0 : fin has_zero.zero) : @t0_space.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (normed_lattice_add_comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_106232 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_106233 (h0 : topological_space (has_pos_part (has_pos_part name))) : totally_separated_space (has_pos_part (has_pos_part name)) := sorry --non-trivial
lemma new_lemma_106234 (h0 : functor.add_const (fin has_zero.zero) real) : @add_monoid.fg.{0} (sub_neg_monoid.{0} pos) (@matrix.vec_empty.{0} (add_monoid.{0} (sub_neg_monoid.{0} pos)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) real h0))  := sorry --non-trivial
lemma new_lemma_106235 (h0 : complete_lattice (normed_group (semiring (has_norm linarith.comp)))) : complete_lattice.is_Sup_finite_compact (normed_group (semiring (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_106236 (h0 : semiring (generalized_boolean_algebra (has_Inf pos))) : is_noetherian_ring (generalized_boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_106237 (h0 : topological_space (has_one (semiring (has_top (semiring (semiring (semiring (semiring num)))))))) : discrete_topology (has_one (semiring (has_top (semiring (semiring (semiring (semiring num))))))) := sorry --non-trivial
lemma new_lemma_106238 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_106239 (h0 : functor.add_const (list (has_neg Type)) (finset (finset (finset (finset linarith.comp))))) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_106240 (h0 : topological_space (ordered_comm_ring (has_add pos))) : totally_disconnected_space (ordered_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_106241 (h0 : functor.add_const (filter (ring environment.implicit_infer_kind)) environment.implicit_infer_kind) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_106242 (h0 : ordered_comm_monoid (has_pos_part (has_add (has_add name)))) : has_exists_mul_of_le (has_pos_part (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_106243 (h1 : ring (fintype (comm_ring char))) : strong_rank_condition (fintype (comm_ring char)) := sorry --non-trivial
lemma new_lemma_106244 (h0 : group (has_top (has_ssubset to_additive.value_type))) : group.fg (has_top (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_106245 (h0 : topological_space (has_dist (option (option unsigned)))) : t1_space (has_dist (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_106246 (h0 : functor.add_const (topological_space (cancel_monoid pos)) environment.implicit_infer_kind) : @sequential_space.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_106247 (h0 : functor.add_const (topological_space (normed_comm_ring name)) unsigned) : @path_connected_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_106248 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} h0 (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_106249 (h0 : uniform_space (has_add (finset environment.implicit_infer_kind))) : separated_space (has_add (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_106250 (h0 : complete_lattice (linear_ordered_add_comm_group (random_gen linarith.ineq))) : is_atomistic (linear_ordered_add_comm_group (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_106251 (h1 : not (topological_space (has_norm num) -> false)) : @path_connected_space.{0} (has_norm.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} num)) h1)  := sorry --non-trivial
lemma new_lemma_106252 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_106253 (h0 h1 : multiset (random_gen char)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_106254 (h0 : ring (free_add_monoid (semiring (semiring num)))) : strong_rank_condition (free_add_monoid (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_106255 (h0 : functor.add_const (filter (has_neg pos)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_106256 (h0 : functor.add_const (monoid (normed_comm_ring unsigned)) (option unsigned)) : @monoid.fg.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (normed_comm_ring.{0} unsigned)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_106257 (h0 : functor.add_const (topological_space (has_edist unsigned)) empty) : @locally_compact_space.{0} (has_edist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_edist.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_106258 (h0 : topological_space (semigroup (has_add (ring Type)))) : sequential_space (semigroup (has_add (ring Type))) := sorry --non-trivial
lemma new_lemma_106259 (h0 : function.extfun Type (functor.add_const (ordered_comm_monoid name))) : @has_exists_mul_of_le.{0} name (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} name) (option.{0} pos) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ordered_comm_monoid.{0} name)) h0 (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_106260 (h0 : ring (has_one empty)) : strong_rank_condition (has_one empty) := sorry --non-trivial
lemma new_lemma_106261 (h0 : ordered_add_comm_monoid (ordered_comm_ring (has_add Type))) : archimedean (ordered_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_106262 (h0 : not (uniform_space (semiring linarith.comp_source) -> false)) : @complete_space.{0} (semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (uniform_space.{0} (semiring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_106263 (h0 : function.extfun Type (functor.add_const (topological_space Type))) : @normal_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) name (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (topological_space.{1} Type)) h0 name))  := sorry --non-trivial
lemma new_lemma_106264 (h0 : function.extfun Type topological_space) : @t0_space.{0} (boolean_algebra.core.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_106265 (h0 : function.extfun (finset Type) (has_mem.mem (semiring linarith.comp))) : @is_add_cyclic.{0} (semiring.{0} linarith.comp) (@finset.pi.empty.{1 0} Type add_group.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_106266 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_106267 (h4 : add_group (non_unital_non_assoc_semiring string_imp)) : is_add_cyclic (non_unital_non_assoc_semiring string_imp) := sorry --non-trivial
lemma new_lemma_106268 (h0 : topological_space (has_to_string pos)) : regular_space (has_to_string pos) := sorry --non-trivial
lemma new_lemma_106269 (h0 : add_group (semigroup unsigned)) : is_add_cyclic (semigroup unsigned) := sorry --non-trivial
lemma new_lemma_106270 (h0 : functor.add_const (topological_space (ring pos)) name) : @preconnected_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_106271 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (add_left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_106272 (h0 : ring (comm_ring (has_ssubset linarith.comp_source))) : rank_condition (comm_ring (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_106273 (h0 : functor.add_const (ring (generalized_boolean_algebra pos)) (has_neg name)) : @is_domain.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (generalized_boolean_algebra.{0} pos)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_106274 (h0 : functor.add_const (uniform_space (boolean_algebra Type)) linarith.comp) : @separated_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (boolean_algebra.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_106275 (h0 : topological_space (finset (finset Type))) : t0_space (finset (finset Type)) := sorry --non-trivial
lemma new_lemma_106276 (h0 : add_group (metric_space linarith.comp)) : is_add_cyclic (metric_space linarith.comp) := sorry --non-trivial
lemma new_lemma_106277 (h0 : group (has_Inf (has_Inf (has_neg (has_neg (has_neg name)))))) : group.fg (has_Inf (has_Inf (has_neg (has_neg (has_neg name))))) := sorry --non-trivial
lemma new_lemma_106278 (h0 : topological_space (normed_group (has_norm (has_top (has_norm linarith.comp_source))))) : totally_separated_space (normed_group (has_norm (has_top (has_norm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_106279 (h0 : topological_space (add_comm_semigroup char)) (h1 : nat) (h2 : fin (nat.succ h1) -> preorder (add_comm_semigroup char)) (h3 : fin h1) : @order_topology.{0} (add_comm_semigroup.{0} char) h0 (@matrix.vec_tail.{0} (preorder.{0} (add_comm_semigroup.{0} char)) h1 h2 h3)  := sorry --non-trivial
lemma new_lemma_106280 (h0 : complete_lattice (complete_distrib_lattice linarith.comp)) : is_compactly_generated (complete_distrib_lattice linarith.comp) := sorry --non-trivial
lemma new_lemma_106281 (h0 : topological_space (complete_distrib_lattice (has_Inf linarith.comp))) : discrete_topology (complete_distrib_lattice (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_106282 (h0 : measurable_space (linear_ordered_comm_group_with_zero enat)) (h1 : filter (linear_ordered_comm_group_with_zero enat)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_106283 (h0 : ring (uniform_space (metric_space linarith.comp_source))) : rank_condition (uniform_space (metric_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_106284 (h0 : ring (boolean_algebra (ring linarith.comp))) : is_principal_ideal_ring (boolean_algebra (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_106285 (h0 : complete_lattice (with_one (complete_semilattice_Sup empty))) : is_atomistic (with_one (complete_semilattice_Sup empty)) := sorry --non-trivial
lemma new_lemma_106286 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_106287 (h0 : not (monoid (has_top empty) -> false)) : @monoid.fg.{0} (has_top.{0} empty) (@classical.by_contradiction'.{1} (monoid.{0} (has_top.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_106288 (h0 : filter Prop) (h1 : punit) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@category_theory.hom_of_element.{0} (filter.{0} Prop) (@id.{1} (filter.{0} Prop) h0) h1)  := sorry --non-trivial
lemma new_lemma_106289 (h0 : ordered_add_comm_monoid (has_zero name)) : archimedean (has_zero name) := sorry --non-trivial
lemma new_lemma_106290 (h0 : functor.add_const (ordered_add_comm_monoid (has_neg name)) pos) : @archimedean.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_neg.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_106291 (h0 : topological_space (has_nndist (finset (finset (finset pos))))) : locally_compact_space (has_nndist (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_106292 (h0 : topological_space (boolean_algebra (normed_comm_ring linarith.comp))) : preconnected_space (boolean_algebra (normed_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_106293 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (linear_ordered_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_106294 (h1 : random_gen (has_ssubset (has_norm string_imp)) -> random_gen (has_ssubset (has_norm string_imp)) -> bool) : is_dec_refl h1 := sorry --non-trivial
lemma new_lemma_106295 (h0 : topological_space (ordered_cancel_add_comm_monoid (has_to_string pos))) : path_connected_space (ordered_cancel_add_comm_monoid (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_106296 (h0 : ring (has_nnnorm occurrences)) : is_domain (has_nnnorm occurrences) := sorry --non-trivial
lemma new_lemma_106297 (h0 : uniform_space (boolean_algebra (finset linarith.comp))) : complete_space (boolean_algebra (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_106298 (h0 : uniform_space (has_norm (random_gen num))) : separated_space (has_norm (random_gen num)) := sorry --non-trivial
lemma new_lemma_106299 (h0 : ring (simple_graph linarith.ineq)) : strong_rank_condition (simple_graph linarith.ineq) := sorry --non-trivial
lemma new_lemma_106300 (h0 : topological_space (has_neg_part pos)) : normal_space (has_neg_part pos) := sorry --non-trivial
lemma new_lemma_106301 (h0 : group (has_emptyc to_additive.value_type)) : group.fg (has_emptyc to_additive.value_type) := sorry --non-trivial
lemma new_lemma_106302 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_106303 (h0 : uniform_space (with_bot (has_inv (random_gen (random_gen (has_inv linarith.ineq)))))) : complete_space (with_bot (has_inv (random_gen (random_gen (has_inv linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_106304 (h4 : set (char -> char)) : set.separates_points h4 := sorry --non-trivial
lemma new_lemma_106305 (h0 : functor.add_const (topological_space (left_cancel_monoid empty)) empty) : @irreducible_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_106306 (h0 : topological_space (has_bot (has_add name))) : path_connected_space (has_bot (has_add name)) := sorry --non-trivial
lemma new_lemma_106307 (h0 : topological_space (canonically_linear_ordered_monoid num)) : totally_separated_space (canonically_linear_ordered_monoid num) := sorry --non-trivial
lemma new_lemma_106308 (h0 : uniform_space (has_one (has_top (has_top linarith.comp)))) : separated_space (has_one (has_top (has_top linarith.comp))) := sorry --non-trivial
lemma new_lemma_106309 (h0 : functor.add_const (list (ring name)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_106310 (h0 : functor.add_const (uniform_space (has_to_string pos)) environment.implicit_infer_kind) : @complete_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_to_string.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_106311 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_106312 (h0 : group (measurable_space (with_bot (with_bot (with_bot (with_bot string_imp)))))) : group.fg (measurable_space (with_bot (with_bot (with_bot (with_bot string_imp))))) := sorry --non-trivial
lemma new_lemma_106313 (h0 : function.extfun Type (prod znum) -> Prop) (h1 : Exists (fun (x : function.extfun Type (prod znum)), h0 x)) : id_rel (function.extfun_app (classical.some h1) znum) := sorry --non-trivial
lemma new_lemma_106314 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_106315 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (with_one.{0} (has_top.{0} num)) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (with_one.{0} (has_top.{0} num)))  := sorry --non-trivial
lemma new_lemma_106316 (h0 : topological_space (finset (has_pos_part (ring environment.implicit_infer_kind)))) : path_connected_space (finset (has_pos_part (ring environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_106317 (h1 : group (has_nnnorm (comm_ring linarith.comp_source))) : is_cyclic (has_nnnorm (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_106318 (h0 : topological_space (canonically_ordered_comm_semiring empty)) : preirreducible_space (canonically_ordered_comm_semiring empty) := sorry --non-trivial
lemma new_lemma_106319 (h0 : group (boolean_algebra.core (has_pos_part pos))) : is_cyclic (boolean_algebra.core (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_106320 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) name) : @topological_space.separable_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_106321 (h0 : add_group (has_nnnorm (mul_one_class fun_info))) : is_add_cyclic (has_nnnorm (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_106322 (h0 : measurable_space (has_lt fun_info)) (h1 : filter (has_lt fun_info)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_106323 (h0 : functor.add_const (topological_space (finset ennreal)) num) : @locally_compact_space.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_106324 (h0 : topological_space (complete_distrib_lattice (boolean_algebra Type))) : discrete_topology (complete_distrib_lattice (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_106325 (h0 : functor.add_const (topological_space (ring linarith.comp)) (has_neg (has_neg Type))) : @preirreducible_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} linarith.comp)) (has_neg.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_106326 (h0 : functor.comp list add_comm_monoid Type) : palindrome (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_106327 (h0 : topological_space (sub_neg_monoid (has_add Type))) : locally_compact_space (sub_neg_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_106328 (h0 : functor.add_const (function.extfun Type finset) pos) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (has_neg pos)) := sorry --non-trivial
lemma new_lemma_106329 (h0 : group (has_norm (semiring num))) : group.fg (has_norm (semiring num)) := sorry --non-trivial
lemma new_lemma_106330 (h0 : ordered_add_comm_monoid (semigroup ennreal)) : archimedean (semigroup ennreal) := sorry --non-trivial
lemma new_lemma_106331 (h0 : has_lt (has_div string.iterator_imp)) : no_max_order (has_div string.iterator_imp) := sorry --non-trivial
lemma new_lemma_106332 (h0 : ring (has_one (semiring (has_top (semiring (semiring (has_top congr_arg_kind))))))) : is_domain (has_one (semiring (has_top (semiring (semiring (has_top congr_arg_kind)))))) := sorry --non-trivial
lemma new_lemma_106333 (h0 : topological_space (boolean_algebra (has_pos_part (has_Inf (has_pos_part real))))) : topological_space.separable_space (boolean_algebra (has_pos_part (has_Inf (has_pos_part real)))) := sorry --non-trivial
lemma new_lemma_106334 (h0 : complete_lattice (has_norm (random_gen linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (has_norm (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_106335 (h0 : add_group (option unsigned)) : is_add_cyclic (option unsigned) := sorry --non-trivial
lemma new_lemma_106336 (h0 : complete_lattice (uniform_space (mul_one_class linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (uniform_space (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_106337 (h0 : functor.add_const (group (free_add_monoid empty)) congr_arg_kind) : @group.fg.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (free_add_monoid.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_106338 (h0 : topological_space (normed_group congr_arg_kind)) : irreducible_space (normed_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_106339 (h0 : topological_space ordering) : t0_space ordering := sorry --non-trivial
lemma new_lemma_106340 (h0 : not (group (has_norm empty) -> false)) : @group.fg.{0} (has_norm.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (has_norm.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_106341 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_106342 (h0 : not (topological_space (has_union congr_arg_kind) -> false)) : @preirreducible_space.{0} (has_union.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_106343 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_semilattice_Sup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_106344 (h0 : ring (monoid pos)) : strong_rank_condition (monoid pos) := sorry --non-trivial
lemma new_lemma_106345 (h0 : function.extfun Type (functor.comp ordered_comm_monoid has_to_string)) : @has_exists_mul_of_le.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} has_to_string.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ordered_comm_monoid.{0} has_to_string.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_106346 (h0 : functor.add_const (group (complete_distrib_lattice num)) empty) : @group.fg.{0} (complete_distrib_lattice.{0} num) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_106347 (h0 : group (semigroup (option (option pos)))) : is_cyclic (semigroup (option (option pos))) := sorry --non-trivial
lemma new_lemma_106348 (h0 : add_group (complete_linear_order congr_arg_kind)) : is_add_cyclic (complete_linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_106349 (h0 : topological_space (has_nndist (has_add (has_add name)))) : locally_compact_space (has_nndist (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_106350 (h0 : topological_space (canonically_ordered_comm_semiring (boolean_algebra.core pos))) : loc_path_connected_space (canonically_ordered_comm_semiring (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_106351 (h0 : semiring (has_Inf (has_Inf (has_Inf pos)))) : is_noetherian_ring (has_Inf (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_106352 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (random_gen.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (random_gen.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_106353 (h0 : functor.add_const (function.extfun Type ring) (has_to_string Type)) : @rank_condition.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) (has_to_string.{1} Type) h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_106354 (h0 : functor.add_const (topological_space (has_zero pos)) pos) : @totally_separated_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_106355 (h0 : not (add_group (with_one linarith.comp) -> false)) : @is_add_cyclic.{0} (with_one.{0} linarith.comp) (@classical.by_contradiction'.{1} (add_group.{0} (with_one.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_106356 (h0 : functor.add_const (ordered_comm_monoid (complete_distrib_lattice linarith.comp)) name) : @has_exists_mul_of_le.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (complete_distrib_lattice.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_106357 (h0 : ring (has_compl (random_gen to_additive.value_type))) : rank_condition (has_compl (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_106358 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_106359 (h0 : ring (non_unital_non_assoc_semiring string_imp)) : rank_condition (non_unital_non_assoc_semiring string_imp) := sorry --non-trivial
lemma new_lemma_106360 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (filter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (filter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_106361 (h0 : topological_space (linear_ordered_comm_ring (semiring num))) : t0_space (linear_ordered_comm_ring (semiring num)) := sorry --non-trivial
lemma new_lemma_106362 (h0 : finset (normed_comm_ring (finset environment.implicit_infer_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_106363 (h0 : functor.add_const (fin has_zero.zero) Type) : @archimedean.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (ordered_add_comm_monoid.{1} (normed_lattice_add_comm_group.{1} Type)) (@functor.add_const.run.{0 1} (fin (@has_zero.zero.{0} nat nat.has_zero)) Type h0))  := sorry --non-trivial
lemma new_lemma_106364 (h0 : topological_space (complete_semilattice_Sup (distrib_lattice (dlist linarith.ineq)))) : totally_disconnected_space (complete_semilattice_Sup (distrib_lattice (dlist linarith.ineq))) := sorry --non-trivial
lemma new_lemma_106365 (h1 : topological_space (normed_field (has_ssubset linarith.comp_source))) : totally_disconnected_space (normed_field (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_106366 (h0 : function.extfun Type ring) : @is_domain.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_106367 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_dist.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} num))  := sorry --non-trivial
lemma new_lemma_106368 (h0 : functor.add_const (function.extfun Type uniform_space) linarith.comp) : @complete_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) linarith.comp h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_106369 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (normed_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (normed_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_106370 (h0 : topological_space (has_add (option ennreal))) : totally_disconnected_space (has_add (option ennreal)) := sorry --non-trivial
lemma new_lemma_106371 (h0 : function.extfun Type group) : @is_simple_group.{0} (linear_ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_106372 (h0 : ring (add_cancel_comm_monoid (random_gen (uniform_space char)))) : is_domain (add_cancel_comm_monoid (random_gen (uniform_space char))) := sorry --non-trivial
lemma new_lemma_106373 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_106374 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @monoid.fg.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 monoid.{1}) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_106375 (h0 : topological_space (has_Inf (has_nndist Type))) : locally_compact_space (has_Inf (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_106376 (h0 : topological_space (semiring (has_top linarith.comp_source))) : path_connected_space (semiring (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_106377 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) (ring (has_add (ring name)))) : @regular_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) (ring.{0} (has_add.{0} (ring.{0} name))) h0)  := sorry --non-trivial
lemma new_lemma_106378 (h0 : functor.add_const (complete_lattice (finset Type)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (finset.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_106379 (h0 : functor.add_const (finset (ordered_comm_monoid linarith.comp)) (has_Inf Type)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_106380 (h0 : function.extfun Type group) : @normalizer_condition.{0} (comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_106381 (h0 : add_group (complete_linear_order empty)) : is_add_cyclic (complete_linear_order empty) := sorry --non-trivial
lemma new_lemma_106382 (h0 : topological_space (monoid (option empty))) : irreducible_space (monoid (option empty)) := sorry --non-trivial
lemma new_lemma_106383 (h0 : topological_space (semi_normed_comm_ring (random_gen to_additive.value_type))) : locally_compact_space (semi_normed_comm_ring (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_106384 (h0 : topological_space (simple_graph (has_add (ring pos)))) : totally_disconnected_space (simple_graph (has_add (ring pos))) := sorry --non-trivial
lemma new_lemma_106385 (h0 : functor.add_const (topological_space (comm_group pos)) unsigned) : @sequential_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_106386 (h0 : not (topological_space (id num) -> false)) : @locally_compact_space.{0} (@id.{2} Type num) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type num)) h0)  := sorry --non-trivial
lemma new_lemma_106387 (h0 : ring (semi_normed_ring (has_nnnorm linarith.ineq))) : rank_condition (semi_normed_ring (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_106388 (h0 : functor.add_const (group (boolean_algebra.core pos)) linarith.comp) : @is_simple_group.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.core.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_106389 (h1 : add_group (linear_ordered_add_comm_group (has_nnnorm char))) : is_add_cyclic (linear_ordered_add_comm_group (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_106390 (h1 : ring congr_arg_kind) : strong_rank_condition congr_arg_kind := sorry --non-trivial
lemma new_lemma_106391 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) (finset linarith.comp)) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) (finset.{0} linarith.comp) h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_106392 (h0 : ring (has_bot empty)) : strong_rank_condition (has_bot empty) := sorry --non-trivial
lemma new_lemma_106393 (h0 : topological_space (comm_group (has_neg_part unsigned))) : preirreducible_space (comm_group (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_106394 (h0 : functor.add_const (topological_space (as_linear_order empty)) num) : @totally_disconnected_space.{0} (as_linear_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (as_linear_order.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_106395 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (ordered_cancel_add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_106396 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_sub.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (has_sub.{0} num))  := sorry --non-trivial
lemma new_lemma_106397 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_106398 (h0 : filter (generalized_boolean_algebra (boolean_algebra.core (has_add Type)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_106399 (h0 : ring (semigroup (boolean_algebra.core (boolean_algebra.core Type)))) : rank_condition (semigroup (boolean_algebra.core (boolean_algebra.core Type))) := sorry --non-trivial
lemma new_lemma_106400 (h0 : filter (complete_distrib_lattice (comm_group (comm_group Type)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_106401 (h0 : complete_lattice (comm_semigroup (has_bot name))) : is_compactly_generated (comm_semigroup (has_bot name)) := sorry --non-trivial
lemma new_lemma_106402 (h0 : not (uniform_space (dlist linarith.ineq) -> false)) : @complete_space.{0} (dlist.{0} linarith.ineq) (@classical.by_contradiction'.{1} (uniform_space.{0} (dlist.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_106403 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (pseudo_metric_space empty)) := sorry --non-trivial
lemma new_lemma_106404 (h0 : topological_space (add_comm_monoid unsigned)) : irreducible_space (add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_106405 (h0 : not (group (complete_semilattice_Sup unsigned) -> false)) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (complete_semilattice_Sup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_106406 (h0 : topological_space (measurable_space (has_norm (has_norm linarith.comp_source)))) : t0_space (measurable_space (has_norm (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_106407 (h0 : not (measurable_space (encodable fun_info) -> false)) (h1 : has_sup (encodable fun_info)) : @has_measurable_sup₂.{0} (encodable.{0} fun_info) (@classical.by_contradiction'.{1} (measurable_space.{0} (encodable.{0} fun_info)) h0) h1  := sorry --non-trivial
lemma new_lemma_106408 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_106409 (h0 : functor.add_const (ring (has_nndist pos)) Type) : @strong_rank_condition.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_nndist.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_106410 (h0 : topological_space (has_nndist (canonically_ordered_monoid environment.implicit_infer_kind))) : preconnected_space (has_nndist (canonically_ordered_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_106411 (h0 : cancel_monoid unsigned -> cancel_monoid unsigned) (h1 : cancel_monoid unsigned) : function.periodic_pts h0 h1 := sorry --non-trivial
lemma new_lemma_106412 (h0 : not (function.extfun Type list -> false)) : list.nodup (function.extfun_app (classical.by_contradiction' h0) (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_106413 (h0 : ring (has_Sup (option (option empty)))) : is_domain (has_Sup (option (option empty))) := sorry --non-trivial
lemma new_lemma_106414 (h0 : functor.add_const (topological_space (has_neg_part pos)) linarith.comp) : @t1_space.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_106415 (h0 : fin has_zero.zero) : @topological_space.separable_space.{1} (sub_neg_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (sub_neg_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_106416 (h0 : filter (has_nndist (finset name))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_106417 (h1 : topological_space (mul_one_class (mul_one_class enat))) (h2 : preorder (mul_one_class (mul_one_class enat))) : order_closed_topology (mul_one_class (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_106418 (h0 : add_monoid (has_to_string (has_add (has_add Type)))) : add_monoid.fg (has_to_string (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_106419 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (linear_ordered_cancel_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_cancel_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_106420 (h0 : group (normed_comm_ring (has_add Type))) : group.fg (normed_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_106421 (h0 : topological_space (semigroup (semiring (semiring empty)))) : topological_space.separable_space (semigroup (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_106422 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_106423 (h0 : function.extfun Type (functor.add_const (topological_space (ring Type)))) : @loc_path_connected_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) pos (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (topological_space.{1} (ring.{1} Type))) h0 pos))  := sorry --non-trivial
lemma new_lemma_106424 (h0 : monoid (id empty)) : monoid.fg (id empty) := sorry --non-trivial
lemma new_lemma_106425 (h0 : filter (has_neg (comm_group (comm_group Type)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_106426 (h0 : functor.add_const (topological_space znum) (option empty)) : @preirreducible_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_106427 (h2 : topological_space (random_gen (has_emptyc fun_info))) : path_connected_space (random_gen (has_emptyc fun_info)) := sorry --non-trivial
lemma new_lemma_106428 (h0 : group (has_nndist (option (option (option (option pos)))))) : is_simple_group (has_nndist (option (option (option (option pos))))) := sorry --non-trivial
lemma new_lemma_106429 (h0 : ring (cancel_monoid (comm_group (comm_group name)))) : is_principal_ideal_ring (cancel_monoid (comm_group (comm_group name))) := sorry --non-trivial
lemma new_lemma_106430 (h0 : functor.add_const (function.extfun (Type 1) ordered_add_comm_monoid) Type) : @archimedean.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ordered_add_comm_monoid.{1}) Type h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_106431 (h0 : complete_lattice (fintype (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) : complete_lattice.is_Sup_finite_compact (fintype (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_106432 (h0 : topological_space (finset (ring environment.implicit_infer_kind))) : totally_disconnected_space (finset (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_106433 (h0 : functor.add_const (function.extfun Type topological_space) (ring name)) : @path_connected_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (ring.{0} name) h0) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_106434 (h0 : finset (has_pos_part (ring (ring (ring pos))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_106435 (h0 : functor.add_const (list (monoid empty)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_106436 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) name) : @discrete_topology.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_106437 (h0 : functor.add_const (topological_space (has_nndist Type)) (ring environment.implicit_infer_kind)) : @preconnected_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_106438 (h0 : topological_space (has_inner empty congr_arg_kind)) : totally_separated_space (has_inner empty congr_arg_kind) := sorry --non-trivial
lemma new_lemma_106439 (h0 : topological_space string) : totally_disconnected_space string := sorry --non-trivial
lemma new_lemma_106440 (h0 : topological_space (has_neg (ring name))) : t1_space (has_neg (ring name)) := sorry --non-trivial
lemma new_lemma_106441 (h1 : group (normed_field (uniform_space (random_gen char)))) : is_cyclic (normed_field (uniform_space (random_gen char))) := sorry --non-trivial
lemma new_lemma_106442 (h0 : functor.add_const (monoid (add_cancel_monoid name)) linarith.comp) : @monoid.fg.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (add_cancel_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_106443 (h0 : ring (measure_theory.measure_space (semiring empty))) : strong_rank_condition (measure_theory.measure_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_106444 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @strong_rank_condition.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) ring.{0}) (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_106445 (h2 : set (uniform_space to_additive.value_type)) : set.finite h2 := sorry --non-trivial
lemma new_lemma_106446 (h0 : monoid (omega_complete_partial_order (option (option empty)))) : monoid.fg (omega_complete_partial_order (option (option empty))) := sorry --non-trivial
lemma new_lemma_106447 (h0 : functor.add_const (topological_space (add_left_cancel_semigroup unsigned)) congr_arg_kind) : @topological_space.separable_space.{0} (add_left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_106448 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_106449 (h0 : topological_space (has_one (has_top num))) : normal_space (has_one (has_top num)) := sorry --non-trivial
lemma new_lemma_106450 (h0 : functor.add_const (ring (has_neg pos)) linarith.comp) : @is_principal_ideal_ring.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_106451 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_106452 (h0 : ring (denumerable (metric_space reducibility_hints))) : rank_condition (denumerable (metric_space reducibility_hints)) := sorry --non-trivial
lemma new_lemma_106453 (h0 : cancel_comm_monoid_with_zero (has_edist (semiring empty))) : unique_factorization_monoid (has_edist (semiring empty)) := sorry --non-trivial
lemma new_lemma_106454 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) environment.implicit_infer_kind) : @t0_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_106455 (h1 : ring (random_gen (has_nnnorm char))) : strong_rank_condition (random_gen (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_106456 (h0 : topological_space (add_semigroup (comm_monoid (ordered_comm_group (option empty))))) : irreducible_space (add_semigroup (comm_monoid (ordered_comm_group (option empty)))) := sorry --non-trivial
lemma new_lemma_106457 (h0 : ordered_comm_monoid (has_add (finset Type))) : has_exists_mul_of_le (has_add (finset Type)) := sorry --non-trivial
lemma new_lemma_106458 (h0 : not (topological_space (random_gen fun_info) -> false)) : @path_connected_space.{0} (random_gen.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_106459 (h0 : functor.add_const (topological_space (has_add pos)) pos) : @locally_compact_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_106460 (h0 : ring (has_star (semiring (semiring num)))) : strong_rank_condition (has_star (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_106461 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} (complete_linear_order.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) (complete_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_106462 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @totally_disconnected_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_106463 (h0 : uniform_space (has_to_string (option num))) : complete_space (has_to_string (option num)) := sorry --non-trivial
lemma new_lemma_106464 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_106465 (h1 : topological_space (has_ssubset to_additive.value_type)) : path_connected_space (has_ssubset to_additive.value_type) := sorry --non-trivial
lemma new_lemma_106466 (h0 : functor.add_const (group (cancel_monoid linarith.comp)) linarith.comp) : @is_simple_group.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (cancel_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_106467 (h0 : functor.add_const (topological_space (normed_linear_ordered_group unsigned)) (semiring unsigned)) : @discrete_topology.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} unsigned)) (semiring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_106468 (h0 : fin has_zero.zero) : @complete_space.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@matrix.vec_empty.{0} (uniform_space.{0} (normed_lattice_add_comm_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_106469 (h0 : ring (option pos)) : rank_condition (option pos) := sorry --non-trivial
lemma new_lemma_106470 (h0 : list (ordered_comm_ring (has_add (has_add pos)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_106471 (h0 : list (with_one char)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_106472 (h1 : list (linear_ordered_add_comm_group char)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_106473 (h5 : group (normed_field (has_nnnorm (random_gen string_imp)))) : is_cyclic (normed_field (has_nnnorm (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_106474 (h0 : functor.add_const (filter (comm_group unsigned)) unsigned) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_106475 (h0 : ring (distrib (mul_one_class (has_nnnorm fun_info)))) : strong_rank_condition (distrib (mul_one_class (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_106476 (h0 : topological_space (has_add linarith.comp_source)) : t0_space (has_add linarith.comp_source) := sorry --non-trivial
lemma new_lemma_106477 (h0 : functor.add_const (topological_space (has_neg environment.implicit_infer_kind)) linarith.comp) : @regular_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_106478 (h0 : filter (has_add (has_neg (has_add linarith.comp)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_106479 (h0 : topological_space (bin_tree (semiring num))) : totally_disconnected_space (bin_tree (semiring num)) := sorry --non-trivial
lemma new_lemma_106480 (h0 : functor.add_const (complete_lattice (partial_order num)) num) : @complete_lattice.is_Sup_finite_compact.{0} (partial_order.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (partial_order.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_106481 (h0 : uniform_space (pseudo_metric_space unsigned)) : complete_space (pseudo_metric_space unsigned) := sorry --non-trivial
lemma new_lemma_106482 (h0 : function.extfun (Type 1) topological_space) : @topological_space.separable_space.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_106483 (h0 : function.extfun Type (functor.comp ring has_neg_part)) : @strong_rank_condition.{0} (has_neg_part.{0} (cancel_monoid.{0} ennreal)) (@functor.comp.run.{0 0 0} ring.{0} has_neg_part.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} has_neg_part.{0}) h0 (cancel_monoid.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_106484 (h0 : complete_lattice (random_gen (has_Inf (denumerable linarith.ineq)))) : complete_lattice.is_Sup_finite_compact (random_gen (has_Inf (denumerable linarith.ineq))) := sorry --non-trivial
lemma new_lemma_106485 (h0 : functor.add_const (complete_lattice (boolean_algebra unsigned)) Type) : @is_compactly_generated.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 1} (complete_lattice.{0} (boolean_algebra.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_106486 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_inter.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inter.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_106487 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (with_one.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (with_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_106488 (h0 : functor.add_const (topological_space (has_zero ennreal)) ennreal) : @topological_space.separable_space.{0} (has_zero.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_106489 (h0 : has_neg ereal) (h1 : thunk (measurable_space ereal)) : has_measurable_neg ereal := sorry --non-trivial
lemma new_lemma_106490 (h1 : complete_lattice (semi_normed_comm_ring (has_ssubset (has_nnnorm char)))) : is_compactly_generated (semi_normed_comm_ring (has_ssubset (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_106491 (h0 : functor.add_const (ring (add_cancel_monoid pos)) linarith.comp) : @is_domain.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_106492 (h1 : topological_space (mul_one_class (add_comm_semigroup std_gen))) : totally_disconnected_space (mul_one_class (add_comm_semigroup std_gen)) := sorry --non-trivial
lemma new_lemma_106493 (h0 : has_mem.mem string_imp has_emptyc.emptyc) : filter.ne_bot (finset.pi.empty filter string_imp h0) := sorry --non-trivial
lemma new_lemma_106494 (h0 : not (filter (distrib_lattice linarith.comp_source) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_106495 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) pos) : @totally_disconnected_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_106496 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_106497 (h0 : uniform_space (partial_order (has_top empty))) : separated_space (partial_order (has_top empty)) := sorry --non-trivial
lemma new_lemma_106498 (h1 : filter Type) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_106499 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (canonically_linear_ordered_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (canonically_linear_ordered_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_106500 (h0 : functor.add_const (monoid (add_cancel_monoid Type)) (finset (complete_semilattice_Sup linarith.comp))) : @monoid.fg.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (add_cancel_monoid.{1} Type)) (finset.{0} (complete_semilattice_Sup.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_106501 (h0 : complete_lattice (has_one empty)) : complete_lattice.is_Sup_finite_compact (has_one empty) := sorry --non-trivial
lemma new_lemma_106502 (h1 : complete_lattice (has_append (has_nnnorm (random_gen char)))) : complete_lattice.is_Sup_finite_compact (has_append (has_nnnorm (random_gen char))) := sorry --non-trivial
lemma new_lemma_106503 (h0 : filter (with_zero (has_nnnorm fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_106504 (h0 : functor.add_const (topological_space (ring unsigned)) linarith.comp) : @t1_space.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_106505 (h0 : functor.add_const (list (has_neg_part Type)) (has_add (has_add (has_add pos)))) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_106506 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_106507 (h0 : complete_lattice (metric_space string_imp)) : is_compactly_generated (metric_space string_imp) := sorry --non-trivial
lemma new_lemma_106508 (h0 : semiring (with_one linarith.comp)) : is_noetherian_ring (with_one linarith.comp) := sorry --non-trivial
lemma new_lemma_106509 (h0 : functor.add_const Prop (option congr_arg_kind)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_106510 (h0 : topological_space (finset (has_add name))) : loc_path_connected_space (finset (has_add name)) := sorry --non-trivial
lemma new_lemma_106511 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (add_group.{0} (has_norm.{0} empty)) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (add_group.{0} (has_norm.{0} empty)))  := sorry --non-trivial
lemma new_lemma_106512 (h0 : topological_space (boolean_algebra (has_bot real))) : totally_separated_space (boolean_algebra (has_bot real)) := sorry --non-trivial
lemma new_lemma_106513 (h0 : filter (has_norm (id linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_106514 (h0 : filter (group_with_zero unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_106515 (h0 : function.extfun Type group) : @group.fg.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_106516 (h0 : functor.add_const (add_monoid (semiring num)) congr_arg_kind) : @add_monoid.fg.{0} (semiring.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (semiring.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_106517 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (with_one.{0} (has_top.{0} (has_top.{0} (has_inv.{0} (has_top.{0} to_additive.value_type))))) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (with_one.{0} (has_top.{0} (has_top.{0} (has_inv.{0} (has_top.{0} to_additive.value_type))))))  := sorry --non-trivial
lemma new_lemma_106518 (h0 : function.extfun (Type 1) topological_space) : @preconnected_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_106519 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @preconnected_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_106520 (h0 : functor.add_const (list (ordered_comm_ring linarith.comp)) (has_add (ring Type))) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_106521 (h0 : topological_space real) : preirreducible_space real := sorry --non-trivial
lemma new_lemma_106522 (h0 : with_bot (fin has_zero.zero)) (h1 : ne h0 has_bot.bot) : id (matrix.vec_empty (with_bot.unbot h0 h1)) := sorry --non-trivial
lemma new_lemma_106523 (h0 : filter (has_star (semiring (semiring congr_arg_kind)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_106524 (h0 : functor.add_const (topological_space (ordered_ring empty)) num) : @loc_path_connected_space.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_106525 (h0 : topological_space (id (linear_ordered_semiring unsigned))) : normal_space (id (linear_ordered_semiring unsigned)) := sorry --non-trivial
lemma new_lemma_106526 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (mul_zero_class.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (mul_zero_class.{0} pos))  := sorry --non-trivial
lemma new_lemma_106527 (h3 : string_imp -> string_imp -> bool) : is_dec_refl h3 := sorry --non-trivial
lemma new_lemma_106528 (h0 : topological_space (has_add (ordered_comm_monoid linarith.comp))) : preirreducible_space (has_add (ordered_comm_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_106529 (h0 : functor.add_const (ring (has_nndist unsigned)) environment.implicit_infer_kind) : @rank_condition.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_106530 (h0 : semiring (has_star (semiring (semiring (semiring (semiring unsigned)))))) : is_noetherian_ring (has_star (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_106531 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_106532 (h0 : functor.add_const (prod (semiring unsigned) (semiring unsigned)) unsigned) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_106533 (h1 : ring (add_left_cancel_monoid to_additive.value_type)) : rank_condition (add_left_cancel_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_106534 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (group_with_zero.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (group_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_106535 (h0 : complete_lattice (has_add (has_Inf (has_Inf Type)))) : is_compactly_generated (has_add (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_106536 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (distrib_lattice.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (distrib_lattice.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_106537 (h0 : function.extfun Type topological_space) : @normal_space.{0} (canonically_linear_ordered_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_106538 (h0 : topological_space (has_top (has_top (semiring (has_top to_additive.value_type))))) : discrete_topology (has_top (has_top (semiring (has_top to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_106539 (h0 : functor.add_const (complete_lattice (is_R_or_C empty)) empty) : @is_compactly_generated.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (is_R_or_C.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_106540 (h0 : list (boolean_algebra (has_Inf (has_pos_part pos)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_106541 (h0 : complete_lattice (has_add (sub_neg_monoid (has_Inf (has_add real))))) : is_compactly_generated (has_add (sub_neg_monoid (has_Inf (has_add real)))) := sorry --non-trivial
lemma new_lemma_106542 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (preorder.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (preorder.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_106543 (h0 : add_monoid (canonically_ordered_monoid (ordered_comm_monoid real))) : add_monoid.fg (canonically_ordered_monoid (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_106544 (h0 : uniform_space (normed_comm_ring ennreal)) : separated_space (normed_comm_ring ennreal) := sorry --non-trivial
lemma new_lemma_106545 (h0 : topological_space (has_bot (has_add (has_Inf linarith.comp)))) : discrete_topology (has_bot (has_add (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_106546 (h0 : ring (linear_ordered_semiring (has_norm to_additive.value_type))) : is_domain (linear_ordered_semiring (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_106547 (h0 : topological_space (has_star (ordered_cancel_comm_monoid congr_arg_kind))) : irreducible_space (has_star (ordered_cancel_comm_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_106548 (h0 : fin has_zero.zero) : @group.fg.{0} (has_Inf.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (has_Inf.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_106549 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_106550 (h0 : ring (comm_ring (comm_ring (metric_space (normed_field linarith.comp_source))))) : rank_condition (comm_ring (comm_ring (metric_space (normed_field linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_106551 (h0 : uniform_space (has_neg_part (comm_group name))) : separated_space (has_neg_part (comm_group name)) := sorry --non-trivial
lemma new_lemma_106552 (h0 : topological_space (normed_comm_ring (ring (ring linarith.comp)))) : locally_compact_space (normed_comm_ring (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_106553 (h0 : ring (has_pos_part (has_add (finset pos)))) : is_domain (has_pos_part (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_106554 (h0 : complete_lattice (distrib_lattice string_imp)) : complete_lattice.is_Sup_finite_compact (distrib_lattice string_imp) := sorry --non-trivial
lemma new_lemma_106555 (h0 : functor.comp monoid comm_group name) : @monoid.fg.{0} (comm_group.{0} name) (@functor.comp.run.{0 0 0} monoid.{0} comm_group.{0} name h0)  := sorry --non-trivial
lemma new_lemma_106556 (h0 : functor.add_const (function.extfun Type topological_space) (has_pos_part Type)) : @irreducible_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (has_pos_part.{1} Type) h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_106557 (h0 : topological_space (has_norm (has_nnnorm char))) : locally_compact_space (has_norm (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_106558 (h0 : topological_space (has_pos_part (boolean_algebra.core linarith.comp))) : topological_space.separable_space (has_pos_part (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_106559 (h0 : group (ring (option ennreal))) : is_simple_group (ring (option ennreal)) := sorry --non-trivial
lemma new_lemma_106560 (h0 : topological_space (semigroup Type)) : totally_separated_space (semigroup Type) := sorry --non-trivial
lemma new_lemma_106561 (h0 : topological_space (add_comm_monoid (boolean_algebra (boolean_algebra pos)))) : discrete_topology (add_comm_monoid (boolean_algebra (boolean_algebra pos))) := sorry --non-trivial
lemma new_lemma_106562 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) (has_nndist Type)) : @totally_separated_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} pos)) (has_nndist.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_106563 (h0 : functor.add_const (group (has_star empty)) unsigned) : @group.fg.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (has_star.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_106564 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (option.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (option.{0} empty))  := sorry --non-trivial
lemma new_lemma_106565 (h0 : group (has_inter congr_arg_kind)) : is_cyclic (has_inter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_106566 (h0 : functor.add_const (topological_space (finset linarith.comp)) linarith.comp) : @preconnected_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_106567 (h1 : not (topological_space (has_sdiff fun_info) -> false)) : @totally_separated_space.{0} (has_sdiff.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (has_sdiff.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_106568 (h0 : functor.add_const (finset (boolean_algebra.core unsigned)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_106569 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_106570 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group fun_info))) : @totally_disconnected_space.{0} (normed_group.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_106571 (h0 : monoid (preorder (ordered_cancel_comm_monoid (semiring (semiring (semiring empty)))))) : monoid.fg (preorder (ordered_cancel_comm_monoid (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_106572 (h0 : functor.comp uniform_space boolean_algebra Type) : @separated_space.{1} (boolean_algebra.{1} Type) (@functor.comp.run.{1 1 1} uniform_space.{1} boolean_algebra.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_106573 (h0 : functor.add_const (function.extfun Type semiring) Type) : @is_noetherian_ring.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type semiring.{0}) Type h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_106574 (h0 : uniform_space (ordered_comm_monoid (has_neg name))) : complete_space (ordered_comm_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_106575 (h0 : semiring (has_neg (has_neg (has_neg linarith.comp)))) : is_noetherian_ring (has_neg (has_neg (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_106576 (h0 : semiring (has_pos_part (has_Inf linarith.comp))) : is_noetherian_ring (has_pos_part (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_106577 (h0 : function.extfun Type topological_space) : @t1_space.{0} (comm_semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_106578 (h0 : topological_space (canonically_linear_ordered_monoid char)) : path_connected_space (canonically_linear_ordered_monoid char) := sorry --non-trivial
lemma new_lemma_106579 (h0 : topological_space (normed_comm_ring name)) : locally_compact_space (normed_comm_ring name) := sorry --non-trivial
lemma new_lemma_106580 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) environment.implicit_infer_kind) : @totally_separated_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_106581 (h0 : list (has_to_string (has_Inf (has_Inf Type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_106582 (h0 : finset (cancel_monoid (option name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_106583 (h0 : topological_space (measurable_space.dynkin_system (semiring linarith.comp))) : discrete_topology (measurable_space.dynkin_system (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_106584 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_106585 (h0 : add_monoid (has_neg_part (has_to_string name))) : add_monoid.fg (has_neg_part (has_to_string name)) := sorry --non-trivial
lemma new_lemma_106586 (h0 : ring (has_emptyc unsigned)) : strong_rank_condition (has_emptyc unsigned) := sorry --non-trivial
lemma new_lemma_106587 (h0 : function.extfun Type topological_space) : @t0_space.{0} (topological_space.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (topological_space.{0} char))  := sorry --non-trivial
lemma new_lemma_106588 (h0 : not (add_monoid (option empty) -> false)) : @add_monoid.fg.{0} (option.{0} empty) (@classical.by_contradiction'.{1} (add_monoid.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_106589 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_106590 (h0 : ring (semigroup (option empty))) : is_principal_ideal_ring (semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_106591 (h1 : set (has_nnnorm (normed_field std_gen))) : set.finite h1 := sorry --non-trivial
lemma new_lemma_106592 (h0 : function.extfun Type group) : @group.fg.{0} (add_cancel_monoid.{0} (option.{0} num)) (@function.extfun_app.{2 1} Type group.{0} h0 (add_cancel_monoid.{0} (option.{0} num)))  := sorry --non-trivial
lemma new_lemma_106593 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (omega_complete_partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (omega_complete_partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_106594 (h2 : ring (linear_ordered_add_comm_group string_imp)) : is_domain (linear_ordered_add_comm_group string_imp) := sorry --non-trivial
lemma new_lemma_106595 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_106596 (h0 : filter (normed_comm_ring (has_add (finset linarith.comp)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_106597 (h0 : cancel_comm_monoid_with_zero (mul_zero_class (finset pos))) : unique_factorization_monoid (mul_zero_class (finset pos)) := sorry --non-trivial
lemma new_lemma_106598 (h0 : topological_space (boolean_algebra.core (has_add Type))) : preconnected_space (boolean_algebra.core (has_add Type)) := sorry --non-trivial
lemma new_lemma_106599 (h0 : not (topological_space (normed_group linarith.comp_source) -> false)) : @irreducible_space.{0} (normed_group.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_106600 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (monoid_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_106601 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (measurable_space.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (measurable_space.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_106602 (h0 : comm_semiring (dlist string_imp)) (h1 : ideal (dlist string_imp)) : ideal.is_primary h1 := sorry --non-trivial
lemma new_lemma_106603 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_106604 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_106605 (h0 : topological_space (has_top (has_top (has_inv linarith.comp_source)))) : irreducible_space (has_top (has_top (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_106606 (h0 : complete_lattice (normed_group (has_inv to_additive.value_type))) : is_compactly_generated (normed_group (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_106607 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_106608 (h0 : has_le (dlist string_imp)) (h1 : bounded_order (dlist string_imp)) : is_simple_order (dlist string_imp) := sorry --non-trivial
lemma new_lemma_106609 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_dist.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_dist.{0} num))  := sorry --non-trivial
lemma new_lemma_106610 (h0 : topological_space (random_gen (has_nnnorm (has_nnnorm char)))) : path_connected_space (random_gen (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_106611 (h0 : semiring (has_nndist (has_to_string Type))) : is_noetherian_ring (has_nndist (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_106612 (h0 : functor.add_const (finset (has_to_string name)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_106613 (h0 : functor.add_const (topological_space (semigroup unsigned)) (semiring empty)) : @preirreducible_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_106614 (h0 : functor.add_const (topological_space auto.case_option) (option unsigned)) : @t1_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_106615 (h0 : finset (complete_distrib_lattice (has_add pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_106616 (h0 : topological_space (semiring (has_norm linarith.comp))) : normal_space (semiring (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_106617 (h0 h1 : pnat) : pnat.coprime (id (id (id h0))) (id (id (id (id h1)))) := sorry --non-trivial
lemma new_lemma_106618 (h0 : group (boolean_algebra (finset (has_neg linarith.comp)))) : group.fg (boolean_algebra (finset (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_106619 (h0 : not (topological_space (has_top congr_arg_kind) -> false)) : @discrete_topology.{0} (has_top.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_106620 (h0 : functor.add_const (ordered_add_comm_monoid (ring name)) (has_add pos)) : @archimedean.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ring.{0} name)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_106621 (h0 : ring (measurable_space.dynkin_system num)) : is_domain (measurable_space.dynkin_system num) := sorry --non-trivial
lemma new_lemma_106622 (h0 : topological_space (ring (has_add (has_pos_part pos)))) : loc_path_connected_space (ring (has_add (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_106623 (h0 : functor.add_const (function.extfun (Type 1) cancel_comm_monoid_with_zero) environment.implicit_infer_kind) : @unique_factorization_monoid.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1}) environment.implicit_infer_kind h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_106624 (h1 : topological_space (normed_field linarith.comp_source)) : totally_disconnected_space (normed_field linarith.comp_source) := sorry --non-trivial
lemma new_lemma_106625 (h4 : function.extfun Type topological_space) : @path_connected_space.{0} (preorder.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h4 (preorder.{0} num))  := sorry --non-trivial
lemma new_lemma_106626 (h0 : set (has_compl (has_compl fun_info))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_106627 (h0 : ordered_add_comm_monoid (has_neg (finset environment.implicit_infer_kind))) : archimedean (has_neg (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_106628 (h0 : add_monoid (normed_comm_ring (has_neg_part environment.implicit_infer_kind))) : add_monoid.fg (normed_comm_ring (has_neg_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_106629 (h0 : complete_lattice (has_append (comm_ring (comm_ring char)))) : is_compactly_generated (has_append (comm_ring (comm_ring char))) := sorry --non-trivial
lemma new_lemma_106630 (h0 : topological_space fun_info) (h1 : pfun (nondiscrete_normed_field (mul_one_class fun_info)) fun_info) (h2 : nondiscrete_normed_field (mul_one_class fun_info)) : is_path_connected (pfun.graph' h1 h2) := sorry --non-trivial
lemma new_lemma_106631 (h0 : group (canonically_ordered_comm_semiring (finset linarith.comp))) : is_cyclic (canonically_ordered_comm_semiring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_106632 (h0 : function.extfun (finset Type) (has_mem.mem (ordered_semiring linarith.ineq))) : @totally_separated_space.{0} (ordered_semiring.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (ordered_semiring.{0} linarith.ineq) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (ordered_semiring.{0} linarith.ineq)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_106633 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) empty) : @archimedean.{0} (ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) empty h0) (ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_106634 (h1 : set (has_nnnorm string_imp)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_106635 (h0 : uniform_space (has_ssubset reducibility_hints)) : complete_space (has_ssubset reducibility_hints) := sorry --non-trivial
lemma new_lemma_106636 (h0 : ordered_add_comm_monoid (finset (has_to_string unsigned))) : archimedean (finset (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_106637 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (filter.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (filter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_106638 (h0 : add_group (normed_field (pseudo_metric_space linarith.ineq))) : is_add_cyclic (normed_field (pseudo_metric_space linarith.ineq)) := sorry --non-trivial
lemma new_lemma_106639 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (@id.{2} Type linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (@id.{2} Type linarith.ineq))  := sorry --non-trivial
lemma new_lemma_106640 (h0 : function.extfun (Type 1) (functor.add_const (group subsingleton_info))) : @group.fg.{0} subsingleton_info (@functor.add_const.run.{0 1} (group.{0} subsingleton_info) Type (@function.extfun_app.{3 1} (Type 1) (functor.add_const.{0 1} (group.{0} subsingleton_info)) h0 Type))  := sorry --non-trivial
lemma new_lemma_106641 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} pos (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) pos)  := sorry --non-trivial
lemma new_lemma_106642 (h0 : not (topological_space (mul_zero_class empty) -> false)) : @path_connected_space.{0} (mul_zero_class.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (mul_zero_class.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_106643 (h0 : add_group (metric_space char)) : is_add_cyclic (metric_space char) := sorry --non-trivial
lemma new_lemma_106644 (h0 : topological_space (linear_ordered_comm_group (option ennreal))) : topological_space.separable_space (linear_ordered_comm_group (option ennreal)) := sorry --non-trivial
lemma new_lemma_106645 (h0 : ring (linear_ordered_cancel_comm_monoid congr_arg_kind)) : is_domain (linear_ordered_cancel_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_106646 (h0 : topological_space (ordered_comm_ring (has_Inf (has_add name)))) : totally_separated_space (ordered_comm_ring (has_Inf (has_add name))) := sorry --non-trivial
lemma new_lemma_106647 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_edist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_edist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_106648 (h0 : functor.add_const (ordered_add_comm_monoid (normed_linear_ordered_group congr_arg_kind)) empty) : @archimedean.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (normed_linear_ordered_group.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_106649 (h0 : list (ordered_comm_ring (has_Inf (has_add pos)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_106650 (h0 : functor.add_const (ordered_comm_monoid (ring unsigned)) Type) : @has_exists_mul_of_le.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (ring.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_106651 (h0 : functor.add_const (topological_space (cancel_monoid unsigned)) pos) : @discrete_topology.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_106652 (h0 : group (semigroup congr_arg_kind)) : normalizer_condition (semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_106653 (h0 : topological_space (free_add_monoid (semiring (semiring (semiring unsigned))))) : topological_space.separable_space (free_add_monoid (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_106654 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (linear_ordered_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (linear_ordered_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_106655 (h0 : function.extfun Type (functor.add_const (uniform_space (preorder empty)))) : @separated_space.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (preorder.{0} empty)) (option.{0} (option.{0} (option.{0} unsigned))) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (preorder.{0} empty))) h0 (option.{0} (option.{0} (option.{0} unsigned)))))  := sorry --non-trivial
lemma new_lemma_106656 (h0 : list (monoid empty)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_106657 (h0 : topological_space (has_neg (comm_group (has_to_string (add_comm_monoid (has_add Type)))))) : t1_space (has_neg (comm_group (has_to_string (add_comm_monoid (has_add Type))))) := sorry --non-trivial
lemma new_lemma_106658 (h0 : cancel_comm_monoid_with_zero (linear_ordered_field congr_arg_kind)) : unique_factorization_monoid (linear_ordered_field congr_arg_kind) := sorry --non-trivial
lemma new_lemma_106659 (h0 : function.extfun Type uniform_space) : @separated_space.{0} ennreal (@function.extfun_app.{2 1} Type uniform_space.{0} h0 ennreal)  := sorry --non-trivial
lemma new_lemma_106660 (h0 : group (ring (has_Inf linarith.comp))) : is_cyclic (ring (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_106661 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_106662 (h0 : topological_space (has_top (has_norm to_additive.value_type))) : t0_space (has_top (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_106663 (h0 : fin has_zero.zero) : @monoid.fg.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type monoid.{0}) h0) (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_106664 (h0 : set (semi_normed_comm_ring (mul_one_class enat))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_106665 (h0 : topological_space (has_add (has_Inf pos))) : sequential_space (has_add (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_106666 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (pseudo_metric_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_106667 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_106668 (h0 : functor.comp ring canonically_ordered_comm_semiring pos) : @strong_rank_condition.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} canonically_ordered_comm_semiring.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_106669 (h0 : ring (linear_ordered_comm_ring empty)) : strong_rank_condition (linear_ordered_comm_ring empty) := sorry --non-trivial
lemma new_lemma_106670 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @locally_compact_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_106671 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @normalizer_condition.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_106672 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_106673 (h0 : add_group (random_gen (has_norm string_imp))) : is_add_cyclic (random_gen (has_norm string_imp)) := sorry --non-trivial
lemma new_lemma_106674 (h0 : not (complete_lattice (linear_ordered_semiring unsigned) -> false)) : @is_compactly_generated.{0} (linear_ordered_semiring.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_106675 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system empty)) num) : @t0_space.{0} (measurable_space.dynkin_system.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_106676 (h0 : add_group (ring (has_Inf pos))) : is_add_cyclic (ring (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_106677 (h0 : topological_space (has_top (semiring (add_left_cancel_monoid linarith.comp)))) : loc_path_connected_space (has_top (semiring (add_left_cancel_monoid linarith.comp))) := sorry --non-trivial
lemma new_lemma_106678 (h0 : topological_space (id (semiring (semiring empty)))) : preirreducible_space (id (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_106679 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_106680 (h0 : list (has_star (semiring (semiring (semiring (semiring (semiring num))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_106681 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @t0_space.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_106682 (h0 : topological_space (has_top (id linarith.comp))) : irreducible_space (has_top (id linarith.comp)) := sorry --non-trivial
lemma new_lemma_106683 (h0 : has_mem.mem (has_norm (has_norm linarith.ineq)) has_emptyc.emptyc) : @complete_space.{0} (has_norm.{0} (has_norm.{0} linarith.ineq)) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_norm.{0} (has_norm.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_106684 (h0 : group (cancel_monoid Type)) : is_cyclic (cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_106685 (h0 : functor.add_const (topological_space (has_nndist pos)) unsigned) : @loc_path_connected_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_106686 (h0 : topological_space (nondiscrete_normed_field enat)) (h1 : add_group (nondiscrete_normed_field enat)) : topological_add_group (nondiscrete_normed_field enat) := sorry --non-trivial
lemma new_lemma_106687 (h0 : functor.add_const (group (ordered_ring pos)) Type) : @is_cyclic.{0} (ordered_ring.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (ordered_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_106688 (h0 : functor.comp topological_space has_neg real) : @t0_space.{0} (has_neg.{0} real) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} real h0)))))))))))))))))))))))))))))))))))))))))))))))))))))  := sorry --non-trivial
lemma new_lemma_106689 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (omega_complete_partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (omega_complete_partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_106690 (h2 : topological_space (semi_normed_comm_ring to_additive.value_type)) : totally_disconnected_space (semi_normed_comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_106691 (h0 : functor.add_const (add_group (ring linarith.comp)) name) : @is_add_cyclic.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_106692 (h0 : ring (has_append (has_nnnorm fun_info))) : rank_condition (has_append (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_106693 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_star.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_star.{0} num))  := sorry --non-trivial
lemma new_lemma_106694 (h0 : ring (random_gen (has_inv (has_norm (has_norm fun_info))))) : is_domain (random_gen (has_inv (has_norm (has_norm fun_info)))) := sorry --non-trivial
lemma new_lemma_106695 (h1 : group (div_inv_monoid string_imp)) : is_cyclic (div_inv_monoid string_imp) := sorry --non-trivial
lemma new_lemma_106696 (h0 : right_cancel_semigroup pos -> right_cancel_semigroup pos -> Prop) : is_symm (right_cancel_semigroup pos) h0 := sorry --non-trivial
lemma new_lemma_106697 (h0 : functor.add_const (group (has_to_string (comm_group name))) linarith.comp) : @is_simple_group.{0} (has_to_string.{0} (comm_group.{0} name)) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} (comm_group.{0} name))) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_106698 (h1 : not (ring (normed_field reducibility_hints) -> false)) : @is_domain.{0} (normed_field.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (normed_field.{0} reducibility_hints)) h1)  := sorry --non-trivial
lemma new_lemma_106699 (h0 : functor.add_const (topological_space (has_add pos)) unsigned) : @loc_path_connected_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_106700 (h0 : topological_space (has_zero (option (option (option pos))))) : loc_path_connected_space (has_zero (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_106701 (h0 : topological_space (comm_semigroup real)) : preconnected_space (comm_semigroup real) := sorry --non-trivial
lemma new_lemma_106702 (h0 : not (add_monoid (measure_theory.measure_space congr_arg_kind) -> false)) : @add_monoid.fg.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (add_monoid.{0} (measure_theory.measure_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_106703 (h0 : group (finset num)) : group.fg (finset num) := sorry --non-trivial
lemma new_lemma_106704 (h0 : functor.add_const (topological_space (has_add (ring environment.implicit_infer_kind))) linarith.comp) : @preconnected_space.{0} (has_add.{0} (ring.{0} environment.implicit_infer_kind)) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} (ring.{0} environment.implicit_infer_kind))) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_106705 (h0 : function.extfun Type ring) : @is_domain.{0} (add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_106706 (h0 : group (option (option ennreal))) : is_simple_group (option (option ennreal)) := sorry --non-trivial
lemma new_lemma_106707 (h0 : group (has_emptyc linarith.comp)) : is_cyclic (has_emptyc linarith.comp) := sorry --non-trivial
lemma new_lemma_106708 (h0 : monoid (has_norm (has_top num))) : monoid.fg (has_norm (has_top num)) := sorry --non-trivial
lemma new_lemma_106709 (h0 : add_monoid (normed_group empty)) : add_monoid.fg (normed_group empty) := sorry --non-trivial
lemma new_lemma_106710 (h0 : list (add_group_with_zero_nhd name)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_106711 (h0 : list (has_Inf (ordered_ring Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_106712 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_106713 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen num))) : @discrete_topology.{0} (random_gen.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_106714 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) (has_neg (has_neg Type))) : @path_connected_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} pos)) (has_neg.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_106715 (h0 : filter (non_assoc_semiring (semiring (semiring empty)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_106716 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_106717 (h0 : group (with_bot (random_gen (random_gen (id linarith.ineq))))) : normalizer_condition (with_bot (random_gen (random_gen (id linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_106718 (h0 : finset (add_comm_monoid (has_to_string unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_106719 (h0 : topological_space (semiring (semiring congr_arg_kind))) : irreducible_space (semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_106720 (h1 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h1) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_106721 (h0 : functor.add_const (functor.add_const (topological_space pos) name) name) : @totally_separated_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) name (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} pos) name) name h0))  := sorry --non-trivial
lemma new_lemma_106722 (h0 : complete_lattice (plift (option unsigned))) : is_atomistic (plift (option unsigned)) := sorry --non-trivial
lemma new_lemma_106723 (h0 : cancel_comm_monoid_with_zero (complete_distrib_lattice (ring pos))) : unique_factorization_monoid (complete_distrib_lattice (ring pos)) := sorry --non-trivial
lemma new_lemma_106724 (h0 : functor.comp topological_space cancel_monoid pos) : @normal_space.{0} (cancel_monoid.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_106725 (h1 : complete_lattice (with_bot linarith.ineq)) : complete_lattice.is_Sup_finite_compact (with_bot linarith.ineq) := sorry --non-trivial
lemma new_lemma_106726 (h0 : functor.add_const (filter (has_nndist Type)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_106727 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (with_one.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (with_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_106728 (h0 : topological_space (finset (boolean_algebra (boolean_algebra (has_to_string (has_neg pos)))))) : locally_compact_space (finset (boolean_algebra (boolean_algebra (has_to_string (has_neg pos))))) := sorry --non-trivial
lemma new_lemma_106729 (h0 : functor.add_const (ring (cancel_monoid Type)) pos) : @is_principal_ideal_ring.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (cancel_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_106730 (h0 : functor.add_const (list (metric_space linarith.comp)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_106731 (h0 : topological_space (has_to_string (finset (finset linarith.comp)))) : regular_space (has_to_string (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_106732 (h0 : has_mem.mem (has_top (random_gen linarith.comp_source)) has_emptyc.emptyc) : @irreducible_space.{0} (has_top.{0} (random_gen.{0} linarith.comp_source)) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} (random_gen.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_106733 (h0 : has_mem.mem (metric_space unsigned) has_emptyc.emptyc) : @t0_space.{0} (metric_space.{0} unsigned) (@finset.pi.empty.{1 0} Type topological_space.{0} (metric_space.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_106734 (h0 : measurable_space (normed_field char)) (h1 : filter (normed_field char)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_106735 (h0 : nat -> std_gen -> Prop -> Prop) (h1 : nat) (h2 : Prop) (h3 : list std_gen) : list.foldr_with_index_aux h0 h1 h2 h3 := sorry --non-trivial
lemma new_lemma_106736 (h0 : topological_space (has_pos_part (has_pos_part pos))) : t1_space (has_pos_part (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_106737 (h0 : topological_space (linear_ordered_semiring linarith.comp)) (h1 : set (set (linear_ordered_semiring linarith.comp))) : topological_space.is_topological_basis h1 := sorry --non-trivial
lemma new_lemma_106738 (h0 : set (has_div environment.projection_info)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_106739 (h0 : ring (generalized_boolean_algebra (has_Inf linarith.comp))) : is_principal_ideal_ring (generalized_boolean_algebra (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_106740 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} (option.{0} (option.{0} (option.{0} (option.{0} empty))))) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (add_cancel_monoid.{0} (option.{0} (option.{0} (option.{0} (option.{0} empty))))))  := sorry --non-trivial
lemma new_lemma_106741 (h0 : group (has_neg (has_add linarith.comp))) : group.fg (has_neg (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_106742 (h0 : functor.add_const (uniform_space (boolean_algebra environment.implicit_infer_kind)) (has_pos_part linarith.comp)) : @complete_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) (has_pos_part.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_106743 (h0 : functor.add_const (list (ordered_cancel_add_comm_monoid num)) num) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_106744 (h0 : functor.add_const (functor.comp group has_neg_part pos) Type) : @group.fg.{0} (has_neg_part.{0} pos) (@functor.comp.run.{0 0 0} group.{0} has_neg_part.{0} pos (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} group.{0} has_neg_part.{0} pos) pos (@functor.comp.run.{0 0 0} group.{0} has_neg_part.{0} pos (@functor.add_const.run.{0 1} (functor.comp.{0 0 0} group.{0} has_neg_part.{0} pos) Type h0))))  := sorry --non-trivial
lemma new_lemma_106745 (h0 : topological_space (has_nndist (comm_group Type))) : preirreducible_space (has_nndist (comm_group Type)) := sorry --non-trivial
lemma new_lemma_106746 (h0 : complete_lattice (is_R_or_C unsigned)) : complete_lattice.is_Sup_finite_compact (is_R_or_C unsigned) := sorry --non-trivial
lemma new_lemma_106747 (h0 : measurable_space (nondiscrete_normed_field (normed_field reducibility_hints))) (h1 : set (nondiscrete_normed_field (normed_field reducibility_hints))) : measurable_set h1 := sorry --non-trivial
lemma new_lemma_106748 (h0 : function.extfun (finset Type) (has_mem.mem (with_one linarith.comp))) : @locally_compact_space.{0} (with_one.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_106749 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_cyclic.{0} (measurable_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (measurable_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_106750 (h0 : topological_space (add_cancel_monoid (option pos))) : preconnected_space (add_cancel_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_106751 (h0 : group (linear_ordered_semiring linarith.comp)) : is_cyclic (linear_ordered_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_106752 (h0 : group (left_cancel_semigroup num)) : normalizer_condition (left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_106753 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_106754 (h0 : ring (semigroup (option (option (option unsigned))))) : is_principal_ideal_ring (semigroup (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_106755 (h0 : complete_lattice (complete_linear_order (option unsigned))) : is_compactly_generated (complete_linear_order (option unsigned)) := sorry --non-trivial
lemma new_lemma_106756 (h0 : monoid (normed_lattice_add_comm_group Type)) : monoid.fg (normed_lattice_add_comm_group Type) := sorry --non-trivial
lemma new_lemma_106757 (h0 : topological_space (left_cancel_monoid num)) : discrete_topology (left_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_106758 (h0 : filter (has_zero (has_nndist Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_106759 (h0 : ring (has_nnnorm (has_ssubset to_additive.value_type))) : rank_condition (has_nnnorm (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_106760 (h0 : topological_space (has_compl (has_ssubset linarith.ineq))) : totally_disconnected_space (has_compl (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_106761 (h0 : topological_space (with_zero string_imp)) : locally_compact_space (with_zero string_imp) := sorry --non-trivial
lemma new_lemma_106762 (h0 : topological_space (boolean_algebra (has_Inf real))) : path_connected_space (boolean_algebra (has_Inf real)) := sorry --non-trivial
lemma new_lemma_106763 (h1 : topological_space (distrib fun_info)) : t0_space (distrib fun_info) := sorry --non-trivial
lemma new_lemma_106764 (h0 : finset (has_to_string (has_pos_part (ordered_ring linarith.comp)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_106765 (h0 : topological_space (linear_ordered_cancel_comm_monoid empty)) : loc_path_connected_space (linear_ordered_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_106766 (h0 : ring (boolean_algebra.core (has_neg_part (comm_group Type)))) : is_domain (boolean_algebra.core (has_neg_part (comm_group Type))) := sorry --non-trivial
lemma new_lemma_106767 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_106768 (h0 : group (boolean_algebra (has_Inf real))) : group.fg (boolean_algebra (has_Inf real)) := sorry --non-trivial
lemma new_lemma_106769 (h1 : ring (topological_space reducibility_hints)) : is_domain (topological_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_106770 (h0 : functor.add_const (ring (bin_tree num)) num) : @is_domain.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (bin_tree.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_106771 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf linarith.comp))) : totally_separated_space (normed_lattice_add_comm_group (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_106772 (h0 : ring (has_append (comm_ring linarith.comp_source))) : rank_condition (has_append (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_106773 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_106774 (h0 : complete_lattice (boolean_algebra.core (cancel_monoid (has_neg linarith.comp)))) : is_atomistic (boolean_algebra.core (cancel_monoid (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_106775 (h0 : monoid (random_gen (random_gen (random_gen linarith.comp_source)))) : monoid.fg (random_gen (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_106776 (h0 : topological_space (id (semiring num))) : totally_disconnected_space (id (semiring num)) := sorry --non-trivial
lemma new_lemma_106777 (h0 : topological_space (has_Inf (finset pos))) : discrete_topology (has_Inf (finset pos)) := sorry --non-trivial
lemma new_lemma_106778 (h0 : complete_lattice (cancel_monoid (comm_group Type))) : is_atomistic (cancel_monoid (comm_group Type)) := sorry --non-trivial
lemma new_lemma_106779 (h0 : topological_space (group_with_zero (option unsigned))) : totally_separated_space (group_with_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_106780 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (left_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (left_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_106781 (h0 : topological_space (ring (has_neg Type))) : locally_compact_space (ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_106782 (h0 : semiring (complete_distrib_lattice (add_comm_monoid (has_add pos)))) : is_noetherian_ring (complete_distrib_lattice (add_comm_monoid (has_add pos))) := sorry --non-trivial
lemma new_lemma_106783 (h0 : uniform_space (add_group congr_arg_kind)) : separated_space (add_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_106784 (h0 : functor.add_const (add_monoid (generalized_boolean_algebra Type)) (has_pos_part Type)) : @add_monoid.fg.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (add_monoid.{1} (generalized_boolean_algebra.{1} Type)) (has_pos_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_106785 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_106786 (h0 : monoid (complete_semilattice_Sup linarith.comp)) : monoid.fg (complete_semilattice_Sup linarith.comp) := sorry --non-trivial
lemma new_lemma_106787 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_106788 (h0 : ring (random_gen (semiring (has_norm (semiring linarith.comp))))) : is_domain (random_gen (semiring (has_norm (semiring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_106789 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (left_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_106790 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) (measurable_space.dynkin_system.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_106791 (h0 : functor.comp topological_space mul_zero_class Type) : @preirreducible_space.{1} (mul_zero_class.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} mul_zero_class.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_106792 (h0 : complete_lattice (non_assoc_semiring (semiring (semiring congr_arg_kind)))) : complete_lattice.is_Sup_finite_compact (non_assoc_semiring (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_106793 (h0 : topological_space (measurable_space (semiring complex))) : totally_disconnected_space (measurable_space (semiring complex)) := sorry --non-trivial
lemma new_lemma_106794 (h1 : measurable_space (add_comm_semigroup (add_comm_semigroup char))) (h2 : set (add_comm_semigroup (add_comm_semigroup char))) : measurable_set h2 := sorry --non-trivial
lemma new_lemma_106795 (h0 : group (generalized_boolean_algebra (has_add pos))) : normalizer_condition (generalized_boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_106796 (h0 : uniform_space (boolean_algebra (has_neg (has_neg (finset (finset Type)))))) : complete_space (boolean_algebra (has_neg (has_neg (finset (finset Type))))) := sorry --non-trivial
lemma new_lemma_106797 (h0 : finset (comm_group (has_add pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_106798 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (canonically_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (canonically_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_106799 (h0 : functor.add_const (complete_lattice unsigned) pos) : @complete_lattice.is_Sup_finite_compact.{0} unsigned (@functor.add_const.run.{0 0} (complete_lattice.{0} unsigned) pos h0)  := sorry --non-trivial
lemma new_lemma_106800 (h0 : complete_lattice (left_cancel_semigroup unsigned)) : is_compactly_generated (left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_106801 (h0 : functor.add_const (finset (has_star num)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_106802 (h0 : functor.add_const (group (add_comm_monoid Type)) name) : @is_simple_group.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (add_comm_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_106803 (h0 : ring (has_Inf (finset name))) : is_principal_ideal_ring (has_Inf (finset name)) := sorry --non-trivial
lemma new_lemma_106804 (h0 : filter (boolean_algebra.core environment.implicit_infer_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_106805 (h0 : functor.add_const (group (has_to_string linarith.comp)) (ring (finset pos))) : @is_cyclic.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} linarith.comp)) (ring.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_106806 (h0 : complete_lattice (nondiscrete_normed_field ereal)) : complete_lattice.is_Sup_finite_compact (nondiscrete_normed_field ereal) := sorry --non-trivial
lemma new_lemma_106807 (h0 : uniform_space (comm_group name)) : separated_space (comm_group name) := sorry --non-trivial
lemma new_lemma_106808 (h0 : function.extfun (Type 1) topological_space) : @preirreducible_space.{1} (pseudo_metric_space.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (pseudo_metric_space.{1} Type))  := sorry --non-trivial
lemma new_lemma_106809 (h0 : functor.add_const (complete_lattice (finset pos)) pos) : @is_atomistic.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_106810 (h0 : function.extfun ((finset Type -> Prop) -> Prop) (function.extfun (finset Type -> Prop))) : @irreducible_space.{0} (has_emptyc.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} linarith.comp_source)) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) (@function.extfun_app.{2 0} ((finset.{1} Type → Prop) → Prop) (function.extfun.{2 0} (finset.{1} Type → Prop)) h0 (function.extfun.{2 0} (finset.{1} Type))) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} linarith.comp_source))) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_106811 (h0 : monoid (has_neg (normed_comm_ring (boolean_algebra.core environment.implicit_infer_kind)))) : monoid.fg (has_neg (normed_comm_ring (boolean_algebra.core environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_106812 (h0 : functor.add_const (topological_space (cancel_monoid unsigned)) Type) : @irreducible_space.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_106813 (h0 : ring (has_edist (option (option empty)))) : is_principal_ideal_ring (has_edist (option (option empty))) := sorry --non-trivial
lemma new_lemma_106814 (h0 : topological_space (finset empty)) : normal_space (finset empty) := sorry --non-trivial
lemma new_lemma_106815 (h0 : topological_space (has_dist unsigned)) : irreducible_space (has_dist unsigned) := sorry --non-trivial
lemma new_lemma_106816 (h0 : topological_space (add_cancel_monoid (has_neg (has_Inf Type)))) : loc_path_connected_space (add_cancel_monoid (has_neg (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_106817 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_106818 (h0 : topological_space Type) : discrete_topology Type := sorry --non-trivial
lemma new_lemma_106819 (h0 : filter (random_gen linarith.comp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_106820 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (topological_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (topological_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_106821 (h0 : complete_lattice (has_emptyc linarith.comp_source)) : is_compactly_generated (has_emptyc linarith.comp_source) := sorry --non-trivial
lemma new_lemma_106822 (h0 : functor.add_const (topological_space (has_to_string unsigned)) name) : @irreducible_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_106823 (h0 : group (normed_group (random_gen (random_gen (random_gen congr_arg_kind))))) : is_cyclic (normed_group (random_gen (random_gen (random_gen congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_106824 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (linear_ordered_comm_ring.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} h0 (linear_ordered_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_106825 (h0 : topological_space (add_comm_monoid (has_neg (has_neg (add_comm_monoid (has_Inf name)))))) : t0_space (add_comm_monoid (has_neg (has_neg (add_comm_monoid (has_Inf name))))) := sorry --non-trivial
lemma new_lemma_106826 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @discrete_topology.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_106827 (h0 : topological_space (simple_graph congr_arg_kind)) : normal_space (simple_graph congr_arg_kind) := sorry --non-trivial
lemma new_lemma_106828 (h0 : measurable_space (normed_field enat)) (h1 : filter (normed_field enat)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_106829 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} linarith.comp_source (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_106830 (h0 : functor.add_const (topological_space name) unsigned) : @t0_space.{0} name (@functor.add_const.run.{0 0} (topological_space.{0} name) unsigned h0)  := sorry --non-trivial
lemma new_lemma_106831 (h0 : topological_space (has_star unsigned)) : locally_compact_space (has_star unsigned) := sorry --non-trivial
lemma new_lemma_106832 (h0 : topological_space (linear_ordered_comm_group (option (option unsigned)))) : preconnected_space (linear_ordered_comm_group (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_106833 (h1 : function.extfun Type topological_space) : @totally_disconnected_space.{0} fun_info (@function.extfun_app.{2 1} Type topological_space.{0} h1 fun_info)  := sorry --non-trivial
lemma new_lemma_106834 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_106835 (h1 : group (random_gen (has_top fun_info))) : normalizer_condition (random_gen (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_106836 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_106837 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_106838 (h1 : topological_space (random_gen linarith.comp_source)) : totally_disconnected_space (random_gen linarith.comp_source) := sorry --non-trivial
lemma new_lemma_106839 (h0 : topological_space (ordered_comm_monoid (has_Inf (has_Inf pos)))) : sequential_space (ordered_comm_monoid (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_106840 (h0 : topological_space (canonically_linear_ordered_monoid unsigned)) : loc_path_connected_space (canonically_linear_ordered_monoid unsigned) := sorry --non-trivial
lemma new_lemma_106841 (h0 : topological_space (dlist (random_gen (has_inv linarith.ineq)))) : irreducible_space (dlist (random_gen (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_106842 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (distrib_lattice.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (distrib_lattice.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_106843 (h0 : topological_space (normed_field string.iterator_imp)) (h1 : add_group (normed_field string.iterator_imp)) : topological_add_group (normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_106844 (h0 : not (ring (linear_ordered_comm_group_with_zero string_imp) -> false)) : @rank_condition.{0} (linear_ordered_comm_group_with_zero.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_comm_group_with_zero.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_106845 (h0 : not (add_group (complete_distrib_lattice linarith.ineq) -> false)) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} linarith.ineq) (@classical.by_contradiction'.{1} (add_group.{0} (complete_distrib_lattice.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_106846 (h0 : functor.add_const (ring (has_zero name)) pos) : @is_domain.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_106847 (h0 : functor.add_const (uniform_space (has_nndist name)) pos) : @separated_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_nndist.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_106848 (h1 : topological_space (has_lt linarith.comp_source)) (h2 : preorder (has_lt linarith.comp_source)) : order_topology (has_lt linarith.comp_source) := sorry --non-trivial
lemma new_lemma_106849 (h0 : topological_space (has_neg (finset (finset pos)))) : normal_space (has_neg (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_106850 (h0 : functor.add_const (filter (normed_comm_ring Type)) (normed_comm_ring Type)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_106851 (h0 : add_group (simple_graph unsigned)) : is_add_cyclic (simple_graph unsigned) := sorry --non-trivial
lemma new_lemma_106852 (h0 : has_lt (add_comm_semigroup (has_compl enat))) : no_max_order (add_comm_semigroup (has_compl enat)) := sorry --non-trivial
lemma new_lemma_106853 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_106854 (h0 : semiring (metric_space (semiring (semiring (semiring (semiring congr_arg_kind)))))) : is_noetherian_ring (metric_space (semiring (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_106855 (h0 : complete_lattice (has_to_string (has_neg_part name))) : complete_lattice.is_Sup_finite_compact (has_to_string (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_106856 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) (has_neg (has_neg linarith.comp))) : @t0_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) (has_neg.{0} (has_neg.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_106857 (h0 : cancel_comm_monoid_with_zero (has_add linarith.comp)) : unique_factorization_monoid (has_add linarith.comp) := sorry --non-trivial
lemma new_lemma_106858 (h0 : functor.add_const (topological_space (ordered_ring congr_arg_kind)) empty) : @discrete_topology.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_106859 (h0 : functor.add_const (ring (has_neg name)) name) : @strong_rank_condition.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_106860 (h0 : topological_space (add_comm_semigroup (mul_one_class (mul_one_class string.iterator_imp)))) : path_connected_space (add_comm_semigroup (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_106861 (h0 : filter (boolean_algebra (add_comm_monoid (add_comm_monoid environment.implicit_infer_kind)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_106862 (h1 : function.extfun Type topological_space) : @irreducible_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} h1 linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_106863 (h0 : complete_lattice (has_add (has_nnnorm fun_info))) : is_compactly_generated (has_add (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_106864 (h0 : topological_space (boolean_algebra.core (finset ennreal))) : normal_space (boolean_algebra.core (finset ennreal)) := sorry --non-trivial
lemma new_lemma_106865 (h0 : topological_space (has_div (mul_one_class (mul_one_class char)))) : path_connected_space (has_div (mul_one_class (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_106866 (h0 : functor.add_const (ring (measurable_space.dynkin_system num)) (semiring empty)) : @is_principal_ideal_ring.{0} (measurable_space.dynkin_system.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (measurable_space.dynkin_system.{0} num)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_106867 (h0 : functor.add_const (function.extfun (Type 1) finset) pos) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (ordered_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_106868 (h0 : add_group (add_comm_monoid (add_comm_monoid name))) : is_add_cyclic (add_comm_monoid (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_106869 (h0 : topological_space (has_compl fun_info)) (h1 : preorder (has_compl fun_info)) : order_topology (has_compl fun_info) := sorry --non-trivial
lemma new_lemma_106870 (h0 : fin has_zero.zero) : @path_connected_space.{1} (add_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (add_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_106871 (h0 : functor.add_const (topological_space (has_zero Type)) linarith.comp) : @irreducible_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_106872 (h0 : ring (has_nndist (has_neg pos))) : is_principal_ideal_ring (has_nndist (has_neg pos)) := sorry --non-trivial
lemma new_lemma_106873 (h0 : topological_space (has_norm (semiring (semiring (semiring empty))))) : path_connected_space (has_norm (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_106874 (h0 : functor.add_const (ordered_add_comm_monoid (add_right_cancel_monoid unsigned)) (option unsigned)) : @archimedean.{0} (add_right_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (add_right_cancel_monoid.{0} unsigned)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_106875 (h0 : group (semi_normed_ring to_additive.value_type)) : is_cyclic (semi_normed_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_106876 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem uniform_space)) : @complete_space.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) uniform_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (metric_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_106877 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_neg_part.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_106878 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (random_gen.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_106879 (h0 : functor.add_const (fin has_zero.zero) real) : @normal_space.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_bot.{1} Type)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) real h0))  := sorry --non-trivial
lemma new_lemma_106880 (h0 : functor.add_const (uniform_space (generalized_boolean_algebra pos)) (ring linarith.comp)) : @separated_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (generalized_boolean_algebra.{0} pos)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_106881 (h0 : ring (non_unital_non_assoc_semiring to_additive.value_type)) : is_domain (non_unital_non_assoc_semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_106882 (h0 : ring (simple_graph (normed_field to_additive.value_type))) : is_domain (simple_graph (normed_field to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_106883 (h0 : ring (has_one congr_arg_kind)) : is_principal_ideal_ring (has_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_106884 (h0 : function.extfun Type (prod (add_group congr_arg_kind))) : id_rel (function.extfun_app h0 (add_group congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_106885 (h0 : complete_lattice (with_bot (has_top empty))) : is_atomistic (with_bot (has_top empty)) := sorry --non-trivial
lemma new_lemma_106886 (h0 : ring (denumerable (has_nnnorm int))) : is_domain (denumerable (has_nnnorm int)) := sorry --non-trivial
lemma new_lemma_106887 (h0 : function.extfun nat fin) : @locally_compact_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_106888 (h0 : functor.add_const (topological_space (has_star num)) empty) : @locally_compact_space.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_106889 (h0 : semiring (has_to_string congr_arg_kind)) : is_noetherian_ring (has_to_string congr_arg_kind) := sorry --non-trivial
lemma new_lemma_106890 (h0 : topological_space (finset (ring linarith.comp))) : t1_space (finset (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_106891 (h0 : filter (option (option unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_106892 (h0 : topological_space (has_inv (random_gen char))) : totally_disconnected_space (has_inv (random_gen char)) := sorry --non-trivial
lemma new_lemma_106893 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_edist.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_edist.{0} num))  := sorry --non-trivial
lemma new_lemma_106894 (h0 : topological_space (comm_semigroup (ordered_comm_monoid (sub_neg_monoid linarith.comp)))) : path_connected_space (comm_semigroup (ordered_comm_monoid (sub_neg_monoid linarith.comp))) := sorry --non-trivial
lemma new_lemma_106895 (h0 : functor.add_const (add_group pos) (has_add name)) : @is_add_cyclic.{0} pos (@functor.add_const.run.{0 0} (add_group.{0} pos) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_106896 (h0 : list (left_cancel_monoid (semiring unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_106897 (h0 : add_group (complete_semilattice_Sup (has_norm (semiring fun_info)))) : is_add_cyclic (complete_semilattice_Sup (has_norm (semiring fun_info))) := sorry --non-trivial
lemma new_lemma_106898 (h0 : topological_space (simple_graph (has_nndist num))) : normal_space (simple_graph (has_nndist num)) := sorry --non-trivial
lemma new_lemma_106899 (h0 : cancel_comm_monoid_with_zero (boolean_algebra.core environment.implicit_infer_kind)) : unique_factorization_monoid (boolean_algebra.core environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_106900 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (has_sub.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (has_sub.{0} empty))  := sorry --non-trivial
lemma new_lemma_106901 (h0 : group (with_bot (has_top to_additive.value_type))) : normalizer_condition (with_bot (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_106902 (h0 : complete_lattice (has_add ennreal)) : is_atomistic (has_add ennreal) := sorry --non-trivial
lemma new_lemma_106903 (h0 : functor.add_const (function.extfun Type list) (has_Inf pos)) : palindrome (function.extfun_app (functor.add_const.run h0) (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_106904 (h0 : semiring (add_comm_semigroup (add_comm_semigroup enat))) (h2 : add_comm_semigroup (add_comm_semigroup enat)) : even h2 := sorry --non-trivial
lemma new_lemma_106905 (h0 : topological_space (complete_distrib_lattice (sub_neg_monoid real))) : irreducible_space (complete_distrib_lattice (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_106906 (h0 : function.extfun Type (functor.comp ring semigroup)) : @rank_condition.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} ring.{0} semigroup.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} semigroup.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_106907 (h0 : ring (preorder (semiring num))) : is_principal_ideal_ring (preorder (semiring num)) := sorry --non-trivial
lemma new_lemma_106908 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} string_imp (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) string_imp)  := sorry --non-trivial
lemma new_lemma_106909 (h0 : function.extfun Type (functor.add_const (topological_space (simple_graph linarith.comp)))) : @locally_compact_space.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} linarith.comp)) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (simple_graph.{0} linarith.comp))) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_106910 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @complete_space.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) uniform_space.{0}) (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_106911 (h0 : group (has_nndist (add_comm_monoid Type))) : normalizer_condition (has_nndist (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_106912 (h0 : functor.add_const (functor.add_const (topological_space name) num) num) : @t0_space.{0} name (@functor.add_const.run.{0 0} (topological_space.{0} name) num (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} name) num) num h0))  := sorry --non-trivial
lemma new_lemma_106913 (h0 : set (has_ssubset string.iterator_imp)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_106914 (h0 : topological_space (has_ssubset (random_gen to_additive.value_type))) : totally_disconnected_space (has_ssubset (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_106915 (h0 : ordered_comm_monoid (linear_ordered_field name)) : has_exists_mul_of_le (linear_ordered_field name) := sorry --non-trivial
lemma new_lemma_106916 (h0 : topological_space (linear_ordered_comm_ring unsigned)) : irreducible_space (linear_ordered_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_106917 (h0 : functor.add_const (ring (semigroup Type)) linarith.comp) : @strong_rank_condition.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (semigroup.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_106918 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_edist.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_edist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_106919 (h0 : add_monoid (normed_lattice_add_comm_group name)) : add_monoid.fg (normed_lattice_add_comm_group name) := sorry --non-trivial
lemma new_lemma_106920 (h0 : topological_space (boolean_algebra (boolean_algebra Type))) : discrete_topology (boolean_algebra (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_106921 (h0 : has_mem.mem (id (semiring empty)) has_emptyc.emptyc) : @irreducible_space.{0} (@id.{2} Type (semiring.{0} empty)) (@finset.pi.empty.{1 0} Type topological_space.{0} (@id.{2} Type (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_106922 (h0 : complete_lattice (cancel_monoid ennreal)) : is_compactly_generated (cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_106923 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_106924 (h0 : complete_lattice (normed_comm_ring congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (normed_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_106925 (h0 : functor.add_const (group (boolean_algebra Type)) name) : @normalizer_condition.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (boolean_algebra.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_106926 (h0 : function.extfun (finset Type) (has_mem.mem (with_one linarith.ineq))) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} linarith.ineq)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_106927 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (add_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_106928 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group empty))) : @normalizer_condition.{0} (normed_group.{0} empty) (@finset.pi.empty.{1 0} Type group.{0} (normed_group.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_106929 (h0 : topological_space (plift (semiring (semiring (semiring (semiring num)))))) : discrete_topology (plift (semiring (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_106930 (h0 : topological_space (normed_group (random_gen linarith.comp_source))) : t0_space (normed_group (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_106931 (h0 : finset (has_to_string (has_add Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_106932 (h0 : topological_space (denumerable (random_gen linarith.comp_source))) : totally_separated_space (denumerable (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_106933 (h0 : ring (boolean_algebra (has_pos_part Type))) : rank_condition (boolean_algebra (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_106934 (h0 : ring (complete_linear_order string_imp)) : is_domain (complete_linear_order string_imp) := sorry --non-trivial
lemma new_lemma_106935 (h0 : filter (has_top to_additive.value_type)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_106936 (h0 : functor.add_const (topological_space (sub_neg_monoid pos)) name) : @discrete_topology.{0} (sub_neg_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (sub_neg_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_106937 (h0 : topological_space (non_unital_non_assoc_semiring linarith.ineq)) (h1 : preorder (non_unital_non_assoc_semiring linarith.ineq)) : order_topology (non_unital_non_assoc_semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_106938 (h0 : topological_space (metric_space unsigned)) : path_connected_space (metric_space unsigned) := sorry --non-trivial
lemma new_lemma_106939 (h1 : not (complete_lattice (random_gen reducibility_hints) -> false)) : @is_compactly_generated.{0} (random_gen.{0} reducibility_hints) (@classical.by_contradiction'.{1} (complete_lattice.{0} (random_gen.{0} reducibility_hints)) h1)  := sorry --non-trivial
lemma new_lemma_106940 (h0 : add_group (finset (ring Type))) : is_add_cyclic (finset (ring Type)) := sorry --non-trivial
lemma new_lemma_106941 (h0 : add_group (has_to_string (add_cancel_monoid (boolean_algebra (has_add name))))) : is_add_cyclic (has_to_string (add_cancel_monoid (boolean_algebra (has_add name)))) := sorry --non-trivial
lemma new_lemma_106942 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_106943 (h0 : complete_lattice (has_bot num)) : is_compactly_generated (has_bot num) := sorry --non-trivial
lemma new_lemma_106944 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) auto.case_option) := sorry --non-trivial
lemma new_lemma_106945 (h0 : complete_lattice (plift empty)) : complete_lattice.is_Sup_finite_compact (plift empty) := sorry --non-trivial
lemma new_lemma_106946 (h0 : function.extfun Type (functor.add_const (topological_space (comm_monoid empty)))) : @t0_space.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (comm_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_106947 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_106948 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_star.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (has_star.{0} num))  := sorry --non-trivial
lemma new_lemma_106949 (h0 : topological_space (has_pos_part (has_neg pos))) : discrete_topology (has_pos_part (has_neg pos)) := sorry --non-trivial
lemma new_lemma_106950 (h0 : ring (linear_ordered_comm_group (option ennreal))) : is_principal_ideal_ring (linear_ordered_comm_group (option ennreal)) := sorry --non-trivial
lemma new_lemma_106951 (h0 : filter (dlist (add_left_cancel_monoid linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_106952 (h0 : topological_space (has_compl (random_gen linarith.ineq))) : locally_compact_space (has_compl (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_106953 (h0 : topological_space (has_inv linarith.ineq)) : locally_compact_space (has_inv linarith.ineq) := sorry --non-trivial
lemma new_lemma_106954 (h0 : functor.add_const (topological_space (semigroup pos)) (finset environment.implicit_infer_kind)) : @locally_compact_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_106955 (h0 : group (metric_space (semiring (semiring (semiring linarith.comp))))) : normalizer_condition (metric_space (semiring (semiring (semiring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_106956 (h0 : complete_lattice (comm_semigroup (sub_neg_monoid real))) : is_compactly_generated (comm_semigroup (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_106957 (h0 : has_lt (mul_one_class (mul_one_class (mul_one_class ereal)))) : no_max_order (mul_one_class (mul_one_class (mul_one_class ereal))) := sorry --non-trivial
lemma new_lemma_106958 (h0 : function.extfun Type ring) : @rank_condition.{0} (canonically_ordered_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_106959 (h0 : topological_space (has_lt (mul_one_class std_gen))) : path_connected_space (has_lt (mul_one_class std_gen)) := sorry --non-trivial
lemma new_lemma_106960 (h0 : functor.add_const (topological_space (finset linarith.comp)) (has_Inf (has_neg (has_add pos)))) : @normal_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) (has_Inf.{0} (has_neg.{0} (has_add.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_106961 (h0 : semiring (mul_zero_class (finset name))) : is_noetherian_ring (mul_zero_class (finset name)) := sorry --non-trivial
lemma new_lemma_106962 (h0 : ring (generalized_boolean_algebra (has_pos_part pos))) : rank_condition (generalized_boolean_algebra (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_106963 (h0 : group (dlist (linear_ordered_add_comm_group (has_top (denumerable fun_info))))) : is_cyclic (dlist (linear_ordered_add_comm_group (has_top (denumerable fun_info)))) := sorry --non-trivial
lemma new_lemma_106964 (h0 : topological_space (ordered_comm_ring (has_add real))) : preirreducible_space (ordered_comm_ring (has_add real)) := sorry --non-trivial
lemma new_lemma_106965 (h0 : group (has_add (option (option pos)))) : group.fg (has_add (option (option pos))) := sorry --non-trivial
lemma new_lemma_106966 (h0 : functor.add_const (ring (cancel_monoid Type)) (normed_comm_ring environment.implicit_infer_kind)) : @strong_rank_condition.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (cancel_monoid.{1} Type)) (normed_comm_ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_106967 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) linarith.comp) : @path_connected_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_106968 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} string_imp (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) string_imp)  := sorry --non-trivial
lemma new_lemma_106969 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (linear_ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (linear_ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_106970 (h0 : functor.add_const (topological_space (bin_tree num)) (semiring (semiring congr_arg_kind))) : @topological_space.separable_space.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} num)) (semiring.{0} (semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_106971 (h0 : topological_space (has_neg (cancel_monoid Type))) : path_connected_space (has_neg (cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_106972 (h0 : add_group (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup linarith.ineq)))) : is_add_cyclic (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup linarith.ineq))) := sorry --non-trivial
lemma new_lemma_106973 (h0 : ring (with_top ereal)) : is_domain (with_top ereal) := sorry --non-trivial
lemma new_lemma_106974 (h0 : functor.add_const (semiring (left_cancel_semigroup num)) unsigned) : @is_noetherian_ring.{0} (left_cancel_semigroup.{0} num) (@functor.add_const.run.{0 0} (semiring.{0} (left_cancel_semigroup.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_106975 (h0 : uniform_space (cancel_monoid (option (option pos)))) : separated_space (cancel_monoid (option (option pos))) := sorry --non-trivial
lemma new_lemma_106976 (h0 : group (add_cancel_monoid (add_cancel_monoid pos))) : is_cyclic (add_cancel_monoid (add_cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_106977 (h0 : has_mem.mem group has_emptyc.emptyc) : @group.fg.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_106978 (h0 : functor.add_const (group (add_comm_monoid empty)) (option num)) : @normalizer_condition.{0} (add_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (add_comm_monoid.{0} empty)) (option.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_106979 (h0 : group (has_norm (semiring (semiring empty)))) : is_cyclic (has_norm (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_106980 (h0 : functor.add_const (topological_space (has_bot empty)) empty) : @locally_compact_space.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_106981 (h0 : functor.add_const (group ennreal) ennreal) : @group.fg.{0} ennreal (@functor.add_const.run.{0 0} (group.{0} ennreal) ennreal h0)  := sorry --non-trivial
lemma new_lemma_106982 (h1 : has_lt (has_div char)) : no_max_order (has_div char) := sorry --non-trivial
lemma new_lemma_106983 (h0 : group (comm_ring (random_gen (has_nnnorm to_additive.value_type)))) : group.fg (comm_ring (random_gen (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_106984 (h0 : functor.comp list mul_zero_class name) : palindrome (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_106985 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring environment.implicit_infer_kind)) pos) : @path_connected_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_106986 (h0 : not (ring (denumerable reducibility_hints) -> false)) : @is_domain.{0} (denumerable.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (denumerable.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_106987 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) name) : @has_exists_mul_of_le.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) name h0) (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_106988 (h1 : ring (semi_normed_comm_ring (random_gen string_imp))) : is_domain (semi_normed_comm_ring (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_106989 (h0 : uniform_space (ordered_ring (option empty))) : separated_space (ordered_ring (option empty)) := sorry --non-trivial
lemma new_lemma_106990 (h0 : functor.add_const (topological_space (finset Type)) unsigned) : @regular_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_106991 (h0 : group (normed_field (has_nnnorm (has_nnnorm (has_nnnorm (denumerable linarith.ineq)))))) : is_cyclic (normed_field (has_nnnorm (has_nnnorm (has_nnnorm (denumerable linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_106992 (h0 : ring (linear_ordered_comm_group_with_zero linarith.ineq)) : strong_rank_condition (linear_ordered_comm_group_with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_106993 (h0 : topological_space (has_emptyc (random_gen (has_top to_additive.value_type)))) : path_connected_space (has_emptyc (random_gen (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_106994 (h0 : complete_lattice (bin_tree unsigned)) : complete_lattice.is_Sup_finite_compact (bin_tree unsigned) := sorry --non-trivial
lemma new_lemma_106995 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_106996 (h0 : topological_space (finset (comm_group name))) : regular_space (finset (comm_group name)) := sorry --non-trivial
lemma new_lemma_106997 (h0 : functor.add_const (functor.add_const (complete_lattice (has_neg unsigned)) pos) pos) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg.{0} unsigned)) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (complete_lattice.{0} (has_neg.{0} unsigned)) pos) pos h0))  := sorry --non-trivial
lemma new_lemma_106998 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_106999 (h0 : filter (has_zero (comm_group Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_107000 (h0 : functor.add_const (function.extfun Type topological_space) (has_neg (ring (ring pos)))) : @loc_path_connected_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_neg.{0} (ring.{0} (ring.{0} pos))) h0) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_107001 (h0 : complete_lattice (ring (has_add linarith.comp))) : is_atomistic (ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_107002 (h0 : topological_space (add_comm_monoid real)) : preconnected_space (add_comm_monoid real) := sorry --non-trivial
lemma new_lemma_107003 (h0 : functor.add_const (ring (finset unsigned)) environment.implicit_infer_kind) : @rank_condition.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_107004 (h0 : functor.add_const (functor.add_const (topological_space pos) ennreal) Type) : @path_connected_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) ennreal (@functor.add_const.run.{0 1} (functor.add_const.{0 0} (topological_space.{0} pos) ennreal) Type h0))  := sorry --non-trivial
lemma new_lemma_107005 (h0 : filter (has_compl (random_gen linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_107006 (h0 : function.extfun Type (functor.add_const (complete_lattice linarith.comp))) : @is_compactly_generated.{0} linarith.comp (@functor.add_const.run.{0 0} (complete_lattice.{0} linarith.comp) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} linarith.comp)) h0 pos))  := sorry --non-trivial
lemma new_lemma_107007 (h1 : uniform_space (add_left_cancel_monoid linarith.ineq)) : complete_space (add_left_cancel_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_107008 (h0 : list (has_neg (finset linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_107009 (h0 : prod (has_zero unsigned) (has_zero unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_107010 (h0 : finset (has_nndist (option (has_add name)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_107011 (h0 : monoid (linear_ordered_comm_ring (semiring (semiring unsigned)))) : monoid.fg (linear_ordered_comm_ring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_107012 (h0 : complete_lattice (has_le string.iterator_imp)) : complete_lattice.is_Sup_finite_compact (has_le string.iterator_imp) := sorry --non-trivial
lemma new_lemma_107013 (h0 : not (filter (random_gen to_additive.value_type) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_107014 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) (has_add name)) : @totally_disconnected_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_107015 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (dlist.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (dlist.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_107016 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_107017 (h0 : topological_space (has_zero (has_to_string ennreal))) : topological_space.separable_space (has_zero (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_107018 (h0 : list (boolean_algebra Type)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_107019 (h1 : add_group (mul_one_class fun_info)) : is_add_cyclic (mul_one_class fun_info) := sorry --non-trivial
lemma new_lemma_107020 (h0 : functor.add_const (ring (has_to_string name)) linarith.comp) : @is_principal_ideal_ring.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_107021 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (canonically_ordered_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_107022 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_add_cyclic.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (add_group.{1} (has_bot.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_107023 (h0 : not (uniform_space (measurable_space.dynkin_system empty) -> false)) : @complete_space.{0} (measurable_space.dynkin_system.{0} empty) (@classical.by_contradiction'.{1} (uniform_space.{0} (measurable_space.dynkin_system.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_107024 (h0 : functor.add_const (group (preorder num)) unsigned) : @is_cyclic.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (group.{0} (preorder.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_107025 (h0 : add_group (distrib (has_nnnorm linarith.ineq))) : is_add_cyclic (distrib (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_107026 (h0 : topological_space (plift (semiring num))) : totally_disconnected_space (plift (semiring num)) := sorry --non-trivial
lemma new_lemma_107027 (h0 : topological_space (has_to_string (add_comm_monoid environment.implicit_infer_kind))) : preconnected_space (has_to_string (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_107028 (h0 : semiring (semigroup (mul_one_class (has_neg linarith.comp)))) : is_noetherian_ring (semigroup (mul_one_class (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_107029 (h0 : topological_space (has_nndist (finset (finset (finset Type))))) : preconnected_space (has_nndist (finset (finset (finset Type)))) := sorry --non-trivial
lemma new_lemma_107030 (h0 : linarith.ineq -> linarith.ineq -> linarith.ineq) : is_idempotent linarith.ineq h0 := sorry --non-trivial
lemma new_lemma_107031 (h0 : not (topological_space (plift num) -> false)) : @topological_space.separable_space.{1} (plift.{1} num) (@classical.by_contradiction'.{2} (topological_space.{1} (plift.{1} num)) h0)  := sorry --non-trivial
lemma new_lemma_107032 (h0 : functor.add_const (filter pos) environment.implicit_infer_kind) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_107033 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_107034 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_107035 (h1 : finset to_additive.value_type) (h2 : finset.nonempty h1) (h3 : to_additive.value_type -> topological_space (random_gen (random_gen (random_gen char)))) : @t0_space.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} char))) (@finset.sup'.{0 0} (topological_space.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} char)))) to_additive.value_type (@lattice.to_semilattice_sup.{0} (topological_space.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} char)))) (@conditionally_complete_lattice.to_lattice.{0} (topological_space.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} char)))) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} char)))) (@topological_space.complete_lattice.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} char))))))) h1 h2 h3)  := sorry --non-trivial
lemma new_lemma_107036 (h0 : ring (dlist (div_inv_monoid fun_info))) : strong_rank_condition (dlist (div_inv_monoid fun_info)) := sorry --non-trivial
lemma new_lemma_107037 (h0 : functor.add_const (ordered_comm_monoid (has_nndist name)) (has_neg_part pos)) : @has_exists_mul_of_le.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_nndist.{0} name)) (has_neg_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_107038 (h0 : uniform_space (has_pos_part real)) : complete_space (has_pos_part real) := sorry --non-trivial
lemma new_lemma_107039 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_107040 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_neg_part.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_107041 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (pseudo_metric_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_107042 (h0 : list (normed_comm_ring (has_neg Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_107043 (h0 : complete_lattice (has_one (semiring linarith.comp))) : complete_lattice.is_Sup_finite_compact (has_one (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_107044 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (with_bot.{0} (comm_ring.{0} (denumerable.{0} (has_inv.{0} (comm_ring.{0} linarith.ineq))))) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (with_bot.{0} (comm_ring.{0} (denumerable.{0} (has_inv.{0} (comm_ring.{0} linarith.ineq))))))  := sorry --non-trivial
lemma new_lemma_107045 (h0 : topological_space (has_append (random_gen linarith.comp_source))) : path_connected_space (has_append (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_107046 (h0 : functor.add_const (semiring (comm_group Type)) name) : @is_noetherian_ring.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (comm_group.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_107047 (h0 : group (linear_ordered_semiring num)) : is_cyclic (linear_ordered_semiring num) := sorry --non-trivial
lemma new_lemma_107048 (h0 : add_monoid (has_zero environment.implicit_infer_kind)) : add_monoid.fg (has_zero environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_107049 (h0 : topological_space (add_comm_semigroup (mul_one_class (add_comm_semigroup fun_info)))) : t0_space (add_comm_semigroup (mul_one_class (add_comm_semigroup fun_info))) := sorry --non-trivial
lemma new_lemma_107050 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (ordered_ring.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ordered_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_107051 (h0 : topological_space (option (option (option (finset pos))))) : loc_path_connected_space (option (option (option (finset pos)))) := sorry --non-trivial
lemma new_lemma_107052 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) name) : @t0_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_107053 (h0 : topological_space (measurable_space (has_top linarith.ineq))) : locally_compact_space (measurable_space (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_107054 (h1 : function.extfun (finset (Type -> Type)) (has_mem.mem add_group)) : @is_add_cyclic.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_group.{0}) h1 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_107055 (h0 : Prop) (h1 : ereal) (h2 : set ereal) : xor h0 (set.mem h1 h2) := sorry --non-trivial
lemma new_lemma_107056 (h0 : group (has_add char)) : is_cyclic (has_add char) := sorry --non-trivial
lemma new_lemma_107057 (h0 : semiring (canonically_ordered_monoid (has_Inf name))) : is_noetherian_ring (canonically_ordered_monoid (has_Inf name)) := sorry --non-trivial
lemma new_lemma_107058 (h0 : topological_space (add_right_cancel_monoid unsigned)) : irreducible_space (add_right_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_107059 (h0 : function.extfun nat fin) : @complete_space.{0} (has_pos_part.{0} real) (@matrix.vec_empty.{0} (uniform_space.{0} (has_pos_part.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_107060 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (denumerable.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (denumerable.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_107061 (h0 : add_monoid (has_sdiff unsigned)) : add_monoid.fg (has_sdiff unsigned) := sorry --non-trivial
lemma new_lemma_107062 (h0 : functor.add_const (topological_space (complete_linear_order empty)) num) : @t1_space.{0} (complete_linear_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_linear_order.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_107063 (h0 : function.extfun Type topological_space) : @t0_space.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_107064 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_107065 (h0 : not (group (has_star unsigned) -> false)) : @normalizer_condition.{0} (has_star.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (has_star.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_107066 (h0 : topological_space (has_emptyc (has_top congr_arg_kind))) : path_connected_space (has_emptyc (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_107067 (h1 : topological_space (has_compl linarith.comp_source)) : t0_space (has_compl linarith.comp_source) := sorry --non-trivial
lemma new_lemma_107068 (h0 : topological_space (has_zero (option unsigned))) : loc_path_connected_space (has_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_107069 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @t0_space.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_107070 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @discrete_topology.{0} (has_emptyc.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_emptyc.{0} empty))  := sorry --non-trivial
lemma new_lemma_107071 (h1 : topological_space (has_nnnorm (has_ssubset (random_gen string_imp)))) : t0_space (has_nnnorm (has_ssubset (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_107072 (h0 : has_mem.mem linarith.comp_source has_emptyc.emptyc) : @totally_disconnected_space.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type topological_space.{0} linarith.comp_source h0)  := sorry --non-trivial
lemma new_lemma_107073 (h1 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_107074 (h0 : topological_space (has_add (has_neg (has_neg pos)))) : topological_space.separable_space (has_add (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_107075 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) name) : @archimedean.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) name h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_107076 (h0 : topological_space (linear_ordered_semiring (random_gen (random_gen (random_gen fun_info))))) : discrete_topology (linear_ordered_semiring (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_107077 (h0 : topological_space (boolean_algebra.core (ring Type))) : topological_space.separable_space (boolean_algebra.core (ring Type)) := sorry --non-trivial
lemma new_lemma_107078 (h0 : ring (add_comm_monoid (has_neg (finset environment.implicit_infer_kind)))) : is_principal_ideal_ring (add_comm_monoid (has_neg (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_107079 (h0 : linarith.ineq -> linarith.ineq -> Prop) : is_symm linarith.ineq h0 := sorry --non-trivial
lemma new_lemma_107080 (h0 : topological_space (has_Inf (has_pos_part linarith.comp))) : regular_space (has_Inf (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_107081 (h0 : monoid (measurable_space (random_gen (has_inv linarith.ineq)))) : monoid.fg (measurable_space (random_gen (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_107082 (h0 : ring (ordered_comm_semiring reducibility_hints)) : strong_rank_condition (ordered_comm_semiring reducibility_hints) := sorry --non-trivial
lemma new_lemma_107083 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) linarith.comp) : @discrete_topology.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_107084 (h0 : ring (semigroup (has_add pos))) : strong_rank_condition (semigroup (has_add pos)) := sorry --non-trivial
lemma new_lemma_107085 (h1 : has_lt (mul_one_class (normed_field enat))) : no_max_order (mul_one_class (normed_field enat)) := sorry --non-trivial
lemma new_lemma_107086 (h0 : group (with_one (has_norm empty))) : group.fg (with_one (has_norm empty)) := sorry --non-trivial
lemma new_lemma_107087 (h0 : ring (canonically_ordered_monoid Type)) : is_principal_ideal_ring (canonically_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_107088 (h0 : function.extfun (Type 1) topological_space) : @totally_separated_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 Type)  := sorry --non-trivial
lemma new_lemma_107089 (h0 : functor.comp topological_space normed_comm_ring name) : @loc_path_connected_space.{0} (normed_comm_ring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} normed_comm_ring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_107090 (h0 : not (topological_space (plift unsigned) -> false)) : @t0_space.{1} (plift.{1} unsigned) (@classical.by_contradiction'.{2} (topological_space.{1} (plift.{1} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_107091 (h0 : function.extfun (Type 1) topological_space) : @preconnected_space.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_107092 (h2 : topological_space (add_cancel_comm_monoid to_additive.value_type)) : totally_disconnected_space (add_cancel_comm_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_107093 (h0 : uniform_space (topological_space (has_nnnorm (has_top (denumerable char))))) : complete_space (topological_space (has_nnnorm (has_top (denumerable char)))) := sorry --non-trivial
lemma new_lemma_107094 (h0 : function.extfun Type topological_space) : @t0_space.{0} (dlist.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (dlist.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_107095 (h0 : list (measurable_space.dynkin_system empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_107096 (h0 : functor.add_const (function.extfun Type monoid) Type) : @monoid.fg.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type monoid.{0}) Type h0) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_107097 (h0 : finset (boolean_algebra (finset (finset (finset pos))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_107098 (h0 : complete_lattice (id empty)) : is_atomistic (id empty) := sorry --non-trivial
lemma new_lemma_107099 (h0 : uniform_space (div_inv_monoid (has_nnnorm linarith.ineq))) : complete_space (div_inv_monoid (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_107100 (h0 : functor.add_const (topological_space (semigroup name)) Type) : @topological_space.separable_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_107101 (h0 : topological_space (has_neg (semigroup environment.implicit_infer_kind))) : irreducible_space (has_neg (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_107102 (h0 : function.extfun Type (prod (linear_ordered_semiring num))) : id_rel (function.extfun_app h0 (linear_ordered_semiring num)) := sorry --non-trivial
lemma new_lemma_107103 (h0 : topological_space (normed_group (has_top (has_top congr_arg_kind)))) : irreducible_space (normed_group (has_top (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_107104 (h0 : monoid (measure_theory.measure_space (has_top unsigned))) : monoid.fg (measure_theory.measure_space (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_107105 (h0 : topological_space (left_cancel_monoid empty)) : totally_separated_space (left_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_107106 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_107107 (h0 : add_monoid (has_dist unsigned)) : add_monoid.fg (has_dist unsigned) := sorry --non-trivial
lemma new_lemma_107108 (h0 : topological_space (has_bot (has_neg (has_neg (has_neg (has_neg (has_neg (has_neg name)))))))) : preconnected_space (has_bot (has_neg (has_neg (has_neg (has_neg (has_neg (has_neg name))))))) := sorry --non-trivial
lemma new_lemma_107109 (h0 : functor.add_const (topological_space (has_to_string pos)) pos) : @topological_space.separable_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_107110 (h1 : topological_space (topological_space string_imp)) : totally_disconnected_space (topological_space string_imp) := sorry --non-trivial
lemma new_lemma_107111 (h0 : semiring (has_nndist (finset (has_Inf linarith.comp)))) : is_noetherian_ring (has_nndist (finset (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_107112 (h0 : uniform_space (pseudo_metric_space (option (option (option (option empty)))))) : complete_space (pseudo_metric_space (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_107113 (h0 : complete_lattice (semiring (has_one num))) : complete_lattice.is_Sup_finite_compact (semiring (has_one num)) := sorry --non-trivial
lemma new_lemma_107114 (h0 : not (function.extfun Type topological_space -> false)) : @t1_space.{0} (measure_theory.measure_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measure_theory.measure_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_107115 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_107116 (h0 : ring (has_Sup (option unsigned))) : rank_condition (has_Sup (option unsigned)) := sorry --non-trivial
lemma new_lemma_107117 (h1 : uniform_space (has_norm string_imp)) : complete_space (has_norm string_imp) := sorry --non-trivial
lemma new_lemma_107118 (h0 : not (ring (with_one fun_info) -> false)) : @rank_condition.{0} (with_one.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (with_one.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_107119 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (pseudo_metric_space.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (pseudo_metric_space.{0} name))  := sorry --non-trivial
lemma new_lemma_107120 (h2 : add_group (non_unital_non_assoc_semiring string.iterator_imp)) : is_add_cyclic (non_unital_non_assoc_semiring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_107121 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (as_linear_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (as_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_107122 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_107123 (h0 : functor.add_const (topological_space (has_add pos)) linarith.comp) : @preconnected_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_107124 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (distrib_lattice linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_107125 (h0 : function.extfun Type topological_space) : @t1_space.{0} (pseudo_metric_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_107126 (h1 : not (ring (denumerable char) -> false)) : @rank_condition.{0} (denumerable.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (denumerable.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_107127 (h0 : add_group (has_nndist (ring Type))) : is_add_cyclic (has_nndist (ring Type)) := sorry --non-trivial
lemma new_lemma_107128 (h1 : complete_lattice (distrib_lattice (random_gen to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (distrib_lattice (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_107129 (h0 : measurable_space std_gen) (h1 : measure_theory.measure std_gen) : measure_theory.measure.is_complete h1 := sorry --non-trivial
lemma new_lemma_107130 (h0 : functor.add_const (topological_space (has_neg pos)) (has_neg (has_nndist (ring linarith.comp)))) : @preconnected_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) (has_neg.{0} (has_nndist.{0} (ring.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_107131 (h0 : complete_lattice (has_one congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (has_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_107132 (h0 : monoid_with_zero (add_comm_monoid (option ennreal)) -> monoid_with_zero (add_comm_monoid (option ennreal)) -> Prop) : is_symm (monoid_with_zero (add_comm_monoid (option ennreal))) h0 := sorry --non-trivial
lemma new_lemma_107133 (h0 : list (free_add_monoid (option unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_107134 (h0 : functor.add_const (filter (normed_comm_ring Type)) unsigned) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_107135 (h0 : monoid (linear_ordered_semiring linarith.ineq)) : monoid.fg (linear_ordered_semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_107136 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_107137 (h0 : not (topological_space (semiring (has_norm linarith.comp_source)) -> false)) : @irreducible_space.{0} (semiring.{0} (has_norm.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} (has_norm.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_107138 (h0 : semiring (has_Inf (has_Inf (has_pos_part (has_add (has_Inf Type)))))) : is_noetherian_ring (has_Inf (has_Inf (has_pos_part (has_add (has_Inf Type))))) := sorry --non-trivial
lemma new_lemma_107139 (h0 : ordered_comm_monoid (comm_semigroup name)) : has_exists_mul_of_le (comm_semigroup name) := sorry --non-trivial
lemma new_lemma_107140 (h0 : functor.add_const (monoid znum) empty) : @monoid.fg.{0} znum (@functor.add_const.run.{0 0} (monoid.{0} znum) empty h0)  := sorry --non-trivial
lemma new_lemma_107141 (h0 : topological_space (mul_zero_class (finset name))) : totally_separated_space (mul_zero_class (finset name)) := sorry --non-trivial
lemma new_lemma_107142 (h0 : complete_lattice (has_append char)) : is_compactly_generated (has_append char) := sorry --non-trivial
lemma new_lemma_107143 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) environment.implicit_infer_kind) : @is_compactly_generated.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) environment.implicit_infer_kind h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_107144 (h0 : fin has_zero.zero) : @sequential_space.{0} (add_comm_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))))  := sorry --non-trivial
lemma new_lemma_107145 (h0 : topological_space (has_compl environment.projection_info)) : path_connected_space (has_compl environment.projection_info) := sorry --non-trivial
lemma new_lemma_107146 (h0 : function.extfun Type topological_space) : @t1_space.{0} (linear_ordered_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_107147 (h0 : function.extfun Type (functor.add_const (ring (left_cancel_monoid unsigned)))) : @is_principal_ideal_ring.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} unsigned)) (option.{0} unsigned) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (left_cancel_monoid.{0} unsigned))) h0 (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_107148 (h0 : ring (comm_semigroup pos)) : rank_condition (comm_semigroup pos) := sorry --non-trivial
lemma new_lemma_107149 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_107150 (h0 : topological_space (has_append linarith.ineq)) : totally_disconnected_space (has_append linarith.ineq) := sorry --non-trivial
lemma new_lemma_107151 (h0 : topological_space (omega_complete_partial_order empty)) : discrete_topology (omega_complete_partial_order empty) := sorry --non-trivial
lemma new_lemma_107152 (h0 : group (dlist (has_nnnorm fun_info))) : is_cyclic (dlist (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_107153 (h0 : functor.add_const (ring (mul_zero_class num)) empty) : @is_principal_ideal_ring.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (mul_zero_class.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_107154 (h0 : functor.add_const (topological_space (boolean_algebra pos)) environment.implicit_infer_kind) : @regular_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_107155 (h0 : functor.add_const (uniform_space (left_cancel_monoid unsigned)) unsigned) : @separated_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (left_cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_107156 (h0 : set (add_comm_semigroup ereal -> nondiscrete_normed_field enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_107157 (h1 : group linarith.comp) : is_cyclic linarith.comp := sorry --non-trivial
lemma new_lemma_107158 (h0 : group (has_nnnorm (has_nnnorm (has_top (has_nnnorm to_additive.value_type))))) : group.fg (has_nnnorm (has_nnnorm (has_top (has_nnnorm to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_107159 (h0 : group (complete_semilattice_Sup empty)) : normalizer_condition (complete_semilattice_Sup empty) := sorry --non-trivial
lemma new_lemma_107160 (h0 : function.extfun Type (functor.add_const (topological_space auto.case_option))) : @topological_space.separable_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} auto.case_option)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_107161 (h0 : functor.add_const (topological_space (has_add pos)) environment.implicit_infer_kind) : @locally_compact_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_107162 (h1 : function.extfun Type topological_space) : @irreducible_space.{0} to_additive.value_type (@function.extfun_app.{2 1} Type topological_space.{0} h1 to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_107163 (h2 : measurable_space to_additive.value_type) (h3 : filter to_additive.value_type) : filter.is_measurably_generated h3 := sorry --non-trivial
lemma new_lemma_107164 (h0 : group (free_add_monoid (linear_ordered_cancel_comm_monoid unsigned))) : normalizer_condition (free_add_monoid (linear_ordered_cancel_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_107165 (h0 : group (with_zero (has_nnnorm to_additive.value_type))) : group.fg (with_zero (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_107166 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_107167 (h0 : topological_space (add_cancel_monoid (add_cancel_monoid unsigned))) : path_connected_space (add_cancel_monoid (add_cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_107168 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_compactly_generated.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 complete_lattice.{1}) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_107169 (h0 : topological_space (option (semiring (semiring num)))) : totally_separated_space (option (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_107170 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_107171 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (finset empty)) := sorry --non-trivial
lemma new_lemma_107172 (h1 : not (ring (has_union empty) -> false)) : @rank_condition.{0} (has_union.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (has_union.{0} empty)) h1)  := sorry --non-trivial
lemma new_lemma_107173 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_107174 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_107175 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_107176 (h0 : functor.comp cancel_comm_monoid_with_zero has_to_string name) : @unique_factorization_monoid.{0} (has_to_string.{0} name) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_to_string.{0} name h0)  := sorry --non-trivial
lemma new_lemma_107177 (h0 : ring (has_neg_part (has_add environment.implicit_infer_kind))) : is_domain (has_neg_part (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_107178 (h0 : topological_space (canonically_ordered_monoid (has_Inf (has_add pos)))) : loc_path_connected_space (canonically_ordered_monoid (has_Inf (has_add pos))) := sorry --non-trivial
lemma new_lemma_107179 (h0 : prod (option empty) (option empty)) : set.diagonal (option empty) h0 := sorry --non-trivial
lemma new_lemma_107180 (h0 : function.extfun Type (functor.add_const (list name))) : list.nodup (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_107181 (h0 : functor.comp topological_space comm_group Type) : @loc_path_connected_space.{1} (comm_group.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} comm_group.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_107182 (h0 : functor.add_const (add_monoid (has_neg unsigned)) Type) : @add_monoid.fg.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 1} (add_monoid.{0} (has_neg.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_107183 (h0 : topological_space (finset (has_nndist environment.implicit_infer_kind))) : normal_space (finset (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_107184 (h0 : functor.add_const (uniform_space (finset Type)) (finset pos)) : @complete_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (finset.{1} Type)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_107185 (h0 : topological_space (has_emptyc (has_top linarith.comp_source))) : totally_separated_space (has_emptyc (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_107186 (h0 : ring (ordered_comm_semiring to_additive.value_type)) : strong_rank_condition (ordered_comm_semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_107187 (h0 : group (boolean_algebra.core (has_Inf (has_Inf Type)))) : is_cyclic (boolean_algebra.core (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_107188 (h0 : ring (has_append reducibility_hints)) : is_domain (has_append reducibility_hints) := sorry --non-trivial
lemma new_lemma_107189 (h0 : topological_space (has_add (finset (ring pos)))) : irreducible_space (has_add (finset (ring pos))) := sorry --non-trivial
lemma new_lemma_107190 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (linear_ordered_add_comm_group.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} h0 (linear_ordered_add_comm_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_107191 (h0 : add_monoid (ring unsigned)) : add_monoid.fg (ring unsigned) := sorry --non-trivial
lemma new_lemma_107192 (h0 h1 : pnat) : pnat.coprime (id h0) (id h1) := sorry --non-trivial
lemma new_lemma_107193 (h0 : topological_space (linear_ordered_semiring (has_top unsigned))) : totally_separated_space (linear_ordered_semiring (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_107194 (h0 : uniform_space (has_norm (has_norm congr_arg_kind))) : separated_space (has_norm (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_107195 (h0 : ordered_add_comm_monoid (has_Inf (has_neg real))) : archimedean (has_Inf (has_neg real)) := sorry --non-trivial
lemma new_lemma_107196 (h0 : function.extfun (Type 1) add_monoid) : @add_monoid.fg.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} h0 (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_107197 (h0 : uniform_space (cancel_monoid (has_add pos))) : separated_space (cancel_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_107198 (h0 : complete_lattice (with_one (has_norm linarith.comp))) : is_atomistic (with_one (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_107199 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (canonically_linear_ordered_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (canonically_linear_ordered_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_107200 (h0 : not (cancel_comm_monoid_with_zero (has_star congr_arg_kind) -> false)) : @unique_factorization_monoid.{0} (has_star.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (has_star.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_107201 (h0 : functor.add_const (topological_space (cancel_monoid name)) environment.implicit_infer_kind) : @discrete_topology.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_107202 (h0 : function.extfun Type ring) : @rank_condition.{0} (metric_space.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (metric_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_107203 (h0 : group (option name)) : is_cyclic (option name) := sorry --non-trivial
lemma new_lemma_107204 (h0 : functor.comp ordered_add_comm_monoid has_to_string Type) : @archimedean.{1} (has_to_string.{1} Type) (@functor.comp.run.{1 1 1} ordered_add_comm_monoid.{1} has_to_string.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_107205 (h0 : ring (linear_ordered_comm_group congr_arg_kind)) : is_domain (linear_ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_107206 (h0 : monoid (with_one (random_gen (random_gen (random_gen (comm_ring linarith.comp_source)))))) : monoid.fg (with_one (random_gen (random_gen (random_gen (comm_ring linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_107207 (h0 : functor.add_const (complete_lattice (add_cancel_monoid Type)) linarith.comp) : @is_compactly_generated.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (add_cancel_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_107208 (h0 : uniform_space (filter num)) : complete_space (filter num) := sorry --non-trivial
lemma new_lemma_107209 (h1 : ring (has_ssubset (simple_graph (normed_field reducibility_hints)))) : is_domain (has_ssubset (simple_graph (normed_field reducibility_hints))) := sorry --non-trivial
lemma new_lemma_107210 (h0 : has_add (has_add ennreal) -> has_add (has_add ennreal) -> Prop) : is_symm (has_add (has_add ennreal)) h0 := sorry --non-trivial
lemma new_lemma_107211 (h0 : functor.add_const (topological_space (has_add real)) Type) : @topological_space.separable_space.{0} (has_add.{0} real) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} real)) Type h0)  := sorry --non-trivial
lemma new_lemma_107212 (h0 : filter (ring (ring Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_107213 (h2 : group (has_ssubset linarith.comp_source)) : is_cyclic (has_ssubset linarith.comp_source) := sorry --non-trivial
lemma new_lemma_107214 (h0 : topological_space (canonically_ordered_comm_semiring ennreal)) : normal_space (canonically_ordered_comm_semiring ennreal) := sorry --non-trivial
lemma new_lemma_107215 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (ordered_cancel_comm_monoid.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ordered_cancel_comm_monoid.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_107216 (h0 : group (ordered_cancel_add_comm_monoid num)) : is_simple_group (ordered_cancel_add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_107217 (h0 : topological_space (has_bot (has_Inf pos))) : normal_space (has_bot (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_107218 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_107219 (h0 : functor.add_const (semiring (preorder congr_arg_kind)) congr_arg_kind) : @is_noetherian_ring.{0} (preorder.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (semiring.{0} (preorder.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_107220 (h0 : functor.add_const (complete_lattice (has_zero linarith.comp)) linarith.comp) : @is_atomistic.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_107221 (h0 : ring (has_neg (has_neg Type))) : is_domain (has_neg (has_neg Type)) := sorry --non-trivial
lemma new_lemma_107222 (h0 : ring (option empty)) : rank_condition (option empty) := sorry --non-trivial
lemma new_lemma_107223 (h0 : ring (has_neg (has_add (finset pos)))) : rank_condition (has_neg (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_107224 (h0 : not (add_monoid (has_sub unsigned) -> false)) : @add_monoid.fg.{0} (has_sub.{0} unsigned) (@classical.by_contradiction'.{1} (add_monoid.{0} (has_sub.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_107225 (h0 : add_group (random_gen (with_bot (has_top to_additive.value_type)))) : is_add_cyclic (random_gen (with_bot (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_107226 (h0 : function.extfun Type multiset) : multiset.nodup (function.extfun_app h0 (has_emptyc fun_info)) := sorry --non-trivial
lemma new_lemma_107227 (h0 : linarith.comp_source -> linarith.comp_source -> Prop) (h1 : function.extfun linarith.comp_source (fun (x : linarith.comp_source), Prop)) : set.bounded h0 (function.extfun_app h1) := sorry --non-trivial
lemma new_lemma_107228 (h0 : functor.add_const (group (cancel_monoid environment.implicit_infer_kind)) linarith.comp) : @is_cyclic.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_107229 (h0 : add_monoid (has_nndist (mul_zero_class (option (mul_zero_class name))))) : add_monoid.fg (has_nndist (mul_zero_class (option (mul_zero_class name)))) := sorry --non-trivial
lemma new_lemma_107230 (h0 : ring (has_top (has_top unsigned))) : strong_rank_condition (has_top (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_107231 (h0 : functor.comp uniform_space semigroup environment.implicit_infer_kind) : @separated_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} uniform_space.{0} semigroup.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_107232 (h0 : functor.add_const (filter (mul_zero_class name)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_107233 (h0 : function.extfun Type (functor.add_const (topological_space (ordered_comm_semiring unsigned)))) : @totally_separated_space.{0} (ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_semiring.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (ordered_comm_semiring.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_107234 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_bot unsigned)) := sorry --non-trivial
lemma new_lemma_107235 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) name) : @sequential_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_107236 (h0 : has_mem.mem (has_top empty) has_emptyc.emptyc) : @separated_space.{0} (has_top.{0} empty) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_top.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_107237 (h0 : uniform_space (add_comm_monoid (add_cancel_monoid (has_add name)))) : complete_space (add_comm_monoid (add_cancel_monoid (has_add name))) := sorry --non-trivial
lemma new_lemma_107238 (h0 : semiring (option ennreal)) : is_noetherian_ring (option ennreal) := sorry --non-trivial
lemma new_lemma_107239 (h0 : add_group (distrib (comm_ring (has_nnnorm (has_nnnorm (random_gen char)))))) : is_add_cyclic (distrib (comm_ring (has_nnnorm (has_nnnorm (random_gen char))))) := sorry --non-trivial
lemma new_lemma_107240 (h1 : add_group (has_div string_imp)) : is_add_cyclic (has_div string_imp) := sorry --non-trivial
lemma new_lemma_107241 (h0 : simple_graph linarith.comp -> simple_graph linarith.comp -> Prop) : is_symm (simple_graph linarith.comp) h0 := sorry --non-trivial
lemma new_lemma_107242 (h0 : uniform_space (has_norm (semiring unsigned))) : separated_space (has_norm (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_107243 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} h0 (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_107244 (h1 : uniform_space (measurable_space (random_gen linarith.comp))) : separated_space (measurable_space (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_107245 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_107246 (h0 : topological_space (has_neg (has_Inf Type))) : path_connected_space (has_neg (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_107247 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen num))) : @totally_disconnected_space.{0} (random_gen.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_107248 (h0 : topological_space (has_to_string (has_to_string pos))) : irreducible_space (has_to_string (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_107249 (h0 : not (monoid (add_group congr_arg_kind) -> false)) : @monoid.fg.{0} (add_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (monoid.{0} (add_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_107250 (h0 : complete_lattice (semiring (has_norm num))) : is_compactly_generated (semiring (has_norm num)) := sorry --non-trivial
lemma new_lemma_107251 (h0 : not (ring (div_inv_monoid fun_info) -> false)) : @is_domain.{0} (div_inv_monoid.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (div_inv_monoid.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_107252 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_107253 (h0 : topological_space (normed_comm_ring (option (option (option (option (option empty))))))) : discrete_topology (normed_comm_ring (option (option (option (option (option empty)))))) := sorry --non-trivial
lemma new_lemma_107254 (h0 : ordered_add_comm_monoid (ring num)) : archimedean (ring num) := sorry --non-trivial
lemma new_lemma_107255 (h0 : filter (boolean_algebra (comm_group name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_107256 (h0 : functor.add_const (cancel_comm_monoid_with_zero znum) (option (option empty))) : @unique_factorization_monoid.{0} znum (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} znum) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_107257 (h0 : uniform_space (distrib (has_nnnorm (has_nnnorm char)))) : complete_space (distrib (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_107258 (h0 : ring (linear_ordered_comm_ring (semiring unsigned))) : is_domain (linear_ordered_comm_ring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_107259 (h0 : group (id linarith.ineq)) : normalizer_condition (id linarith.ineq) := sorry --non-trivial
lemma new_lemma_107260 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_dist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_dist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_107261 (h0 : functor.add_const (topological_space (boolean_algebra name)) pos) : @preconnected_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_107262 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (normed_linear_ordered_group.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_linear_ordered_group.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_107263 (h0 : add_monoid (has_bot congr_arg_kind)) : add_monoid.fg (has_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_107264 (h0 : uniform_space (normed_group (semiring (has_top linarith.comp)))) : separated_space (normed_group (semiring (has_top linarith.comp))) := sorry --non-trivial
lemma new_lemma_107265 (h0 : function.extfun nat fin) : @separated_space.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (sub_neg_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_107266 (h1 : not (ring (distrib reducibility_hints) -> false)) : @rank_condition.{0} (distrib.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (distrib.{0} reducibility_hints)) h1)  := sorry --non-trivial
lemma new_lemma_107267 (h0 : ring (semiring empty)) : is_domain (semiring empty) := sorry --non-trivial
lemma new_lemma_107268 (h0 : topological_space (has_lt string_imp)) (h1 : has_scalar std_gen (has_lt string_imp)) : has_continuous_const_smul std_gen (has_lt string_imp) := sorry --non-trivial
lemma new_lemma_107269 (h0 : complete_lattice (with_bot (has_inv (has_inv to_additive.value_type)))) : complete_lattice.is_Sup_finite_compact (with_bot (has_inv (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_107270 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf pos))) : t1_space (normed_lattice_add_comm_group (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_107271 (h0 : functor.add_const (filter (has_add pos)) unsigned) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_107272 (h0 : not (topological_space (has_ssubset (comm_ring linarith.comp_source)) -> false)) : @t0_space.{0} (has_ssubset.{0} (comm_ring.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} (comm_ring.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_107273 (h0 : uniform_space (has_top (random_gen to_additive.value_type))) : separated_space (has_top (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_107274 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (finset.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} num))  := sorry --non-trivial
lemma new_lemma_107275 (h0 : topological_space (group_with_zero num)) : loc_path_connected_space (group_with_zero num) := sorry --non-trivial
lemma new_lemma_107276 (h0 : functor.add_const (add_group (mul_zero_class name)) (finset pos)) : @is_add_cyclic.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (mul_zero_class.{0} name)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_107277 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (has_neg num)) := sorry --non-trivial
lemma new_lemma_107278 (h0 : function.extfun Type ring) : @is_domain.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_107279 (h0 : functor.add_const (semiring (monoid empty)) (option empty)) : @is_noetherian_ring.{0} (monoid.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (monoid.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_107280 (h0 : topological_space (finset (finset (has_pos_part environment.implicit_infer_kind)))) : topological_space.separable_space (finset (finset (has_pos_part environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_107281 (h0 : function.extfun (Type 1) (functor.comp ring boolean_algebra)) : @is_principal_ideal_ring.{1} (boolean_algebra.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} boolean_algebra.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} ring.{1} boolean_algebra.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_107282 (h0 : functor.comp complete_lattice boolean_algebra.core pos) : @is_atomistic.{0} (boolean_algebra.core.{0} pos) (@functor.comp.run.{0 0 0} complete_lattice.{0} boolean_algebra.core.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_107283 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_107284 (h0 : complete_lattice (normed_linear_ordered_group (semiring (semiring empty)))) : is_atomistic (normed_linear_ordered_group (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_107285 (h0 : topological_space (simple_graph (boolean_algebra.core Type))) : preirreducible_space (simple_graph (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_107286 (h0 : ring (simple_graph (normed_field std_gen))) : strong_rank_condition (simple_graph (normed_field std_gen)) := sorry --non-trivial
lemma new_lemma_107287 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} h0 (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_107288 (h0 : functor.add_const (topological_space (has_neg_part name)) Type) : @irreducible_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg_part.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_107289 (h0 : add_group unsigned) : is_add_cyclic unsigned := sorry --non-trivial
lemma new_lemma_107290 (h1 : topological_space (uniform_space (has_nnnorm string.iterator_imp))) : t0_space (uniform_space (has_nnnorm string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_107291 (h0 : add_monoid (has_nndist (option name))) : add_monoid.fg (has_nndist (option name)) := sorry --non-trivial
lemma new_lemma_107292 (h0 : ring (cancel_monoid Type)) : rank_condition (cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_107293 (h0 : group (normed_comm_ring (comm_group (comm_group name)))) : is_simple_group (normed_comm_ring (comm_group (comm_group name))) := sorry --non-trivial
lemma new_lemma_107294 (h0 : ring (has_add name)) : rank_condition (has_add name) := sorry --non-trivial
lemma new_lemma_107295 (h0 : fin has_zero.zero) : @separated_space.{0} (sub_neg_monoid.{0} name) (@matrix.vec_empty.{0} (uniform_space.{0} (sub_neg_monoid.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_107296 (h0 : topological_space (linear_ordered_semiring (random_gen fun_info))) : path_connected_space (linear_ordered_semiring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_107297 (h0 : thunk (list Prop)) : list.tfae (@trace_call_stack.{0} (list.{0} Prop) h0)  := sorry --non-trivial
lemma new_lemma_107298 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_107299 (h1 : not (has_mem.mem (measurable_space fun_info) has_emptyc.emptyc -> false)) : @is_domain.{0} (measurable_space.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (measurable_space.{0} fun_info) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} fun_info) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h1))  := sorry --non-trivial
lemma new_lemma_107300 (h0 : functor.add_const (topological_space (ring pos)) (has_neg (boolean_algebra Type))) : @t0_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} pos)) (has_neg.{1} (boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_107301 (h0 : uniform_space (add_comm_semigroup (add_comm_semigroup fun_info))) : complete_space (add_comm_semigroup (add_comm_semigroup fun_info)) := sorry --non-trivial
lemma new_lemma_107302 (h0 : function.extfun Type (prod (has_zero (option (option ennreal))))) : id_rel (function.extfun_app h0 (has_zero (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_107303 (h0 : functor.add_const (uniform_space (generalized_boolean_algebra pos)) name) : @separated_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (generalized_boolean_algebra.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_107304 (h0 : topological_space (has_inv (random_gen linarith.comp_source))) : locally_compact_space (has_inv (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_107305 (h0 : functor.add_const (filter (plift num)) (semiring num)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_107306 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} linarith.comp_source (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 complete_lattice.{0}) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_107307 (h0 : topological_space (finset (has_add linarith.comp))) : irreducible_space (finset (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_107308 (h1 : topological_space (with_zero (has_nnnorm fun_info))) : t0_space (with_zero (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_107309 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (complete_distrib_lattice.{0} real) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (complete_distrib_lattice.{0} real))  := sorry --non-trivial
lemma new_lemma_107310 (h1 : complete_lattice (non_unital_non_assoc_semiring linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (non_unital_non_assoc_semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_107311 (h0 : topological_space (linear_ordered_cancel_comm_monoid unsigned)) : irreducible_space (linear_ordered_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_107312 (h0 : functor.add_const (topological_space (canonically_linear_ordered_monoid pos)) pos) : @totally_disconnected_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_107313 (h1 : topological_space (has_compl (has_ssubset reducibility_hints))) : path_connected_space (has_compl (has_ssubset reducibility_hints)) := sorry --non-trivial
lemma new_lemma_107314 (h0 : has_mem.mem (boolean_algebra.core unsigned) has_zero.zero) : @rank_condition.{0} (boolean_algebra.core.{0} unsigned) (@multiset.pi.empty.{1 0} Type ring.{0} (boolean_algebra.core.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_107315 (h0 : functor.add_const (list (has_add Type)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_107316 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (ordered_ring.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_ring.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_107317 (h0 : ring (id to_additive.value_type)) : rank_condition (id to_additive.value_type) := sorry --non-trivial
lemma new_lemma_107318 (h0 : measurable_space (has_lt linarith.comp_source)) (h1 : filter (has_lt linarith.comp_source)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_107319 (h0 : topological_space (has_to_string environment.implicit_infer_kind)) : preconnected_space (has_to_string environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_107320 (h3 : topological_space (non_unital_non_assoc_semiring to_additive.value_type)) (h4 : preorder (non_unital_non_assoc_semiring to_additive.value_type)) : order_topology (non_unital_non_assoc_semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_107321 (h0 : functor.add_const (semiring (has_pos_part pos)) Type) : @is_noetherian_ring.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 1} (semiring.{0} (has_pos_part.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_107322 (h0 : functor.add_const (function.extfun Type ring) Type) : @rank_condition.{0} (finset.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (finset.{0} real))  := sorry --non-trivial
lemma new_lemma_107323 (h1 : not (has_mem.mem (with_one num) has_emptyc.emptyc -> false)) : @is_add_cyclic.{0} (with_one.{0} num) (@finset.pi.empty.{1 0} Type add_group.{0} (with_one.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h1))  := sorry --non-trivial
lemma new_lemma_107324 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_107325 (h0 : topological_space (normed_comm_ring (has_to_string (has_to_string Type)))) : preconnected_space (normed_comm_ring (has_to_string (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_107326 (h0 : ring (id linarith.ineq)) : is_domain (id linarith.ineq) := sorry --non-trivial
lemma new_lemma_107327 (h0 : functor.add_const (ring (add_cancel_monoid environment.implicit_infer_kind)) ennreal) : @is_principal_ideal_ring.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_107328 (h0 : monoid (option unsigned)) : monoid.fg (option unsigned) := sorry --non-trivial
lemma new_lemma_107329 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_107330 (h0 : list (boolean_algebra (has_neg (semigroup (has_zero Type))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_107331 (h0 : add_group (generalized_boolean_algebra (sub_neg_monoid real))) : is_add_cyclic (generalized_boolean_algebra (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_107332 (h0 : function.extfun (finset Type) (has_mem.mem (has_top num))) : @complete_space.{0} (has_top.{0} num) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_top.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_107333 (h0 : ring (add_right_cancel_monoid unsigned)) : is_domain (add_right_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_107334 (h0 : ring (normed_field (has_nnnorm (has_Inf reducibility_hints)))) : strong_rank_condition (normed_field (has_nnnorm (has_Inf reducibility_hints))) := sorry --non-trivial
lemma new_lemma_107335 (h0 : functor.add_const (topological_space (ordered_comm_monoid Type)) name) : @discrete_topology.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_107336 (h2 : topological_space (mul_one_class linarith.ineq)) : t0_space (mul_one_class linarith.ineq) := sorry --non-trivial
lemma new_lemma_107337 (h0 : functor.add_const (function.extfun Type filter) Type) : filter.ne_bot (function.extfun_app (functor.add_const.run h0) (semigroup pos)) := sorry --non-trivial
lemma new_lemma_107338 (h0 : filter (with_one (add_right_cancel_monoid num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_107339 (h0 : add_group (monoid_with_zero (option ennreal))) : is_add_cyclic (monoid_with_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_107340 (h0 : pnat) (h1 : ulower pnat) (h2 : ulower punit) : pnat.coprime h0 (category_theory.hom_of_element (ulower.up h1) (ulower.up h2)) := sorry --non-trivial
lemma new_lemma_107341 (h0 : fin has_zero.zero) : matrix.vec_empty (id (matrix.vec_empty (id (id h0)))) := sorry --non-trivial
lemma new_lemma_107342 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (add_group.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_group.{0} num))  := sorry --non-trivial
lemma new_lemma_107343 (h0 : list (add_cancel_monoid (has_pos_part pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_107344 (h0 : semiring (with_bot (has_norm unsigned))) : is_noetherian_ring (with_bot (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_107345 (h0 : topological_space (comm_group environment.implicit_infer_kind)) : path_connected_space (comm_group environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_107346 (h2 : complete_lattice (has_top num)) : complete_lattice.is_Sup_finite_compact (has_top num) := sorry --non-trivial
lemma new_lemma_107347 (h0 : uniform_space (denumerable (random_gen (random_gen (random_gen (random_gen char)))))) : complete_space (denumerable (random_gen (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_107348 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_107349 (h0 : topological_space (linear_ordered_add_comm_group (with_one (random_gen to_additive.value_type)))) : locally_compact_space (linear_ordered_add_comm_group (with_one (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_107350 (h0 : not (uniform_space (topological_space (random_gen linarith.ineq)) -> false)) : @complete_space.{0} (topological_space.{0} (random_gen.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (uniform_space.{0} (topological_space.{0} (random_gen.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_107351 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (ring.{0} name) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (ring.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_107352 (h0 : function.extfun (Type 1) group) : @normalizer_condition.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_107353 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_atomistic.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) complete_lattice.{0}) (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_107354 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_107355 (h0 : ring (dlist (has_inv linarith.ineq))) : is_domain (dlist (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_107356 (h0 : functor.add_const (topological_space Type) Type) : @totally_disconnected_space.{1} Type (@functor.add_const.run.{1 1} (topological_space.{1} Type) Type h0)  := sorry --non-trivial
lemma new_lemma_107357 (h0 : functor.add_const (list (has_Sup empty)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_107358 (h0 : ordered_add_comm_monoid (sub_neg_monoid (has_Inf Type))) : archimedean (sub_neg_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_107359 (h0 : ordered_comm_monoid (has_zero Type)) : has_exists_mul_of_le (has_zero Type) := sorry --non-trivial
lemma new_lemma_107360 (h0 : functor.add_const (monoid (has_zero Type)) (ring (ring pos))) : @monoid.fg.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (has_zero.{1} Type)) (ring.{0} (ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_107361 (h0 : add_monoid (has_one (semiring (semiring (semiring (semiring num)))))) : add_monoid.fg (has_one (semiring (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_107362 (h0 : ring (sub_neg_monoid (has_neg (has_neg (has_neg pos))))) : is_principal_ideal_ring (sub_neg_monoid (has_neg (has_neg (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_107363 (h0 : functor.add_const (filter (plift num)) (semiring (semiring num))) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_107364 (h0 : has_mem.mem (linear_ordered_semiring linarith.comp_source) has_emptyc.emptyc) : @rank_condition.{0} (linear_ordered_semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (linear_ordered_semiring.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_107365 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (linear_ordered_add_comm_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_107366 (h1 : not (add_group (add_left_cancel_monoid char) -> false)) : @is_add_cyclic.{0} (add_left_cancel_monoid.{0} char) (@classical.by_contradiction'.{1} (add_group.{0} (add_left_cancel_monoid.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_107367 (h0 : finset (non_assoc_semiring (semiring (semiring (semiring unsigned))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_107368 (h0 : topological_space (mul_zero_class pos)) : normal_space (mul_zero_class pos) := sorry --non-trivial
lemma new_lemma_107369 (h0 : not (complete_lattice (metric_space num) -> false)) : @is_atomistic.{0} (metric_space.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (metric_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_107370 (h0 : functor.add_const (finset (add_comm_monoid environment.implicit_infer_kind)) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_107371 (h0 : topological_space (ring (finset (has_add pos)))) : loc_path_connected_space (ring (finset (has_add pos))) := sorry --non-trivial
lemma new_lemma_107372 (h0 : complete_lattice (has_inner empty (option empty))) : complete_lattice.is_Sup_finite_compact (has_inner empty (option empty)) := sorry --non-trivial
lemma new_lemma_107373 (h0 : functor.add_const (filter (boolean_algebra (ring unsigned))) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_107374 (h0 : function.extfun Type ring) : @rank_condition.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_107375 (h0 : uniform_space (has_Inf (has_neg name))) : separated_space (has_Inf (has_neg name)) := sorry --non-trivial
lemma new_lemma_107376 (h0 : function.extfun Type group) : @group.fg.{0} char (@function.extfun_app.{2 1} Type group.{0} h0 char)  := sorry --non-trivial
lemma new_lemma_107377 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (random_gen.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (random_gen.{0} empty))  := sorry --non-trivial
lemma new_lemma_107378 (h0 : ring (has_lt ereal)) : strong_rank_condition (has_lt ereal) := sorry --non-trivial
lemma new_lemma_107379 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_107380 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) linarith.comp) : @is_compactly_generated.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) linarith.comp h0) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_107381 (h0 : fin has_zero.zero) : finset.nonempty (function.extfun_app (matrix.vec_empty h0) (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_107382 (h0 : has_mem.mem (has_add linarith.ineq) has_emptyc.emptyc) : @path_connected_space.{0} (has_add.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_add.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_107383 (h0 : set (has_nnnorm (mul_one_class to_additive.value_type))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_107384 (h0 : functor.add_const (topological_space (has_pos_part environment.implicit_infer_kind)) pos) : @preconnected_space.{0} (has_pos_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_107385 (h0 : not (topological_space (normed_group empty) -> false)) : @normal_space.{0} (normed_group.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_107386 (h0 : group (complete_distrib_lattice (option (option num)))) : normalizer_condition (complete_distrib_lattice (option (option num))) := sorry --non-trivial
lemma new_lemma_107387 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) linarith.comp) : @sequential_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_107388 (h0 : ring (finset (has_to_string (boolean_algebra linarith.comp)))) : rank_condition (finset (has_to_string (boolean_algebra linarith.comp))) := sorry --non-trivial
lemma new_lemma_107389 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_107390 (h0 : topological_space (has_edist (option unsigned))) : locally_compact_space (has_edist (option unsigned)) := sorry --non-trivial
lemma new_lemma_107391 (h0 : semiring (add_comm_semigroup environment.projection_info)) (h1 : ideal (add_comm_semigroup environment.projection_info)) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_107392 (h0 : functor.add_const Prop (ring name)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_107393 (h0 : ring (linear_ordered_cancel_comm_monoid congr_arg_kind)) : is_principal_ideal_ring (linear_ordered_cancel_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_107394 (h0 : topological_space (has_inner (option empty) empty)) : discrete_topology (has_inner (option empty) empty) := sorry --non-trivial
lemma new_lemma_107395 (h0 : ring (rel (mul_one_class enat) (mul_one_class enat))) : strong_rank_condition (rel (mul_one_class enat) (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_107396 (h0 : semiring (ring (add_cancel_monoid Type))) : is_noetherian_ring (ring (add_cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_107397 (h0 : add_group (has_to_string Type)) : is_add_cyclic (has_to_string Type) := sorry --non-trivial
lemma new_lemma_107398 (h0 : ring (with_bot (semiring unsigned))) : is_principal_ideal_ring (with_bot (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_107399 (h0 : add_comm_monoid (complete_distrib_lattice pos) -> add_comm_monoid (complete_distrib_lattice pos) -> Prop) : is_symm (add_comm_monoid (complete_distrib_lattice pos)) h0 := sorry --non-trivial
lemma new_lemma_107400 (h0 : function.extfun Type (functor.add_const (topological_space Type))) : @normal_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) linarith.comp (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (topological_space.{1} Type)) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_107401 (h0 : add_group (linear_ordered_semiring (semiring unsigned))) : is_add_cyclic (linear_ordered_semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_107402 (h0 : functor.add_const (add_group (has_nndist name)) Type) : @is_add_cyclic.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 1} (add_group.{0} (has_nndist.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_107403 (h0 : topological_space (has_star (semiring congr_arg_kind))) : discrete_topology (has_star (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_107404 (h0 : topological_space (semigroup (semiring empty))) : t1_space (semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_107405 (h0 : functor.comp cancel_comm_monoid_with_zero complete_distrib_lattice name) : @unique_factorization_monoid.{0} (complete_distrib_lattice.{0} name) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} complete_distrib_lattice.{0} name h0)  := sorry --non-trivial
lemma new_lemma_107406 (h0 : set (semi_normed_comm_ring (mul_one_class (mul_one_class fun_info)))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_107407 (h0 : ring (comm_group (has_neg_part (has_to_string ennreal)))) : is_domain (comm_group (has_neg_part (has_to_string ennreal))) := sorry --non-trivial
lemma new_lemma_107408 (h0 : ring (mul_zero_class (finset pos))) : strong_rank_condition (mul_zero_class (finset pos)) := sorry --non-trivial
lemma new_lemma_107409 (h0 : monoid (measurable_space (id congr_arg_kind))) : monoid.fg (measurable_space (id congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_107410 (h0 : option (list (left_cancel_semigroup unsigned))) (h1 : list (left_cancel_semigroup unsigned)) : list.nodup (option.get_or_else h0 h1) := sorry --non-trivial
lemma new_lemma_107411 (h0 : filter (has_to_string (has_nndist (finset (has_nndist pos))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_107412 (h0 : group (semi_normed_comm_ring (has_add linarith.ineq))) : is_cyclic (semi_normed_comm_ring (has_add linarith.ineq)) := sorry --non-trivial
lemma new_lemma_107413 (h0 : functor.add_const (add_group (boolean_algebra linarith.comp)) Type) : @is_add_cyclic.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_group.{0} (boolean_algebra.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_107414 (h0 : functor.add_const (complete_lattice (has_add Type)) pos) : @complete_lattice.is_Sup_finite_compact.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_add.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_107415 (h0 : topological_space (normed_lattice_add_comm_group linarith.comp)) : preconnected_space (normed_lattice_add_comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_107416 (h0 : has_mem.mem (with_one fun_info) has_emptyc.emptyc) : @is_domain.{0} (with_one.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (with_one.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_107417 (h0 : function.extfun Type ring) : @rank_condition.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_107418 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_107419 (h0 h1 : multiset (uniform_space to_additive.value_type)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_107420 (h0 : group (boolean_algebra (comm_group (comm_group (has_to_string unsigned))))) : is_cyclic (boolean_algebra (comm_group (comm_group (has_to_string unsigned)))) := sorry --non-trivial
lemma new_lemma_107421 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_107422 (h0 : ring (has_to_string (has_add (has_neg_part (has_add name))))) : is_principal_ideal_ring (has_to_string (has_add (has_neg_part (has_add name)))) := sorry --non-trivial
lemma new_lemma_107423 (h0 : complete_lattice (has_zero (has_neg_part pos))) : is_compactly_generated (has_zero (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_107424 (h0 : functor.add_const (topological_space (has_to_string Type)) name) : @regular_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_107425 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_107426 (h0 : topological_space (has_compl (mul_one_class (mul_one_class fun_info)))) : t0_space (has_compl (mul_one_class (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_107427 (h0 : set (nondiscrete_normed_field string.iterator_imp -> fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_107428 (h1 : function.extfun Type list) : list.nodup (function.extfun_app h1 (denumerable string_imp)) := sorry --non-trivial
lemma new_lemma_107429 (h0 : ring (distrib_lattice (has_nnnorm linarith.ineq))) : rank_condition (distrib_lattice (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_107430 (h0 : functor.add_const (topological_space (normed_comm_ring name)) name) : @path_connected_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_107431 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_107432 (h0 : functor.add_const (cancel_comm_monoid_with_zero (bin_tree unsigned)) congr_arg_kind) : @unique_factorization_monoid.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (bin_tree.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_107433 (h0 : functor.add_const (monoid (ring linarith.comp)) name) : @monoid.fg.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_107434 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} num (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 num)  := sorry --non-trivial
lemma new_lemma_107435 (h0 : group (add_right_cancel_monoid (has_top unsigned))) : group.fg (add_right_cancel_monoid (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_107436 (h0 : ring (has_top (comm_ring (comm_ring fun_info)))) : rank_condition (has_top (comm_ring (comm_ring fun_info))) := sorry --non-trivial
lemma new_lemma_107437 (h0 : not (ring (non_unital_non_assoc_ring empty) -> false)) : @strong_rank_condition.{0} (non_unital_non_assoc_ring.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (non_unital_non_assoc_ring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_107438 (h0 : function.extfun Type (functor.add_const (topological_space (has_Inf linarith.comp)))) : @totally_separated_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) name (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp))) h0 name))  := sorry --non-trivial
lemma new_lemma_107439 (h0 : functor.add_const (complete_lattice (has_zero pos)) Type) : @is_compactly_generated.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_zero.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_107440 (h0 : topological_space (complete_distrib_lattice empty)) : totally_disconnected_space (complete_distrib_lattice empty) := sorry --non-trivial
lemma new_lemma_107441 (h0 : function.extfun nat fin) : @strong_rank_condition.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (canonically_linear_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_107442 (h0 : topological_space (semigroup name)) : preconnected_space (semigroup name) := sorry --non-trivial
lemma new_lemma_107443 (h0 : functor.add_const (group (has_to_string environment.implicit_infer_kind)) environment.implicit_infer_kind) : @group.fg.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_107444 (h0 : topological_space (div_inv_monoid (has_norm (has_norm linarith.comp)))) : path_connected_space (div_inv_monoid (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_107445 (h0 : group (has_nndist unsigned)) : is_cyclic (has_nndist unsigned) := sorry --non-trivial
lemma new_lemma_107446 (h0 : topological_space (add_left_cancel_monoid char)) : totally_disconnected_space (add_left_cancel_monoid char) := sorry --non-trivial
lemma new_lemma_107447 (h0 : complete_lattice (normed_group (has_inv linarith.comp_source))) : is_compactly_generated (normed_group (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_107448 (h0 : uniform_space (mul_zero_class (semiring unsigned))) : separated_space (mul_zero_class (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_107449 (h0 : not (add_group (has_div to_additive.value_type) -> false)) : @is_add_cyclic.{0} (has_div.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (add_group.{0} (has_div.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_107450 (h0 : list (has_top (random_gen to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_107451 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_107452 (h0 : topological_space (with_one (semiring unsigned))) : normal_space (with_one (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_107453 (h0 : functor.add_const (monoid (semigroup Type)) (ring linarith.comp)) : @monoid.fg.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (semigroup.{1} Type)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_107454 (h0 : topological_space (canonically_ordered_comm_semiring (option unsigned))) : discrete_topology (canonically_ordered_comm_semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_107455 (h0 : linarith.comp_source -> Prop) (h1 : linarith.comp_source) : set_of h0 h1 := sorry --non-trivial
lemma new_lemma_107456 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_107457 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_107458 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (simple_graph.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (simple_graph.{0} empty))  := sorry --non-trivial
lemma new_lemma_107459 (h0 : uniform_space (measurable_space (has_inv (comm_ring linarith.comp_source)))) : complete_space (measurable_space (has_inv (comm_ring linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_107460 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_107461 (h0 : group (complete_semilattice_Sup string_imp)) : normalizer_condition (complete_semilattice_Sup string_imp) := sorry --non-trivial
lemma new_lemma_107462 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @rank_condition.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_107463 (h0 : topological_space (ordered_comm_ring Type)) : discrete_topology (ordered_comm_ring Type) := sorry --non-trivial
lemma new_lemma_107464 (h0 : topological_space (has_le (simple_graph string.iterator_imp))) : path_connected_space (has_le (simple_graph string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_107465 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (add_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_group.{0} num))  := sorry --non-trivial
lemma new_lemma_107466 (h0 : complete_lattice (linear_ordered_add_comm_group char) -> random_gen char) (h1 : not (coe_sort (set.range h0) -> false)) : @is_compactly_generated.{0} (linear_ordered_add_comm_group.{0} char) (@set.range_splitting.{0 0} (complete_lattice.{0} (linear_ordered_add_comm_group.{0} char)) (random_gen.{0} char) h0 (@classical.by_contradiction'.{1} (@coe_sort.{1 2} (set.{0} (random_gen.{0} char)) Type (@set.has_coe_to_sort.{0} (random_gen.{0} char)) (@set.range.{0 1} (random_gen.{0} char) (complete_lattice.{0} (linear_ordered_add_comm_group.{0} char)) h0)) h1))  := sorry --non-trivial
lemma new_lemma_107467 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_107468 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem add_monoid)) : @add_monoid.fg.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_monoid.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_monoid.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_107469 (h0 : list (non_assoc_semiring (semiring num))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_107470 (h0 : ring (linear_ordered_add_comm_group (random_gen fun_info))) : rank_condition (linear_ordered_add_comm_group (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_107471 (h0 : functor.add_const (prod znum znum) unsigned) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_107472 (h0 : complete_lattice (has_star (semiring num))) : is_atomistic (has_star (semiring num)) := sorry --non-trivial
lemma new_lemma_107473 (h0 : topological_space (has_add (finset linarith.comp))) : loc_path_connected_space (has_add (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_107474 (h0 : topological_space (semigroup environment.implicit_infer_kind)) : preconnected_space (semigroup environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_107475 (h0 : ring (normed_field (metric_space to_additive.value_type))) : is_domain (normed_field (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_107476 (h0 : add_group (boolean_algebra (mul_one_class (finset (finset (finset linarith.comp)))))) : is_add_cyclic (boolean_algebra (mul_one_class (finset (finset (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_107477 (h0 : functor.add_const (semiring (semigroup environment.implicit_infer_kind)) linarith.comp) : @is_noetherian_ring.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (semiring.{0} (semigroup.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_107478 (h0 : functor.add_const (function.extfun Type group) Type) : @is_cyclic.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_107479 (h0 : group (ring (ring linarith.comp))) : is_cyclic (ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_107480 (h0 : ring (fintype fun_info)) : rank_condition (fintype fun_info) := sorry --non-trivial
lemma new_lemma_107481 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_add_cyclic.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) add_group.{0}) (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_107482 (h0 : semiring to_additive.value_type) (h1 : ideal to_additive.value_type) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_107483 (h3 : ring (fintype (has_nnnorm linarith.comp_source))) : is_domain (fintype (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_107484 (h0 : group (with_bot (has_norm linarith.comp))) : is_cyclic (with_bot (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_107485 (h1 : complete_lattice (uniform_space string_imp)) : is_compactly_generated (uniform_space string_imp) := sorry --non-trivial
lemma new_lemma_107486 (h0 : topological_space (has_add (has_to_string (has_to_string pos)))) : preconnected_space (has_add (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_107487 (h0 : topological_space (has_Inf (has_neg name))) : preirreducible_space (has_Inf (has_neg name)) := sorry --non-trivial
lemma new_lemma_107488 (h0 : functor.add_const (list (option unsigned)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_107489 (h0 : functor.add_const (complete_lattice (has_add linarith.comp)) Type) : @is_compactly_generated.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_add.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_107490 (h0 : complete_lattice (ordered_ring (semiring empty))) : is_compactly_generated (ordered_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_107491 (h0 : functor.add_const (finset (complete_distrib_lattice unsigned)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_107492 (h0 : group (linear_ordered_comm_ring (semiring (semiring empty)))) : normalizer_condition (linear_ordered_comm_ring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_107493 (h0 : topological_space (finset num)) : totally_separated_space (finset num) := sorry --non-trivial
lemma new_lemma_107494 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (with_one fun_info)) := sorry --non-trivial
lemma new_lemma_107495 (h0 : function.extfun Type topological_space) : @t1_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_107496 (h0 : functor.add_const (ring (linear_ordered_add_comm_monoid_with_top ennreal)) ennreal) : @is_domain.{0} (linear_ordered_add_comm_monoid_with_top.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (linear_ordered_add_comm_monoid_with_top.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_107497 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @regular_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_107498 (h0 : function.extfun Type pseudo_metric_space) : @proper_space.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type pseudo_metric_space.{0} h0 (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_107499 (h0 : functor.add_const (finset (has_Sup num)) (semiring num)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_107500 (h0 : function.extfun Type group) : @is_simple_group.{0} (comm_group.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (comm_group.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_107501 (h0 : functor.add_const (uniform_space (mul_one_class environment.implicit_infer_kind)) environment.implicit_infer_kind) : @separated_space.{0} (mul_one_class.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (mul_one_class.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_107502 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (as_linear_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (as_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_107503 (h0 : function.extfun (Type 1) (functor.add_const (functor.add_const Prop Type))) : functor.add_const.run (functor.add_const.run (function.extfun_app h0 Type)) := sorry --non-trivial
lemma new_lemma_107504 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_107505 (h0 : function.extfun Type topological_space) : @t0_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_107506 (h2 : uniform_space (normed_field char)) : complete_space (normed_field char) := sorry --non-trivial
lemma new_lemma_107507 (h0 : not (add_group (uniform_space (semi_normed_ring (comm_ring string_imp))) -> false)) : @is_add_cyclic.{0} (uniform_space.{0} (semi_normed_ring.{0} (comm_ring.{0} string_imp))) (@classical.by_contradiction'.{1} (add_group.{0} (uniform_space.{0} (semi_normed_ring.{0} (comm_ring.{0} string_imp)))) h0)  := sorry --non-trivial
lemma new_lemma_107508 (h0 : uniform_space (ordered_comm_group unsigned)) : separated_space (ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_107509 (h0 : functor.add_const (add_group (has_pos_part pos)) (has_Inf Type)) : @is_add_cyclic.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 1} (add_group.{0} (has_pos_part.{0} pos)) (has_Inf.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_107510 (h0 : not (group (has_emptyc linarith.ineq) -> false)) : @is_cyclic.{0} (has_emptyc.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (has_emptyc.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_107511 (h0 : topological_space (add_cancel_monoid Type)) : locally_compact_space (add_cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_107512 (h0 : functor.comp monoid add_cancel_monoid pos) : @monoid.fg.{0} (add_cancel_monoid.{0} pos) (@functor.comp.run.{0 0 0} monoid.{0} add_cancel_monoid.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_107513 (h0 : semiring (mul_one_class (add_comm_semigroup (add_comm_semigroup enat)))) (h1 : ideal (mul_one_class (add_comm_semigroup (add_comm_semigroup enat)))) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_107514 (h0 : uniform_space (non_unital_non_assoc_semiring fun_info)) : complete_space (non_unital_non_assoc_semiring fun_info) := sorry --non-trivial
lemma new_lemma_107515 (h0 : complete_lattice (left_cancel_semigroup (semiring (semiring empty)))) : complete_lattice.is_Sup_finite_compact (left_cancel_semigroup (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_107516 (h0 : ring (finset unsigned)) : rank_condition (finset unsigned) := sorry --non-trivial
lemma new_lemma_107517 (h0 : group (has_dist congr_arg_kind)) : group.fg (has_dist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_107518 (h0 : topological_space (semigroup (normed_comm_ring linarith.comp))) : totally_separated_space (semigroup (normed_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_107519 (h0 : topological_space (topological_space (has_nnnorm (has_nnnorm fun_info)))) : t0_space (topological_space (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_107520 (h0 h1 : multiset (nondiscrete_normed_field (add_comm_semigroup environment.projection_info))) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_107521 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (with_one.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_107522 (h0 : uniform_space (measurable_space empty)) : complete_space (measurable_space empty) := sorry --non-trivial
lemma new_lemma_107523 (h1 : set (mul_one_class environment.projection_info)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_107524 (h0 : group (add_comm_semigroup (mul_one_class char))) (h1 : subgroup (add_comm_semigroup (mul_one_class char))) : subgroup.fg h1 := sorry --non-trivial
lemma new_lemma_107525 (h0 : complete_lattice (canonically_ordered_add_monoid string_imp)) : is_compactly_generated (canonically_ordered_add_monoid string_imp) := sorry --non-trivial
lemma new_lemma_107526 (h0 : ring (with_one (comm_ring linarith.comp_source))) : is_domain (with_one (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_107527 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (normed_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_107528 (h3 : topological_space (nondiscrete_normed_field environment.projection_info)) (h4 : add_group (nondiscrete_normed_field environment.projection_info)) : topological_add_group (nondiscrete_normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_107529 (h0 : functor.add_const (ring (linear_ordered_field ennreal)) ennreal) : @is_principal_ideal_ring.{0} (linear_ordered_field.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (linear_ordered_field.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_107530 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (canonically_linear_ordered_monoid pos)) := sorry --non-trivial
lemma new_lemma_107531 (h0 : group (finset (option (option ennreal)))) : is_simple_group (finset (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_107532 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (is_R_or_C.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (is_R_or_C.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_107533 (h0 : monoid (simple_graph (has_add pos))) : monoid.fg (simple_graph (has_add pos)) := sorry --non-trivial
lemma new_lemma_107534 (h0 : ring (div_inv_monoid (random_gen (random_gen linarith.ineq)))) : rank_condition (div_inv_monoid (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_107535 (h0 : topological_space (has_neg_part (has_neg_part Type))) : t0_space (has_neg_part (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_107536 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_107537 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_107538 (h0 : group (random_gen empty)) : is_cyclic (random_gen empty) := sorry --non-trivial
lemma new_lemma_107539 (h0 : functor.add_const (finset (finset environment.implicit_infer_kind)) (has_neg linarith.comp)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_107540 (h0 : functor.add_const (function.extfun Type topological_space) (has_add name)) : @sequential_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_add.{0} name) h0) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_107541 (h3 : complete_lattice (simple_graph char)) : is_compactly_generated (simple_graph char) := sorry --non-trivial
lemma new_lemma_107542 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_107543 (h0 : topological_space (canonically_ordered_comm_semiring (has_neg_part ennreal))) : normal_space (canonically_ordered_comm_semiring (has_neg_part ennreal)) := sorry --non-trivial
lemma new_lemma_107544 (h0 : group (encodable (has_nnnorm (has_nnnorm linarith.comp_source)))) : is_cyclic (encodable (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_107545 (h0 : group (add_right_cancel_monoid empty)) : is_cyclic (add_right_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_107546 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (semigroup.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (semigroup.{0} num))  := sorry --non-trivial
lemma new_lemma_107547 (h1 : topological_space (mul_one_class fun_info)) : totally_disconnected_space (mul_one_class fun_info) := sorry --non-trivial
lemma new_lemma_107548 (h0 : functor.add_const (topological_space (add_comm_monoid unsigned)) environment.implicit_infer_kind) : @totally_separated_space.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_107549 (h0 : not (topological_space (linear_ordered_comm_group_with_zero linarith.ineq) -> false)) : @t0_space.{0} (linear_ordered_comm_group_with_zero.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_group_with_zero.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_107550 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (filter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (filter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_107551 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_107552 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (linear_ordered_field pos)) := sorry --non-trivial
lemma new_lemma_107553 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (semi_normed_comm_ring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semi_normed_comm_ring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_107554 (h0 : list (normed_group char)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_107555 (h0 : group (has_to_string (complete_distrib_lattice (option (complete_distrib_lattice pos))))) : is_cyclic (has_to_string (complete_distrib_lattice (option (complete_distrib_lattice pos)))) := sorry --non-trivial
lemma new_lemma_107556 (h0 : complete_lattice (linear_ordered_semiring congr_arg_kind)) : is_atomistic (linear_ordered_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_107557 (h0 : topological_space (with_bot congr_arg_kind) -> Prop) : @locally_compact_space.{0} (with_bot.{0} congr_arg_kind) (@classical.epsilon.{1} (topological_space.{0} (with_bot.{0} congr_arg_kind)) (@nonempty_of_inhabited.{1} (topological_space.{0} (with_bot.{0} congr_arg_kind)) (@inhabited_topological_space.{0} (with_bot.{0} congr_arg_kind))) h0)  := sorry --non-trivial
lemma new_lemma_107558 (h0 : add_monoid (ordered_ring (semiring (semiring congr_arg_kind)))) : add_monoid.fg (ordered_ring (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_107559 (h0 : not (topological_space (measurable_space.dynkin_system num) -> false)) : @t0_space.{0} (measurable_space.dynkin_system.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.dynkin_system.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_107560 (h0 : monoid (linear_ordered_comm_group empty)) : monoid.exponent_exists (linear_ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_107561 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} (add_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) (add_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_107562 (h0 : topological_space (simple_graph linarith.comp)) : path_connected_space (simple_graph linarith.comp) := sorry --non-trivial
lemma new_lemma_107563 (h0 : ordered_comm_monoid (has_neg_part (comm_group (comm_group name)))) : has_exists_mul_of_le (has_neg_part (comm_group (comm_group name))) := sorry --non-trivial
lemma new_lemma_107564 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_107565 (h0 : topological_space (ring (option pos))) : preirreducible_space (ring (option pos)) := sorry --non-trivial
lemma new_lemma_107566 (h0 : not (add_group (semiring fun_info) -> false)) : @is_add_cyclic.{0} (semiring.{0} fun_info) (@classical.by_contradiction'.{1} (add_group.{0} (semiring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_107567 (h0 : uniform_space (normed_comm_ring (has_add (has_add environment.implicit_infer_kind)))) : separated_space (normed_comm_ring (has_add (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_107568 (h0 : functor.add_const (add_group (add_cancel_monoid name)) pos) : @is_add_cyclic.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (add_cancel_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_107569 (h0 : topological_space (mul_one_class fun_info)) (h1 : option (preorder (mul_one_class fun_info))) (h2 : coe_sort (option.is_some h1)) : @order_topology.{0} (mul_one_class.{0} fun_info) h0 (@option.get.{0} (preorder.{0} (mul_one_class.{0} fun_info)) h1 h2)  := sorry --non-trivial
lemma new_lemma_107570 (h0 : functor.add_const (complete_lattice (has_Inf linarith.comp)) (has_neg name)) : @complete_lattice.is_Sup_finite_compact.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_Inf.{0} linarith.comp)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_107571 (h0 : add_group (has_zero (option (option (option ennreal))))) : is_add_cyclic (has_zero (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_107572 (h0 : add_group (has_add (ring (finset linarith.comp)))) : is_add_cyclic (has_add (ring (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_107573 (h0 : functor.add_const (ordered_add_comm_monoid (finset pos)) Type) : @archimedean.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (finset.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_107574 (h0 : topological_space (has_add (finset Type))) : t1_space (has_add (finset Type)) := sorry --non-trivial
lemma new_lemma_107575 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (@id.{2} Type linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (@id.{2} Type linarith.ineq))  := sorry --non-trivial
lemma new_lemma_107576 (h0 : topological_space (group_with_zero (option empty))) : discrete_topology (group_with_zero (option empty)) := sorry --non-trivial
lemma new_lemma_107577 (h0 : ring (ring (has_add (boolean_algebra environment.implicit_infer_kind)))) : is_principal_ideal_ring (ring (has_add (boolean_algebra environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_107578 (h0 : topological_space (canonically_ordered_comm_semiring (has_zero name))) : preconnected_space (canonically_ordered_comm_semiring (has_zero name)) := sorry --non-trivial
lemma new_lemma_107579 (h1 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_compactly_generated.{0} congr_arg_kind (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h1 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_107580 (h0 : group (measurable_space (semiring (semiring linarith.comp)))) : is_cyclic (measurable_space (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_107581 (h0 : ulower (fin has_zero.zero)) : id (matrix.vec_empty (matrix.vec_empty (matrix.vec_empty (matrix.vec_empty (id (ulower.up h0)))))) := sorry --non-trivial
lemma new_lemma_107582 (h0 : group (random_gen (has_nnnorm fun_info))) : is_cyclic (random_gen (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_107583 (h0 : topological_space (has_to_string linarith.comp)) : loc_path_connected_space (has_to_string linarith.comp) := sorry --non-trivial
lemma new_lemma_107584 (h0 : topological_space (boolean_algebra (sub_neg_monoid Type))) : preirreducible_space (boolean_algebra (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_107585 (h1 : topological_space (mul_one_class linarith.ineq)) : path_connected_space (mul_one_class linarith.ineq) := sorry --non-trivial
lemma new_lemma_107586 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @locally_compact_space.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_ring.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_107587 (h0 : ring (non_assoc_semiring empty)) : strong_rank_condition (non_assoc_semiring empty) := sorry --non-trivial
lemma new_lemma_107588 (h0 : ring (add_cancel_comm_monoid string_imp)) : is_domain (add_cancel_comm_monoid string_imp) := sorry --non-trivial
lemma new_lemma_107589 (h2 : uniform_space (denumerable (denumerable (denumerable char)))) : complete_space (denumerable (denumerable (denumerable char))) := sorry --non-trivial
lemma new_lemma_107590 (h0 : semiring (has_top (has_norm num))) : is_noetherian_ring (has_top (has_norm num)) := sorry --non-trivial
lemma new_lemma_107591 (h0 : cancel_comm_monoid_with_zero (add_cancel_monoid (div_inv_monoid (has_pos_part (finset pos))))) : unique_factorization_monoid (add_cancel_monoid (div_inv_monoid (has_pos_part (finset pos)))) := sorry --non-trivial
lemma new_lemma_107592 (h0 : topological_space (with_bot (with_bot string_imp))) : t0_space (with_bot (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_107593 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (add_cancel_monoid.{0} (option.{0} (option.{0} ennreal))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} (option.{0} (option.{0} ennreal))))  := sorry --non-trivial
lemma new_lemma_107594 (h0 : function.extfun (nat -> Type) (function.extfun nat)) (h1 : decidable_pred (function.extfun_app (function.extfun_app h0 (fun (x : nat), Prop)))) (h2 : Exists (fun (n : nat), function.extfun_app (function.extfun_app h0 (fun (x : nat), Prop)) n)) (h3 : function.extfun Type monoid) (h4 : nat) : conjugates_of h4 (nat.find h2) := sorry --non-trivial
lemma new_lemma_107595 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_107596 (h0 : complete_lattice (has_nndist name)) : is_atomistic (has_nndist name) := sorry --non-trivial
lemma new_lemma_107597 (h0 : topological_space (has_nndist (option name))) : totally_separated_space (has_nndist (option name)) := sorry --non-trivial
lemma new_lemma_107598 (h0 : complete_lattice (uniform_space (has_div string.iterator_imp))) : complete_lattice.is_Sup_finite_compact (uniform_space (has_div string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_107599 (h0 : finset (has_Inf (has_Inf pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_107600 (h0 : ring (ring (cancel_monoid Type))) : is_principal_ideal_ring (ring (cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_107601 (h0 : group (ordered_comm_monoid (has_neg pos))) : group.fg (ordered_comm_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_107602 (h0 : uniform_space (distrib_lattice linarith.comp_source)) : complete_space (distrib_lattice linarith.comp_source) := sorry --non-trivial
lemma new_lemma_107603 (h0 : functor.add_const (list (has_neg linarith.comp)) environment.implicit_infer_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_107604 (h0 : fin has_zero.zero) : @strong_rank_condition.{0} (ordered_comm_monoid.{0} real) (@matrix.vec_empty.{0} (ring.{0} (ordered_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_107605 (h0 : topological_space (ordered_comm_monoid (ring Type))) : sequential_space (ordered_comm_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_107606 (h0 : functor.add_const (ordered_add_comm_monoid (has_Inf name)) (ring (ring Type))) : @archimedean.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (has_Inf.{0} name)) (ring.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_107607 (h0 : functor.add_const (function.extfun Type topological_space) (has_neg name)) : @t0_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_neg.{0} name) h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_107608 (h0 : uniform_space (canonically_ordered_comm_semiring (option (option num)))) : complete_space (canonically_ordered_comm_semiring (option (option num))) := sorry --non-trivial
lemma new_lemma_107609 (h0 : functor.add_const (topological_space (has_zero pos)) Type) : @topological_space.separable_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_107610 (h0 : monoid (cancel_monoid (ring name))) : monoid.fg (cancel_monoid (ring name)) := sorry --non-trivial
lemma new_lemma_107611 (h0 : functor.add_const (topological_space (simple_graph pos)) pos) : @topological_space.separable_space.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_107612 (h1 : filter (fintype (add_monoid (add_monoid (add_monoid (comm_ring (fintype (add_monoid char)))))))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_107613 (h0 : functor.comp complete_lattice boolean_algebra name) : @is_atomistic.{0} (boolean_algebra.{0} name) (@functor.comp.run.{0 0 0} complete_lattice.{0} boolean_algebra.{0} name h0)  := sorry --non-trivial
lemma new_lemma_107614 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_emptyc linarith.ineq)) := sorry --non-trivial
lemma new_lemma_107615 (h0 : function.extfun Type (functor.comp ring mul_zero_class)) : @is_principal_ideal_ring.{0} (mul_zero_class.{0} ennreal) (@functor.comp.run.{0 0 0} ring.{0} mul_zero_class.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} mul_zero_class.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_107616 (h1 : topological_space (uniform_space to_additive.value_type)) : path_connected_space (uniform_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_107617 (h0 : functor.add_const (add_group (ordered_comm_ring Type)) (ordered_ring pos)) : @is_add_cyclic.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (ordered_comm_ring.{1} Type)) (ordered_ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_107618 (h2 : list (has_norm string_imp)) : list.nodup h2 := sorry --non-trivial
lemma new_lemma_107619 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (add_left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (add_left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_107620 (h0 : functor.add_const (ring (has_add pos)) pos) : @is_principal_ideal_ring.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_107621 (h0 : functor.add_const (group (has_to_string pos)) unsigned) : @is_simple_group.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_107622 (h0 : ordered_comm_monoid (canonically_ordered_monoid (has_Inf real))) : has_exists_mul_of_le (canonically_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_107623 (h0 : topological_space (boolean_algebra.core (option ennreal))) : t1_space (boolean_algebra.core (option ennreal)) := sorry --non-trivial
lemma new_lemma_107624 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (encodable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (encodable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_107625 (h0 : semiring (with_one unsigned)) : is_noetherian_ring (with_one unsigned) := sorry --non-trivial
lemma new_lemma_107626 (h0 : ring (has_append (semi_normed_ring (random_gen (distrib to_additive.value_type))))) : rank_condition (has_append (semi_normed_ring (random_gen (distrib to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_107627 (h0 : functor.add_const (uniform_space (bin_tree unsigned)) unsigned) : @separated_space.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (bin_tree.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_107628 (h0 : complete_lattice (has_nndist (has_add environment.implicit_infer_kind))) : complete_lattice.is_Sup_finite_compact (has_nndist (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_107629 (h0 : ring (has_add (has_nnnorm (has_nnnorm fun_info)))) : rank_condition (has_add (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_107630 (h0 : function.extfun Type topological_space) : @t0_space.{0} real.angle (@function.extfun_app.{2 1} Type topological_space.{0} h0 real.angle)  := sorry --non-trivial
lemma new_lemma_107631 (h0 : ring (has_emptyc congr_arg_kind)) : rank_condition (has_emptyc congr_arg_kind) := sorry --non-trivial
lemma new_lemma_107632 (h0 : filter (with_one (has_top (semiring linarith.comp)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_107633 (h0 : not (topological_space (has_append reducibility_hints) -> false)) : @totally_disconnected_space.{0} (has_append.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (has_append.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_107634 (h0 : fin has_zero.zero) : @add_monoid.fg.{0} (canonically_ordered_monoid.{0} name) (@matrix.vec_empty.{0} (add_monoid.{0} (canonically_ordered_monoid.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_107635 (h0 : monoid (has_one (semigroup num))) : monoid.fg (has_one (semigroup num)) := sorry --non-trivial
lemma new_lemma_107636 (h0 : topological_space (has_nndist (option ennreal))) : totally_separated_space (has_nndist (option ennreal)) := sorry --non-trivial
lemma new_lemma_107637 (h0 : functor.add_const (topological_space (mul_zero_class Type)) Type) : @preconnected_space.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (mul_zero_class.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_107638 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (uniform_space.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (uniform_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_107639 (h0 : function.extfun (Type 1) (functor.comp topological_space boolean_algebra)) : @path_connected_space.{1} (boolean_algebra.{1} (has_add.{1} (add_comm_monoid.{1} (boolean_algebra.core.{1} Type)))) (@functor.comp.run.{1 1 1} topological_space.{1} boolean_algebra.{1} (has_add.{1} (add_comm_monoid.{1} (boolean_algebra.core.{1} Type))) (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} boolean_algebra.{1}) h0 (has_add.{1} (add_comm_monoid.{1} (boolean_algebra.core.{1} Type)))))  := sorry --non-trivial
lemma new_lemma_107640 (h0 : functor.add_const (list (has_neg pos)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_107641 (h0 : ring (normed_comm_ring (has_nndist pos))) : rank_condition (normed_comm_ring (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_107642 (h0 : group (ordered_comm_ring (finset pos))) : normalizer_condition (ordered_comm_ring (finset pos)) := sorry --non-trivial
lemma new_lemma_107643 (h0 : functor.add_const (function.extfun (Type 1) ordered_add_comm_monoid) linarith.comp) : @archimedean.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_add_comm_monoid.{1}) linarith.comp h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_107644 (h0 : topological_space (comm_semigroup (has_pos_part (has_bot (has_bot (has_bot pos)))))) : t1_space (comm_semigroup (has_pos_part (has_bot (has_bot (has_bot pos))))) := sorry --non-trivial
lemma new_lemma_107645 (h0 : topological_space (left_cancel_monoid (semiring (semiring (semiring (semiring unsigned)))))) : totally_separated_space (left_cancel_monoid (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_107646 (h0 : uniform_space (simple_graph (has_add pos))) : separated_space (simple_graph (has_add pos)) := sorry --non-trivial
lemma new_lemma_107647 (h0 : topological_space (generalized_boolean_algebra (has_pos_part (ring Type)))) : totally_separated_space (generalized_boolean_algebra (has_pos_part (ring Type))) := sorry --non-trivial
lemma new_lemma_107648 (h0 : group (measure_theory.measure_space (semiring (semiring congr_arg_kind)))) : group.fg (measure_theory.measure_space (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_107649 (h0 : ring (linear_ordered_comm_group num)) : is_principal_ideal_ring (linear_ordered_comm_group num) := sorry --non-trivial
lemma new_lemma_107650 (h0 : group (has_nndist (add_comm_monoid Type))) : group.fg (has_nndist (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_107651 (h0 : function.extfun (Type 1) list) : list.nodup (function.extfun_app h0 (pseudo_metric_space Type)) := sorry --non-trivial
lemma new_lemma_107652 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (monoid_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (monoid_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_107653 (h0 : functor.add_const (ring (complete_distrib_lattice pos)) pos) : @is_principal_ideal_ring.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_107654 (h0 : complete_lattice (random_gen num)) : complete_lattice.is_Sup_finite_compact (random_gen num) := sorry --non-trivial
lemma new_lemma_107655 (h0 : topological_space (id (has_inv to_additive.value_type))) : locally_compact_space (id (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_107656 (h0 : functor.comp complete_lattice has_neg_part Type) : @is_compactly_generated.{1} (has_neg_part.{1} Type) (@functor.comp.run.{1 1 1} complete_lattice.{1} has_neg_part.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_107657 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_107658 (h0 : functor.add_const (list (has_pos_part linarith.comp)) (ring pos)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_107659 (h0 : not (topological_space (id congr_arg_kind) -> false)) : @path_connected_space.{0} (@id.{2} Type congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_107660 (h0 : ring (has_emptyc (has_top linarith.comp_source))) : strong_rank_condition (has_emptyc (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_107661 (h0 : functor.add_const (topological_space (ring Type)) Type) : @regular_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_107662 (h0 : not (has_mem.mem (has_norm to_additive.value_type) has_emptyc.emptyc -> false)) : @is_domain.{0} (has_norm.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type ring.{0} (has_norm.{0} to_additive.value_type) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} to_additive.value_type) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_107663 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @complete_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) uniform_space.{0}) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_107664 (h0 : topological_space (has_one fun_info)) : normal_space (has_one fun_info) := sorry --non-trivial
lemma new_lemma_107665 (h0 : complete_lattice (preorder unsigned)) : complete_lattice.is_Sup_finite_compact (preorder unsigned) := sorry --non-trivial
lemma new_lemma_107666 (h0 : topological_space (canonically_ordered_monoid real)) : locally_compact_space (canonically_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_107667 (h0 : functor.comp topological_space comm_group unsigned) : @regular_space.{0} (comm_group.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_107668 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : palindrome (function.extfun_app (function.extfun_app h0 list) (add_cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_107669 (h0 : ordered_add_comm_monoid (generalized_boolean_algebra (ring (has_add pos)))) : archimedean (generalized_boolean_algebra (ring (has_add pos))) := sorry --non-trivial
lemma new_lemma_107670 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (filter congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_107671 (h1 : group (denumerable (denumerable (denumerable reducibility_hints)))) : is_cyclic (denumerable (denumerable (denumerable reducibility_hints))) := sorry --non-trivial
lemma new_lemma_107672 (h0 : function.extfun nat fin) : @t1_space.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_107673 (h0 : topological_space (linear_ordered_comm_group (has_to_string ennreal))) : loc_path_connected_space (linear_ordered_comm_group (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_107674 (h0 : function.extfun Type group) : @normalizer_condition.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_107675 (h0 : topological_space string_imp) : t0_space string_imp := sorry --non-trivial
lemma new_lemma_107676 (h0 : functor.add_const (group (has_neg environment.implicit_infer_kind)) Type) : @is_cyclic.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (group.{0} (has_neg.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_107677 (h0 : functor.comp topological_space has_zero Type) : @normal_space.{1} (has_zero.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_zero.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_107678 (h0 : topological_space (simple_graph (has_nndist (has_add Type)))) : locally_compact_space (simple_graph (has_nndist (has_add Type))) := sorry --non-trivial
lemma new_lemma_107679 (h0 : finset (canonically_linear_ordered_monoid (has_add (has_Inf pos)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_107680 (h0 : functor.comp topological_space add_cancel_monoid Type) : @sequential_space.{1} (add_cancel_monoid.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} add_cancel_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_107681 (h0 : topological_space (has_pos_part (sub_neg_monoid name))) : sequential_space (has_pos_part (sub_neg_monoid name)) := sorry --non-trivial
lemma new_lemma_107682 (h0 : ring (random_gen (add_cancel_comm_monoid string_imp))) : rank_condition (random_gen (add_cancel_comm_monoid string_imp)) := sorry --non-trivial
lemma new_lemma_107683 (h0 : topological_space (fintype fun_info)) : locally_compact_space (fintype fun_info) := sorry --non-trivial
lemma new_lemma_107684 (h0 : group (semigroup (option pos))) : group.fg (semigroup (option pos)) := sorry --non-trivial
lemma new_lemma_107685 (h0 : add_group (boolean_algebra.core (normed_comm_ring unsigned))) : is_add_cyclic (boolean_algebra.core (normed_comm_ring unsigned)) := sorry --non-trivial
lemma new_lemma_107686 (h0 h1 : multiset (normed_field string.iterator_imp)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_107687 (h0 : ring (with_one (has_union linarith.comp))) : strong_rank_condition (with_one (has_union linarith.comp)) := sorry --non-trivial
lemma new_lemma_107688 (h0 : ring (distrib_lattice (has_nnnorm char))) : is_domain (distrib_lattice (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_107689 (h0 : functor.add_const (function.extfun Type group) Type) : @is_simple_group.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_107690 (h0 : topological_space (complete_distrib_lattice (ring name))) : irreducible_space (complete_distrib_lattice (ring name)) := sorry --non-trivial
lemma new_lemma_107691 (h0 : monoid (with_bot linarith.comp)) : monoid.fg (with_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_107692 (h0 : set (has_ssubset linarith.ineq)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_107693 (h0 : add_monoid (add_group empty)) (h1 : ring (add_units (add_group empty))) : is_domain (add_units (add_group empty)) := sorry --non-trivial
lemma new_lemma_107694 (h0 : monoid (measurable_space (has_norm (has_norm (semiring (random_gen linarith.comp_source)))))) : monoid.fg (measurable_space (has_norm (has_norm (semiring (random_gen linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_107695 (h1 : ring (normed_field linarith.comp_source)) : strong_rank_condition (normed_field linarith.comp_source) := sorry --non-trivial
lemma new_lemma_107696 (h0 : function.extfun Type ring) : @rank_condition.{0} (dlist.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (dlist.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_107697 (h0 : complete_lattice (finset (boolean_algebra.core pos))) : is_atomistic (finset (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_107698 (h0 : ring (has_zero Type)) : is_principal_ideal_ring (has_zero Type) := sorry --non-trivial
lemma new_lemma_107699 (h0 : not (topological_space (mul_zero_class num) -> false)) : @totally_separated_space.{0} (mul_zero_class.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (mul_zero_class.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_107700 (h0 : group (has_zero (has_neg (finset Type)))) : group.fg (has_zero (has_neg (finset Type))) := sorry --non-trivial
lemma new_lemma_107701 (h1 : group (with_zero (random_gen (linear_ordered_add_comm_group (has_nnnorm char))))) : is_cyclic (with_zero (random_gen (linear_ordered_add_comm_group (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_107702 (h0 : functor.add_const (topological_space (ordered_comm_ring name)) pos) : @preirreducible_space.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_107703 (h0 : list (has_zero (has_add pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_107704 (h0 : functor.add_const (function.extfun Type semiring) name) : @is_noetherian_ring.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) name h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_107705 (h0 : complete_lattice (finset (has_neg (has_neg pos)))) : complete_lattice.is_Sup_finite_compact (finset (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_107706 (h0 : functor.add_const (fin has_zero.zero) Type) : @unique_factorization_monoid.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (cancel_comm_monoid_with_zero.{1} (has_add.{1} Type)) (@functor.add_const.run.{0 1} (fin (@has_zero.zero.{0} nat nat.has_zero)) Type h0))  := sorry --non-trivial
lemma new_lemma_107707 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) (has_Inf Type)) : @loc_path_connected_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_ring.{0} pos)) (has_Inf.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_107708 (h0 : group (boolean_algebra (has_add (has_add Type)))) : is_simple_group (boolean_algebra (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_107709 (h0 : set (has_ssubset (mul_one_class (mul_one_class (mul_one_class string.iterator_imp))))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_107710 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (left_cancel_monoid.{0} (semiring.{0} (semiring.{0} unsigned))) (@function.extfun_app.{2 1} Type ring.{0} h0 (left_cancel_monoid.{0} (semiring.{0} (semiring.{0} unsigned))))  := sorry --non-trivial
lemma new_lemma_107711 (h0 : not (ring (has_emptyc (random_gen linarith.comp_source)) -> false)) : @strong_rank_condition.{0} (has_emptyc.{0} (random_gen.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (ring.{0} (has_emptyc.{0} (random_gen.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_107712 (h0 : has_mem.mem (measurable_space linarith.ineq) has_emptyc.emptyc) : @is_domain.{0} (measurable_space.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type ring.{0} (measurable_space.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_107713 (h0 : functor.add_const (ring (ring pos)) (has_neg pos)) : @is_principal_ideal_ring.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} pos)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_107714 (h0 : functor.add_const (list (add_cancel_monoid environment.implicit_infer_kind)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_107715 (h0 : uniform_space (comm_group (option name))) : separated_space (comm_group (option name)) := sorry --non-trivial
lemma new_lemma_107716 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_107717 (h0 : topological_space (has_Sup (semiring (semiring congr_arg_kind)))) : t0_space (has_Sup (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_107718 (h0 : ring (has_nndist (mul_zero_class unsigned))) : is_principal_ideal_ring (has_nndist (mul_zero_class unsigned)) := sorry --non-trivial
lemma new_lemma_107719 (h0 : ring (pseudo_metric_space (canonically_ordered_comm_semiring unsigned))) : strong_rank_condition (pseudo_metric_space (canonically_ordered_comm_semiring unsigned)) := sorry --non-trivial
lemma new_lemma_107720 (h0 : functor.add_const (function.extfun Type topological_space) real) : @locally_compact_space.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) real h0) (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_107721 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem monoid)) : @monoid.fg.{0} empty (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) monoid.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) empty)  := sorry --non-trivial
lemma new_lemma_107722 (h0 : add_group (random_gen (bin_tree (denumerable (has_top (denumerable to_additive.value_type)))))) : is_add_cyclic (random_gen (bin_tree (denumerable (has_top (denumerable to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_107723 (h0 : finset (has_inter ennreal)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_107724 (h0 : not (complete_lattice (left_cancel_semigroup congr_arg_kind) -> false)) : @is_atomistic.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (left_cancel_semigroup.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_107725 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) (has_Inf pos)) : @sequential_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_107726 (h0 : function.extfun (Type 1) semiring) : @is_noetherian_ring.{1} (plift.{1} num) (@function.extfun_app.{3 2} (Type 1) semiring.{1} h0 (plift.{1} num))  := sorry --non-trivial
lemma new_lemma_107727 (h0 : group (normed_lattice_add_comm_group (has_bot (comm_semigroup real)))) : is_cyclic (normed_lattice_add_comm_group (has_bot (comm_semigroup real))) := sorry --non-trivial
lemma new_lemma_107728 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_107729 (h0 : functor.add_const (complete_lattice (complete_distrib_lattice Type)) ennreal) : @is_atomistic.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (complete_distrib_lattice.{1} Type)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_107730 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_edist.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_edist.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_107731 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (non_assoc_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (non_assoc_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_107732 (h0 : topological_space (has_to_string (has_nndist (finset name)))) : irreducible_space (has_to_string (has_nndist (finset name))) := sorry --non-trivial
lemma new_lemma_107733 (h0 : topological_space (left_cancel_monoid (semiring (semiring (semiring (semiring empty)))))) : loc_path_connected_space (left_cancel_monoid (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_107734 (h0 : monoid (with_one (has_top linarith.comp_source))) : monoid.fg (with_one (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_107735 (h0 : functor.add_const Prop (has_neg_part (has_neg linarith.comp))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_107736 (h0 : function.extfun Type group) : @normalizer_condition.{0} (left_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (left_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_107737 (h0 : ordered_comm_monoid (has_zero name)) : has_exists_mul_of_le (has_zero name) := sorry --non-trivial
lemma new_lemma_107738 (h0 : function.extfun Type (functor.add_const (semiring (semiring num)))) : @is_noetherian_ring.{0} (semiring.{0} num) (@functor.add_const.run.{0 0} (semiring.{0} (semiring.{0} num)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (semiring.{0} (semiring.{0} num))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_107739 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @t0_space.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_107740 (h0 : topological_space (comm_semigroup (sub_neg_monoid (sub_neg_monoid (has_add pos))))) : preirreducible_space (comm_semigroup (sub_neg_monoid (sub_neg_monoid (has_add pos)))) := sorry --non-trivial
lemma new_lemma_107741 (h0 : functor.add_const (topological_space (ordered_comm_monoid Type)) linarith.comp) : @t0_space.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_107742 (h0 : topological_space (normed_lattice_add_comm_group (has_add (has_add Type)))) : t0_space (normed_lattice_add_comm_group (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_107743 (h0 : functor.add_const (complete_lattice (finset Type)) name) : @complete_lattice.is_Sup_finite_compact.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (finset.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_107744 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @t1_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_107745 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_107746 (h0 : functor.add_const (add_group (has_add Type)) (has_neg Type)) : @is_add_cyclic.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (add_group.{1} (has_add.{1} Type)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_107747 (h0 : functor.add_const (cancel_comm_monoid_with_zero (measurable_space num)) num) : @unique_factorization_monoid.{0} (measurable_space.{0} num) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (measurable_space.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_107748 (h2 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h2 (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_107749 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_107750 (h0 : fin has_zero.zero) : matrix.vec_empty (matrix.vec_empty (matrix.vec_empty (id h0))) := sorry --non-trivial
lemma new_lemma_107751 (h0 : group (has_norm (random_gen (has_nnnorm (has_top linarith.comp_source))))) : group.fg (has_norm (random_gen (has_nnnorm (has_top linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_107752 (h0 : group (has_add (has_neg Type))) : is_cyclic (has_add (has_neg Type)) := sorry --non-trivial
lemma new_lemma_107753 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_107754 (h0 : monoid (plift num)) : monoid.fg (plift num) := sorry --non-trivial
lemma new_lemma_107755 (h0 : topological_space (linear_ordered_field (option empty))) : discrete_topology (linear_ordered_field (option empty)) := sorry --non-trivial
lemma new_lemma_107756 (h0 : nat -> Prop -> Prop) (h1 : nat) (h2 : Prop) : nat.repeat h0 h1 h2 := sorry --non-trivial
lemma new_lemma_107757 (h0 : group (dlist int)) : is_cyclic (dlist int) := sorry --non-trivial
lemma new_lemma_107758 (h0 : complete_lattice (as_linear_order empty)) : is_atomistic (as_linear_order empty) := sorry --non-trivial
lemma new_lemma_107759 (h0 : topological_space (finset (ordered_comm_monoid pos))) : normal_space (finset (ordered_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_107760 (h0 : not (topological_space (option unsigned) -> false)) : @totally_separated_space.{0} (option.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_107761 (h0 : topological_space (has_zero (has_neg_part linarith.comp))) : preconnected_space (has_zero (has_neg_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_107762 (h1 : has_lt (has_le linarith.ineq)) : no_max_order (has_le linarith.ineq) := sorry --non-trivial
lemma new_lemma_107763 (h0 : not (semiring (measurable_space.dynkin_system empty) -> false)) : @is_noetherian_ring.{0} (measurable_space.dynkin_system.{0} empty) (@classical.by_contradiction'.{1} (semiring.{0} (measurable_space.dynkin_system.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_107764 (h2 : topological_space (comm_ring (denumerable fun_info))) : totally_disconnected_space (comm_ring (denumerable fun_info)) := sorry --non-trivial
lemma new_lemma_107765 (h0 : topological_space (has_ssubset (random_gen linarith.comp_source))) : locally_compact_space (has_ssubset (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_107766 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_107767 (h2 : complete_lattice (has_ssubset linarith.ineq)) : is_compactly_generated (has_ssubset linarith.ineq) := sorry --non-trivial
lemma new_lemma_107768 (h0 : ring (add_comm_monoid ennreal)) : is_domain (add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_107769 (h0 : uniform_space (normed_comm_ring (normed_comm_ring Type))) : complete_space (normed_comm_ring (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_107770 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (has_add.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_107771 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (with_one.{0} (has_inv.{0} (has_norm.{0} (has_top.{0} (has_top.{0} linarith.comp_source))))) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (with_one.{0} (has_inv.{0} (has_norm.{0} (has_top.{0} (has_top.{0} linarith.comp_source))))))  := sorry --non-trivial
lemma new_lemma_107772 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_107773 (h0 : topological_space (has_one (has_top (has_top to_additive.value_type)))) : discrete_topology (has_one (has_top (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_107774 (h1 : ring (uniform_space (random_gen linarith.comp_source))) : strong_rank_condition (uniform_space (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_107775 (h0 : functor.add_const (topological_space (has_nndist name)) Type) : @t1_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_107776 (h0 : set (has_nnnorm linarith.ineq)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_107777 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_107778 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (complete_linear_order.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (complete_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_107779 (h0 : group (add_right_cancel_monoid num)) : is_cyclic (add_right_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_107780 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_107781 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (with_bot.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} linarith.ineq))))) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (with_bot.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} linarith.ineq))))))  := sorry --non-trivial
lemma new_lemma_107782 (h0 : cancel_comm_monoid_with_zero (pseudo_metric_space (option ennreal))) : unique_factorization_monoid (pseudo_metric_space (option ennreal)) := sorry --non-trivial
lemma new_lemma_107783 (h0 : function.extfun Type topological_space) : @t1_space.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_107784 (h0 : partial_order (complete_linear_order (has_star empty))) (h1 : order_top (complete_linear_order (has_star empty))) : is_coatomic (complete_linear_order (has_star empty)) := sorry --non-trivial
lemma new_lemma_107785 (h0 : ordered_add_comm_monoid (has_to_string (semigroup environment.implicit_infer_kind))) : archimedean (has_to_string (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_107786 (h0 : functor.add_const (ring (complete_linear_order num)) num) : @is_domain.{0} (complete_linear_order.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (complete_linear_order.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_107787 (h0 : topological_space (ordered_cancel_add_comm_monoid (option unsigned))) : topological_space.separable_space (ordered_cancel_add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_107788 (h0 : ring (random_gen (has_inv (has_inv (has_inv (has_inv linarith.comp_source)))))) : rank_condition (random_gen (has_inv (has_inv (has_inv (has_inv linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_107789 (h2 : topological_space (add_comm_semigroup (mul_one_class string.iterator_imp))) : totally_disconnected_space (add_comm_semigroup (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_107790 (h0 : ring (canonically_ordered_monoid (canonically_linear_ordered_monoid linarith.comp))) : strong_rank_condition (canonically_ordered_monoid (canonically_linear_ordered_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_107791 (h0 : ordered_add_comm_monoid (semilattice_inf unsigned)) : archimedean (semilattice_inf unsigned) := sorry --non-trivial
lemma new_lemma_107792 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_to_string num)) := sorry --non-trivial
lemma new_lemma_107793 (h0 : finset (sub_neg_monoid linarith.comp)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_107794 (h0 : topological_space (normed_field (mul_one_class reducibility_hints))) : t0_space (normed_field (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_107795 (h0 : functor.add_const (ring (semigroup num)) empty) : @is_domain.{0} (semigroup.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_107796 (h0 : function.extfun (Type 1) add_monoid) : @add_monoid.fg.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} h0 (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_107797 (h0 : list (encodable to_additive.value_type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_107798 (h1 : topological_space (fintype linarith.comp)) : t0_space (fintype linarith.comp) := sorry --non-trivial
lemma new_lemma_107799 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring unsigned)) pos) : @is_domain.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (canonically_ordered_comm_semiring.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_107800 (h0 : complete_lattice (normed_lattice_add_comm_group (canonically_ordered_monoid real))) : is_atomistic (normed_lattice_add_comm_group (canonically_ordered_monoid real)) := sorry --non-trivial
lemma new_lemma_107801 (h0 : cancel_comm_monoid_with_zero (canonically_ordered_comm_semiring (option empty))) : unique_factorization_monoid (canonically_ordered_comm_semiring (option empty)) := sorry --non-trivial
lemma new_lemma_107802 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_disconnected_space.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_107803 (h0 : fin has_zero.zero) : @regular_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_107804 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (sub_neg_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (sub_neg_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_107805 (h0 : add_group (distrib reducibility_hints)) : is_add_cyclic (distrib reducibility_hints) := sorry --non-trivial
lemma new_lemma_107806 (h0 : functor.add_const (topological_space (has_zero name)) pos) : @sequential_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_107807 (h0 : ring (has_add (random_gen fun_info))) : rank_condition (has_add (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_107808 (h0 : functor.add_const (ring (bin_tree congr_arg_kind)) unsigned) : @rank_condition.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (bin_tree.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_107809 (h5 : measurable_space (normed_field char)) (h6 : measure_theory.measure (normed_field char)) : measure_theory.is_finite_measure h6 := sorry --non-trivial
lemma new_lemma_107810 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (linear_ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_107811 (h0 : ring (has_nnnorm (random_gen (encodable (random_gen (random_gen linarith.comp_source)))))) : rank_condition (has_nnnorm (random_gen (encodable (random_gen (random_gen linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_107812 (h0 : ring (complete_linear_order num)) : is_principal_ideal_ring (complete_linear_order num) := sorry --non-trivial
lemma new_lemma_107813 (h0 : ordered_add_comm_monoid (monoid_with_zero (option pos))) : archimedean (monoid_with_zero (option pos)) := sorry --non-trivial
lemma new_lemma_107814 (h0 : not (uniform_space (linear_ordered_semiring fun_info) -> false)) : @separated_space.{0} (linear_ordered_semiring.{0} fun_info) (@classical.by_contradiction'.{1} (uniform_space.{0} (linear_ordered_semiring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_107815 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_Sup empty)) := sorry --non-trivial
lemma new_lemma_107816 (h1 : set (simple_graph std_gen)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_107817 (h0 : functor.add_const (topological_space (finset unsigned)) (option num)) : @locally_compact_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} unsigned)) (option.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_107818 (h0 : function.extfun Type topological_space) : @t1_space.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_107819 (h0 : group (dlist (has_nnnorm (has_nnnorm linarith.comp_source)))) : group.fg (dlist (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_107820 (h0 : function.extfun Type (functor.comp topological_space mul_zero_class)) : @discrete_topology.{0} (mul_zero_class.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} mul_zero_class.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} mul_zero_class.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_107821 (h0 : topological_space (denumerable (has_nnnorm (has_nnnorm reducibility_hints)))) : t0_space (denumerable (has_nnnorm (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_107822 (h0 : not (cancel_comm_monoid_with_zero (linear_ordered_comm_ring unsigned) -> false)) : @unique_factorization_monoid.{0} (linear_ordered_comm_ring.{0} unsigned) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (linear_ordered_comm_ring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_107823 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @totally_disconnected_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_107824 (h0 : group (linear_ordered_add_comm_group to_additive.value_type)) : is_cyclic (linear_ordered_add_comm_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_107825 (h0 : functor.add_const (filter (has_zero Type)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_107826 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) znum) := sorry --non-trivial
lemma new_lemma_107827 (h2 : add_group (mul_one_class environment.projection_info)) : is_add_cyclic (mul_one_class environment.projection_info) := sorry --non-trivial
lemma new_lemma_107828 (h0 : group (sub_neg_monoid (boolean_algebra.core (finset linarith.comp)))) : normalizer_condition (sub_neg_monoid (boolean_algebra.core (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_107829 (h0 : functor.comp topological_space mul_zero_class name) : @topological_space.separable_space.{0} (mul_zero_class.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} mul_zero_class.{0} name h0)  := sorry --non-trivial
lemma new_lemma_107830 (h1 : list linarith.comp_source) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_107831 (h0 : topological_space (canonically_ordered_comm_semiring (has_to_string ennreal))) : preconnected_space (canonically_ordered_comm_semiring (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_107832 (h0 : add_comm_monoid pos -> add_comm_monoid pos -> Prop) : well_founded h0 := sorry --non-trivial
lemma new_lemma_107833 (h0 : function.extfun Type group) : @normalizer_condition.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_107834 (h0 : functor.add_const (complete_lattice (has_zero pos)) Type) : @is_atomistic.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_zero.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_107835 (h0 : uniform_space (with_one (semiring empty))) : complete_space (with_one (semiring empty)) := sorry --non-trivial
lemma new_lemma_107836 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type add_group.{0} h0 (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_107837 (h0 : complete_lattice (left_cancel_monoid (semiring empty))) : is_atomistic (left_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_107838 (h0 : not (monoid (complete_linear_order empty) -> false)) : @monoid.fg.{0} (complete_linear_order.{0} empty) (@classical.by_contradiction'.{1} (monoid.{0} (complete_linear_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_107839 (h0 : group (normed_comm_ring (finset (ring (ring linarith.comp))))) : is_simple_group (normed_comm_ring (finset (ring (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_107840 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (denumerable.{0} string_imp) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (denumerable.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_107841 (h0 : filter (boolean_algebra.core linarith.comp)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_107842 (h0 : functor.add_const (group (has_neg_part environment.implicit_infer_kind)) linarith.comp) : @normalizer_condition.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_neg_part.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_107843 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_107844 (h0 : set (has_compl ereal)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_107845 (h0 : topological_space (has_add (has_add Type))) : locally_compact_space (has_add (has_add Type)) := sorry --non-trivial
lemma new_lemma_107846 (h0 : functor.add_const (topological_space (has_add real)) real) : @irreducible_space.{0} (has_add.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_107847 (h0 : functor.add_const (add_monoid (generalized_boolean_algebra Type)) (finset Type)) : @add_monoid.fg.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (add_monoid.{1} (generalized_boolean_algebra.{1} Type)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_107848 (h0 : topological_space (has_to_string Type)) : locally_compact_space (has_to_string Type) := sorry --non-trivial
lemma new_lemma_107849 (h0 : list (has_zero (finset (has_add pos)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_107850 (h0 : not (group (normed_group char) -> false)) : @is_cyclic.{0} (normed_group.{0} char) (@classical.by_contradiction'.{1} (group.{0} (normed_group.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_107851 (h0 : functor.add_const (ordered_add_comm_monoid (semigroup num)) empty) : @archimedean.{0} (semigroup.{0} num) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (semigroup.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_107852 (h0 : functor.add_const (uniform_space (has_zero environment.implicit_infer_kind)) pos) : @complete_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_zero.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_107853 (h0 : add_monoid (with_bot (has_norm (semiring (has_norm unsigned))))) : add_monoid.fg (with_bot (has_norm (semiring (has_norm unsigned)))) := sorry --non-trivial
lemma new_lemma_107854 (h0 : finset (has_neg (finset name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_107855 (h0 : function.extfun (Type 1) (functor.comp topological_space has_add)) : @discrete_topology.{1} (has_add.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_add.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} has_add.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_107856 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_107857 (h0 : uniform_space (linear_ordered_field name)) : complete_space (linear_ordered_field name) := sorry --non-trivial
lemma new_lemma_107858 (h0 : add_monoid (canonically_ordered_comm_semiring (finset linarith.comp))) : add_monoid.fg (canonically_ordered_comm_semiring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_107859 (h0 : topological_space (with_bot (has_norm linarith.comp))) : normal_space (with_bot (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_107860 (h0 : topological_space (has_pos_part (has_neg pos))) : preconnected_space (has_pos_part (has_neg pos)) := sorry --non-trivial
lemma new_lemma_107861 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_107862 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_add_cyclic.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 add_group.{1}) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_107863 (h2 : uniform_space (topological_space to_additive.value_type)) : complete_space (topological_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_107864 (h0 : ordered_add_comm_monoid (has_Inf Type)) : archimedean (has_Inf Type) := sorry --non-trivial
lemma new_lemma_107865 (h0 : topological_space (ring environment.implicit_infer_kind)) : loc_path_connected_space (ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_107866 (h4 : topological_space (add_comm_semigroup linarith.ineq)) (h5 : set (add_comm_semigroup linarith.ineq)) : is_path_connected h5 := sorry --non-trivial
lemma new_lemma_107867 (h0 : functor.add_const (list (semigroup unsigned)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_107868 (h1 : topological_space (id to_additive.value_type)) : totally_separated_space (id to_additive.value_type) := sorry --non-trivial
lemma new_lemma_107869 (h0 : ring (has_inv (has_inv linarith.ineq))) : rank_condition (has_inv (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_107870 (h0 : functor.add_const (ring (has_bot unsigned)) congr_arg_kind) : @strong_rank_condition.{0} (has_bot.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_bot.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_107871 (h0 : topological_space (has_zero (has_add (has_neg_part pos)))) : loc_path_connected_space (has_zero (has_add (has_neg_part pos))) := sorry --non-trivial
lemma new_lemma_107872 (h0 : group (has_top (random_gen to_additive.value_type))) : is_cyclic (has_top (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_107873 (h0 : functor.add_const (complete_lattice (has_zero linarith.comp)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_107874 (h0 : fin has_zero.zero) : @t0_space.{0} (simple_graph.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (simple_graph.{0} name))  := sorry --non-trivial
lemma new_lemma_107875 (h0 : group (has_top (semiring (semiring num)))) : normalizer_condition (has_top (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_107876 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (partial_order.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (partial_order.{0} num))  := sorry --non-trivial
lemma new_lemma_107877 (h0 : group (has_zero Type)) : is_simple_group (has_zero Type) := sorry --non-trivial
lemma new_lemma_107878 (h0 : functor.add_const (monoid (has_inter empty)) empty) : @monoid.fg.{0} (has_inter.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (has_inter.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_107879 (h0 : ring (ordered_comm_ring (has_add (has_Inf (has_pos_part Type))))) : is_domain (ordered_comm_ring (has_add (has_Inf (has_pos_part Type)))) := sorry --non-trivial
lemma new_lemma_107880 (h0 : topological_space (complete_semilattice_Sup (has_top fun_info))) : locally_compact_space (complete_semilattice_Sup (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_107881 (h0 : ring (mul_zero_class ennreal)) : is_principal_ideal_ring (mul_zero_class ennreal) := sorry --non-trivial
lemma new_lemma_107882 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (@id.{2} Type (random_gen.{0} string_imp)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (@id.{2} Type (random_gen.{0} string_imp)))  := sorry --non-trivial
lemma new_lemma_107883 (h0 : measurable_space (has_compl (mul_one_class linarith.ineq))) (h1 : filter (has_compl (mul_one_class linarith.ineq))) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_107884 (h0 : group (ring (ring linarith.comp))) : group.fg (ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_107885 (h0 : not (group (div_inv_monoid to_additive.value_type) -> false)) : @is_cyclic.{0} (div_inv_monoid.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (div_inv_monoid.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_107886 (h0 : has_mem.mem (with_bot linarith.comp) has_emptyc.emptyc) : @separated_space.{0} (with_bot.{0} linarith.comp) (@finset.pi.empty.{1 0} Type uniform_space.{0} (with_bot.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_107887 (h2 : has_mem.mem (has_top congr_arg_kind) has_emptyc.emptyc) : @totally_disconnected_space.{0} (has_top.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} congr_arg_kind) h2)  := sorry --non-trivial
lemma new_lemma_107888 (h0 : functor.add_const (ring (has_nndist name)) name) : @rank_condition.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_107889 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_107890 (h0 : function.extfun nat fin) : @is_cyclic.{0} real (@matrix.vec_empty.{0} (group.{0} real) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_107891 (h0 : complete_lattice (pseudo_metric_space (option (option pos)))) : is_compactly_generated (pseudo_metric_space (option (option pos))) := sorry --non-trivial
lemma new_lemma_107892 (h1 : set (measure_theory.measure_space fun_info -> char)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_107893 (h0 : add_monoid (canonically_linear_ordered_monoid (option ennreal))) : add_monoid.fg (canonically_linear_ordered_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_107894 (h1 : complete_lattice (has_lt linarith.ineq)) : complete_lattice.is_Sup_finite_compact (has_lt linarith.ineq) := sorry --non-trivial
lemma new_lemma_107895 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) name) : @topological_space.separable_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_107896 (h0 : complete_lattice (bin_tree (semiring congr_arg_kind))) : is_atomistic (bin_tree (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_107897 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_107898 (h0 : function.extfun Type (functor.comp topological_space boolean_algebra)) : @sequential_space.{0} (boolean_algebra.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} boolean_algebra.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_107899 (h0 : functor.add_const (add_monoid (has_to_string Type)) (ring linarith.comp)) : @add_monoid.fg.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (has_to_string.{1} Type)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_107900 (h1 : ring (add_cancel_comm_monoid to_additive.value_type)) : rank_condition (add_cancel_comm_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_107901 (h0 : add_group (add_cancel_monoid linarith.comp)) : is_add_cyclic (add_cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_107902 (h0 : fin has_zero.zero) : @locally_compact_space.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (simple_graph.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_107903 (h0 : finset (canonically_linear_ordered_monoid (cancel_monoid ennreal))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_107904 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_107905 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @discrete_topology.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_107906 (h0 : ring (normed_comm_ring (ring Type))) : is_domain (normed_comm_ring (ring Type)) := sorry --non-trivial
lemma new_lemma_107907 (h0 : topological_space (has_neg (finset linarith.comp))) : preconnected_space (has_neg (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_107908 (h0 : functor.add_const (add_group (ring environment.implicit_infer_kind)) linarith.comp) : @is_add_cyclic.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_group.{0} (ring.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_107909 (h0 : add_monoid (cancel_monoid num)) : add_monoid.fg (cancel_monoid num) := sorry --non-trivial
lemma new_lemma_107910 (h0 : topological_space (linear_ordered_add_comm_group linarith.ineq)) : locally_compact_space (linear_ordered_add_comm_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_107911 (h0 : functor.add_const (uniform_space (has_star num)) empty) : @separated_space.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_star.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_107912 (h0 : functor.add_const (topological_space (partial_order empty)) empty) : @t1_space.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_107913 (h0 : topological_space (mul_zero_class (finset ennreal))) : totally_separated_space (mul_zero_class (finset ennreal)) := sorry --non-trivial
lemma new_lemma_107914 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) linarith.comp) : @has_exists_mul_of_le.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) linarith.comp h0) (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_107915 (h0 : filter (has_compl (random_gen string_imp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_107916 (h0 : ring (sub_neg_monoid (has_bot real))) : is_domain (sub_neg_monoid (has_bot real)) := sorry --non-trivial
lemma new_lemma_107917 (h0 : topological_space (mul_zero_class name)) : loc_path_connected_space (mul_zero_class name) := sorry --non-trivial
lemma new_lemma_107918 (h0 : filter (has_ssubset (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_107919 (h0 : functor.add_const (add_group (has_edist empty)) empty) : @is_add_cyclic.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (has_edist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_107920 (h1 : add_group (complete_semilattice_Sup string_imp)) : is_add_cyclic (complete_semilattice_Sup string_imp) := sorry --non-trivial
lemma new_lemma_107921 (h0 : functor.add_const (ring (linear_ordered_cancel_comm_monoid unsigned)) empty) : @rank_condition.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_107922 (h0 : functor.add_const (function.extfun (Type 1) ring) Type) : @rank_condition.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) Type h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_107923 (h0 : topological_space (semiring (option (option (option (option unsigned)))))) : totally_separated_space (semiring (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_107924 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_107925 (h1 : topological_space (random_gen to_additive.value_type)) : totally_disconnected_space (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_107926 (h0 : functor.add_const (ordered_add_comm_monoid (normed_comm_ring pos)) (finset (has_to_string linarith.comp))) : @archimedean.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (normed_comm_ring.{0} pos)) (finset.{0} (has_to_string.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_107927 (h0 : has_mem.mem add_group has_emptyc.emptyc) : @is_add_cyclic.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} h0) (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_107928 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (has_pos_part.{0} linarith.comp) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_pos_part.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_107929 (h0 : functor.add_const (ring (has_pos_part pos)) (has_neg name)) : @strong_rank_condition.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_pos_part.{0} pos)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_107930 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_107931 (h0 : topological_space (with_one (random_gen (has_ssubset linarith.ineq)))) : t0_space (with_one (random_gen (has_ssubset linarith.ineq))) := sorry --non-trivial
lemma new_lemma_107932 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_107933 (h0 : functor.add_const (functor.comp topological_space has_zero ennreal) name) : @t0_space.{0} (has_zero.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} ennreal (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} topological_space.{0} has_zero.{0} ennreal) name h0))  := sorry --non-trivial
lemma new_lemma_107934 (h0 : functor.add_const (function.extfun Type filter) unsigned) : filter.ne_bot (function.extfun_app (functor.add_const.run h0) (has_top num)) := sorry --non-trivial
lemma new_lemma_107935 (h0 : list (boolean_algebra (has_neg (has_neg linarith.comp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_107936 (h0 : function.extfun nat fin) : @is_simple_group.{0} (canonically_linear_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (group.{0} (canonically_linear_ordered_monoid.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_107937 (h0 : functor.add_const (topological_space (has_to_string pos)) environment.implicit_infer_kind) : @path_connected_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_107938 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_inter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_inter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_107939 (h0 : not (topological_space (comm_ring to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (comm_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (comm_ring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_107940 (h1 : topological_space (simple_graph string_imp)) : totally_disconnected_space (simple_graph string_imp) := sorry --non-trivial
lemma new_lemma_107941 (h0 : topological_space (mul_zero_class num)) : path_connected_space (mul_zero_class num) := sorry --non-trivial
lemma new_lemma_107942 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (mul_zero_class.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (mul_zero_class.{0} empty))  := sorry --non-trivial
lemma new_lemma_107943 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) Type) : @t0_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_107944 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_top.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_107945 (h0 : uniform_space (comm_group (add_comm_monoid Type))) : separated_space (comm_group (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_107946 (h0 : ring (has_neg_part (add_comm_monoid Type))) : is_principal_ideal_ring (has_neg_part (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_107947 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @preirreducible_space.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_pos_part.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_107948 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) name) : @loc_path_connected_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_107949 (h0 : has_mem.mem (measurable_space empty) has_emptyc.emptyc) : @totally_disconnected_space.{0} (measurable_space.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_107950 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) (semigroup Type)) : @irreducible_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) (semigroup.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_107951 (h0 : function.extfun Type (functor.comp ring mul_zero_class)) : @is_domain.{0} (mul_zero_class.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} mul_zero_class.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} mul_zero_class.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_107952 (h0 : topological_space bool) : normal_space bool := sorry --non-trivial
lemma new_lemma_107953 (h0 : topological_space (topological_space (topological_space (has_nnnorm (has_nnnorm char))))) : t0_space (topological_space (topological_space (has_nnnorm (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_107954 (h0 : group (has_inv (has_top (has_top num)))) : is_cyclic (has_inv (has_top (has_top num))) := sorry --non-trivial
lemma new_lemma_107955 (h0 : monoid (random_gen (random_gen linarith.ineq))) : monoid.fg (random_gen (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_107956 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (filter.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} h0 (filter.{0} num))  := sorry --non-trivial
lemma new_lemma_107957 (h0 : topological_space (has_neg (finset (has_neg_part Type)))) : regular_space (has_neg (finset (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_107958 (h0 : topological_space (complete_distrib_lattice (has_to_string num))) : totally_disconnected_space (complete_distrib_lattice (has_to_string num)) := sorry --non-trivial
lemma new_lemma_107959 (h0 : functor.add_const (function.extfun Type group) (ring environment.implicit_infer_kind)) : @is_cyclic.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) (ring.{0} environment.implicit_infer_kind) h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_107960 (h0 : functor.add_const (function.extfun (Type 1) filter) pos) : filter.ne_bot (function.extfun_app (functor.add_const.run h0) (complete_distrib_lattice Type)) := sorry --non-trivial
lemma new_lemma_107961 (h0 : list (group_with_zero num)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_107962 (h0 : list (semigroup Type)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_107963 (h0 : has_mem.mem (comm_ring char) has_emptyc.emptyc) : @strong_rank_condition.{0} (comm_ring.{0} char) (@finset.pi.empty.{1 0} Type ring.{0} (comm_ring.{0} char) h0)  := sorry --non-trivial
lemma new_lemma_107964 (h0 : topological_space (has_nndist (finset unsigned))) : normal_space (has_nndist (finset unsigned)) := sorry --non-trivial
lemma new_lemma_107965 (h0 : ring (has_one (semiring (semiring (semiring (semiring (has_norm linarith.comp))))))) : is_domain (has_one (semiring (semiring (semiring (semiring (has_norm linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_107966 (h0 : function.extfun (Type 1) ring) : @strong_rank_condition.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_107967 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_107968 (h0 : functor.add_const (complete_lattice (has_dist unsigned)) congr_arg_kind) : @complete_lattice.is_Sup_finite_compact.{0} (has_dist.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_dist.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_107969 (h0 : topological_space (add_comm_monoid environment.implicit_infer_kind)) : preirreducible_space (add_comm_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_107970 (h0 : topological_space (ordered_comm_ring (has_Inf (has_Inf Type)))) : preirreducible_space (ordered_comm_ring (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_107971 (h0 : uniform_space (semigroup Type)) : separated_space (semigroup Type) := sorry --non-trivial
lemma new_lemma_107972 (h0 : not (topological_space (dlist linarith.ineq) -> false)) : @t0_space.{0} (dlist.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (dlist.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_107973 (h0 : ring (option num)) : is_principal_ideal_ring (option num) := sorry --non-trivial
lemma new_lemma_107974 (h0 : topological_space (finset congr_arg_kind)) : preirreducible_space (finset congr_arg_kind) := sorry --non-trivial
lemma new_lemma_107975 (h0 : functor.add_const (complete_lattice (has_dist num)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (has_dist.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_dist.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_107976 (h0 : functor.add_const (function.extfun (Type 1) list) Type) : palindrome (function.extfun_app (functor.add_const.run h0) (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_107977 (h0 : group (normed_group (has_top (has_top (has_top num))))) : is_cyclic (normed_group (has_top (has_top (has_top num)))) := sorry --non-trivial
lemma new_lemma_107978 (h0 : functor.add_const (group (has_neg name)) name) : @normalizer_condition.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_107979 (h0 : comm_semigroup (has_add real) -> comm_semigroup (has_add real) -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_107980 (h0 : topological_space (id (mul_zero_class linarith.ineq))) : locally_compact_space (id (mul_zero_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_107981 (h2 : nat -> Prop -> Prop) (h3 : nat) (h4 : Prop) : nat.repeat h2 h3 h4 := sorry --non-trivial
lemma new_lemma_107982 (h0 : topological_space (canonically_ordered_comm_semiring name)) : normal_space (canonically_ordered_comm_semiring name) := sorry --non-trivial
lemma new_lemma_107983 (h0 : cancel_comm_monoid_with_zero (non_assoc_semiring (option unsigned))) : unique_factorization_monoid (non_assoc_semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_107984 (h0 : topological_space (has_neg (option (option num)))) : discrete_topology (has_neg (option (option num))) := sorry --non-trivial
lemma new_lemma_107985 (h0 : functor.comp group has_neg Type) : @is_simple_group.{1} (has_neg.{1} Type) (@functor.comp.run.{1 1 1} group.{1} has_neg.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_107986 (h1 : not (add_group (distrib reducibility_hints) -> false)) : @is_add_cyclic.{0} (distrib.{0} reducibility_hints) (@classical.by_contradiction'.{1} (add_group.{0} (distrib.{0} reducibility_hints)) h1)  := sorry --non-trivial
lemma new_lemma_107987 (h0 : ring (filter unsigned)) : strong_rank_condition (filter unsigned) := sorry --non-trivial
lemma new_lemma_107988 (h0 : function.extfun Type (functor.add_const (topological_space znum))) : @t0_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} znum)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_107989 (h0 : topological_space (bin_tree empty)) : t1_space (bin_tree empty) := sorry --non-trivial
lemma new_lemma_107990 (h0 : functor.add_const (cancel_comm_monoid_with_zero (canonically_ordered_comm_semiring name)) Type) : @unique_factorization_monoid.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (canonically_ordered_comm_semiring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_107991 (h0 : filter (div_inv_monoid (random_gen to_additive.value_type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_107992 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_107993 (h0 : functor.add_const (topological_space (simple_graph linarith.comp)) Type) : @locally_compact_space.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (simple_graph.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_107994 (h0 : functor.add_const (group (option num)) num) : @is_cyclic.{0} (option.{0} num) (@functor.add_const.run.{0 0} (group.{0} (option.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_107995 (h0 : complete_lattice (has_nndist (finset pos))) : complete_lattice.is_Sup_finite_compact (has_nndist (finset pos)) := sorry --non-trivial
lemma new_lemma_107996 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_compactly_generated.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_107997 (h0 : has_mem.mem (random_gen num) has_emptyc.emptyc) : @strong_rank_condition.{0} (random_gen.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (random_gen.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_107998 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_107999 (h0 : group (add_group (has_union (has_norm (has_norm (semiring empty)))))) : is_cyclic (add_group (has_union (has_norm (has_norm (semiring empty))))) := sorry --non-trivial
lemma new_lemma_108000 (h0 : functor.add_const (topological_space (comm_group name)) linarith.comp) : @topological_space.separable_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_108001 (h0 : group (has_inv (random_gen linarith.ineq))) : group.fg (has_inv (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_108002 (h0 : function.extfun Type topological_space) : @normal_space.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_108003 (h0 : group (measurable_space (has_norm (has_norm to_additive.value_type)))) : is_cyclic (measurable_space (has_norm (has_norm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_108004 (h0 : functor.add_const (finset (ring pos)) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_108005 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_108006 (h0 : topological_space (has_Inf pos)) : preconnected_space (has_Inf pos) := sorry --non-trivial
lemma new_lemma_108007 (h0 : fin has_zero.zero) : @discrete_topology.{0} (add_comm_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_108008 (h0 : group (has_norm (has_nnnorm (random_gen (has_top to_additive.value_type))))) : group.fg (has_norm (has_nnnorm (random_gen (has_top to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_108009 (h0 : topological_space (has_to_string (ordered_ring name))) : preconnected_space (has_to_string (ordered_ring name)) := sorry --non-trivial
lemma new_lemma_108010 (h0 : semiring (has_add (has_neg (comm_group Type)))) : is_noetherian_ring (has_add (has_neg (comm_group Type))) := sorry --non-trivial
lemma new_lemma_108011 (h0 : functor.add_const (topological_space (boolean_algebra pos)) Type) : @t1_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_108012 (h0 : complete_lattice (has_Inf (sub_neg_monoid real))) : is_compactly_generated (has_Inf (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_108013 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @totally_separated_space.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_108014 (h0 : complete_lattice (has_zero (finset name))) : is_atomistic (has_zero (finset name)) := sorry --non-trivial
lemma new_lemma_108015 (h0 : finset (semigroup (measurable_space (has_neg (has_neg (add_cancel_monoid name)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_108016 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_108017 (h0 : topological_space (canonically_linear_ordered_monoid name)) : regular_space (canonically_linear_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_108018 (h0 : group (linear_ordered_add_comm_group (distrib_lattice to_additive.value_type))) : group.fg (linear_ordered_add_comm_group (distrib_lattice to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_108019 (h0 : topological_space (has_nndist (add_comm_monoid linarith.comp))) : preirreducible_space (has_nndist (add_comm_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_108020 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_108021 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_108022 (h0 : topological_space (has_to_string (finset environment.implicit_infer_kind))) : normal_space (has_to_string (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_108023 (h0 : topological_space (linear_ordered_semiring (semiring congr_arg_kind))) : totally_disconnected_space (linear_ordered_semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_108024 (h0 : topological_space (boolean_algebra.core congr_arg_kind)) : preconnected_space (boolean_algebra.core congr_arg_kind) := sorry --non-trivial
lemma new_lemma_108025 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @path_connected_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_108026 (h0 : topological_space (random_gen (has_ssubset to_additive.value_type))) : totally_disconnected_space (random_gen (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_108027 (h0 : ordered_add_comm_monoid (boolean_algebra.core (comm_group Type))) : archimedean (boolean_algebra.core (comm_group Type)) := sorry --non-trivial
lemma new_lemma_108028 (h0 : complete_lattice (semigroup (option name))) : is_atomistic (semigroup (option name)) := sorry --non-trivial
lemma new_lemma_108029 (h1 : add_group (has_add (has_nnnorm (has_nnnorm fun_info)))) : is_add_cyclic (has_add (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_108030 (h0 : group (left_cancel_monoid unsigned)) : group.fg (left_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_108031 (h0 : ring (boolean_algebra.core Type)) : is_domain (boolean_algebra.core Type) := sorry --non-trivial
lemma new_lemma_108032 (h0 : prod (ordered_cancel_add_comm_monoid congr_arg_kind) (ordered_cancel_add_comm_monoid congr_arg_kind)) : set.diagonal (ordered_cancel_add_comm_monoid congr_arg_kind) h0 := sorry --non-trivial
lemma new_lemma_108033 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @normalizer_condition.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_108034 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_108035 (h0 : add_group (add_comm_monoid (has_add pos))) : is_add_cyclic (add_comm_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_108036 (h0 : not (add_group (comm_ring linarith.ineq) -> false)) : @is_add_cyclic.{0} (comm_ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (add_group.{0} (comm_ring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_108037 (h0 : topological_space real) : t0_space real := sorry --non-trivial
lemma new_lemma_108038 (h0 : group (semigroup (has_neg_part (has_to_string (has_neg_part unsigned))))) : is_simple_group (semigroup (has_neg_part (has_to_string (has_neg_part unsigned)))) := sorry --non-trivial
lemma new_lemma_108039 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (add_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} h0 (add_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_108040 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_108041 (h2 : uniform_space (add_comm_semigroup linarith.ineq)) : complete_space (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_108042 (h0 : monoid (left_cancel_semigroup congr_arg_kind)) : monoid.fg (left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_108043 (h0 : topological_space (has_neg_part (has_add Type))) : discrete_topology (has_neg_part (has_add Type)) := sorry --non-trivial
lemma new_lemma_108044 (h0 : not (ring (add_right_cancel_monoid empty) -> false)) : @is_domain.{0} (add_right_cancel_monoid.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (add_right_cancel_monoid.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_108045 (h0 : function.extfun Type group) : @is_simple_group.{0} (comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_108046 (h0 : functor.add_const (ring (add_comm_monoid Type)) pos) : @is_principal_ideal_ring.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (add_comm_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_108047 (h0 : ring (semi_normed_ring enat)) : rank_condition (semi_normed_ring enat) := sorry --non-trivial
lemma new_lemma_108048 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_108049 (h0 : functor.add_const (group (add_comm_monoid Type)) Type) : @is_simple_group.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (add_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_108050 (h0 : filter (has_norm to_additive.value_type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_108051 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_108052 (h0 : monoid (has_add (finset environment.implicit_infer_kind))) : monoid.fg (has_add (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_108053 (h0 : set (has_le to_additive.value_type)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_108054 (h0 : not (add_group (semi_normed_ring (metric_space to_additive.value_type)) -> false)) : @is_add_cyclic.{0} (semi_normed_ring.{0} (metric_space.{0} to_additive.value_type)) (@classical.by_contradiction'.{1} (add_group.{0} (semi_normed_ring.{0} (metric_space.{0} to_additive.value_type))) h0)  := sorry --non-trivial
lemma new_lemma_108055 (h0 : ring (has_compl (random_gen (mul_one_class (has_nnnorm reducibility_hints))))) : rank_condition (has_compl (random_gen (mul_one_class (has_nnnorm reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_108056 (h0 : empty) : @complete_lattice.is_Sup_finite_compact.{0} (semi_normed_comm_ring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@empty.elim.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (semi_normed_comm_ring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_108057 (h0 : complete_lattice (id (has_inv fun_info))) : complete_lattice.is_Sup_finite_compact (id (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_108058 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} unsigned (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) unsigned)  := sorry --non-trivial
lemma new_lemma_108059 (h0 : functor.add_const (functor.add_const Prop ennreal) num) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_108060 (h0 : list (has_to_string (pseudo_metric_space (has_neg ennreal)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_108061 (h0 : complete_lattice (has_bot unsigned)) : is_compactly_generated (has_bot unsigned) := sorry --non-trivial
lemma new_lemma_108062 (h0 : uniform_space (has_top unsigned)) : separated_space (has_top unsigned) := sorry --non-trivial
lemma new_lemma_108063 (h0 : functor.add_const (prod (add_group empty) (add_group empty)) (semiring empty)) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_108064 (h0 : functor.add_const (ordered_add_comm_monoid (normed_linear_ordered_group unsigned)) unsigned) : @archimedean.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (normed_linear_ordered_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_108065 (h0 : uniform_space (with_bot (semiring (semiring linarith.comp)))) : complete_space (with_bot (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_108066 (h0 : functor.add_const (topological_space (has_zero unsigned)) environment.implicit_infer_kind) : @preconnected_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_108067 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} string_imp) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (complete_semilattice_Sup.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_108068 (h0 : ring (normed_field (has_nnnorm reducibility_hints))) : strong_rank_condition (normed_field (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_108069 (h1 : not (complete_lattice (semiring linarith.ineq) -> false)) : @is_compactly_generated.{0} (semiring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semiring.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_108070 (h0 : functor.add_const (filter (complete_distrib_lattice unsigned)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_108071 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @complete_space.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) uniform_space.{0}) (linear_ordered_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_108072 (h0 : topological_space (has_top (has_norm (has_norm fun_info)))) : path_connected_space (has_top (has_norm (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_108073 (h0 : functor.add_const (ring (ordered_cancel_add_comm_monoid ennreal)) ennreal) : @rank_condition.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (ordered_cancel_add_comm_monoid.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_108074 (h1 : group (semi_normed_comm_ring reducibility_hints)) : is_cyclic (semi_normed_comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_108075 (h0 : function.extfun Type topological_space) : @t0_space.{0} (free_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (free_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_108076 (h0 : filter (semigroup ennreal)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_108077 (h0 : ring (dlist (has_nnnorm (has_nnnorm fun_info)))) : rank_condition (dlist (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_108078 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_108079 (h0 : functor.add_const (ordered_comm_monoid (complete_distrib_lattice linarith.comp)) pos) : @has_exists_mul_of_le.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (complete_distrib_lattice.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_108080 (h0 : ring (plift congr_arg_kind)) : is_principal_ideal_ring (plift congr_arg_kind) := sorry --non-trivial
lemma new_lemma_108081 (h0 : topological_space (distrib_lattice (random_gen linarith.comp_source))) : irreducible_space (distrib_lattice (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_108082 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} h0 (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_108083 (h0 : topological_space (add_semigroup empty)) : t0_space (add_semigroup empty) := sorry --non-trivial
lemma new_lemma_108084 (h0 : functor.add_const (add_group (add_cancel_monoid Type)) (finset pos)) : @is_add_cyclic.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (add_cancel_monoid.{1} Type)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_108085 (h0 : uniform_space (ordered_comm_ring (sub_neg_monoid (ordered_comm_monoid real)))) : complete_space (ordered_comm_ring (sub_neg_monoid (ordered_comm_monoid real))) := sorry --non-trivial
lemma new_lemma_108086 (h0 : group (has_neg (has_neg_part (has_nndist (has_neg_part Type))))) : normalizer_condition (has_neg (has_neg_part (has_nndist (has_neg_part Type)))) := sorry --non-trivial
lemma new_lemma_108087 (h0 : add_monoid (has_one (has_top (semiring (semiring fun_info))))) : add_monoid.fg (has_one (has_top (semiring (semiring fun_info)))) := sorry --non-trivial
lemma new_lemma_108088 (h0 : functor.add_const (list (has_neg_part name)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_108089 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @normal_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_108090 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra name)) environment.implicit_infer_kind) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_108091 (h0 : functor.add_const (topological_space (bin_tree num)) num) : @preirreducible_space.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_108092 (h0 : ring (topological_space (comm_ring (comm_ring (random_gen reducibility_hints))))) : strong_rank_condition (topological_space (comm_ring (comm_ring (random_gen reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_108093 (h0 : finset (canonically_ordered_monoid (has_Inf (has_add pos)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_108094 (h0 : topological_space (canonically_linear_ordered_monoid (has_add Type))) : totally_separated_space (canonically_linear_ordered_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_108095 (h0 : complete_lattice (random_gen (random_gen num))) : complete_lattice.is_Sup_finite_compact (random_gen (random_gen num)) := sorry --non-trivial
lemma new_lemma_108096 (h2 : measurable_space (add_comm_semigroup enat)) (h3 : has_sup (add_comm_semigroup enat)) : has_measurable_sup₂ (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_108097 (h1 : topological_space (comm_ring (random_gen char))) : t0_space (comm_ring (random_gen char)) := sorry --non-trivial
lemma new_lemma_108098 (h0 : ring (uniform_space linarith.ineq)) : is_domain (uniform_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_108099 (h0 : set (uniform_space linarith.ineq)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_108100 (h0 : list (encodable (random_gen (random_gen to_additive.value_type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_108101 (h0 : monoid (finset (finset name))) : monoid.fg (finset (finset name)) := sorry --non-trivial
lemma new_lemma_108102 (h0 : functor.add_const (ordered_comm_monoid Type) linarith.comp) : @has_exists_mul_of_le.{1} Type (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} Type) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_108103 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @complete_space.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) uniform_space.{0}) (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_108104 (h1 : semiring fun_info) (h2 : ideal fun_info) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_108105 (h0 : has_mem.mem (has_norm empty) has_emptyc.emptyc) : @is_atomistic.{0} (has_norm.{0} empty) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_norm.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_108106 (h0 : topological_space (semigroup unsigned)) : locally_compact_space (semigroup unsigned) := sorry --non-trivial
lemma new_lemma_108107 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (ordered_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_108108 (h0 : ring (complete_distrib_lattice (ring environment.implicit_infer_kind))) : strong_rank_condition (complete_distrib_lattice (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_108109 (h0 : topological_space (measure_theory.measure_space (semiring (semiring (semiring congr_arg_kind))))) : path_connected_space (measure_theory.measure_space (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_108110 (h0 : topological_space (has_neg environment.implicit_infer_kind)) : t0_space (has_neg environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_108111 (h0 : topological_space (has_zero (comm_group Type))) : preirreducible_space (has_zero (comm_group Type)) := sorry --non-trivial
lemma new_lemma_108112 (h0 : has_mem.mem (normed_group congr_arg_kind) has_emptyc.emptyc) : @is_domain.{0} (normed_group.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type ring.{0} (normed_group.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_108113 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (canonically_ordered_comm_semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_108114 (h0 : fin has_zero.zero) : @is_cyclic.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) h0) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_108115 (h0 : not (ring nnreal -> false)) : @strong_rank_condition.{0} nnreal (@classical.by_contradiction'.{1} (ring.{0} nnreal) h0)  := sorry --non-trivial
lemma new_lemma_108116 (h0 : not (has_mem.mem (complete_semilattice_Sup linarith.comp_source) has_emptyc.emptyc -> false)) : @irreducible_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_108117 (h0 : functor.add_const (topological_space (has_Sup unsigned)) (option unsigned)) : @irreducible_space.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} unsigned)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_108118 (h0 : topological_space (canonically_ordered_comm_semiring (finset Type))) : path_connected_space (canonically_ordered_comm_semiring (finset Type)) := sorry --non-trivial
lemma new_lemma_108119 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @is_domain.{0} fun_info (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) fun_info)  := sorry --non-trivial
lemma new_lemma_108120 (h0 : functor.add_const (semiring (add_cancel_monoid pos)) Type) : @is_noetherian_ring.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (semiring.{0} (add_cancel_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_108121 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_108122 (h0 : set (semi_normed_ring linarith.ineq)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_108123 (h0 : topological_space (with_one (random_gen (random_gen num)))) : totally_disconnected_space (with_one (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_108124 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_108125 (h0 : functor.add_const (monoid (add_cancel_monoid Type)) linarith.comp) : @monoid.fg.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (add_cancel_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_108126 (h0 : functor.add_const (add_monoid (simple_graph pos)) pos) : @add_monoid.fg.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (simple_graph.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_108127 (h0 : function.extfun nat fin) : @t0_space.{0} (sub_neg_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_108128 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_108129 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (boolean_algebra.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (boolean_algebra.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_108130 (h0 : topological_space (has_dist (option num))) : preirreducible_space (has_dist (option num)) := sorry --non-trivial
lemma new_lemma_108131 (h0 : topological_space (finset ennreal)) : topological_space.separable_space (finset ennreal) := sorry --non-trivial
lemma new_lemma_108132 (h3 : topological_space (with_one num)) : t0_space (with_one num) := sorry --non-trivial
lemma new_lemma_108133 (h0 : ring (distrib (mul_one_class fun_info))) : strong_rank_condition (distrib (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_108134 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_108135 (h0 : topological_space (ordered_comm_ring (ordered_comm_monoid linarith.comp))) : t1_space (ordered_comm_ring (ordered_comm_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_108136 (h0 : ordered_add_comm_monoid (normed_comm_ring (linear_ordered_comm_group linarith.comp))) : archimedean (normed_comm_ring (linear_ordered_comm_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_108137 (h0 : not (topological_space (has_inv linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (has_inv.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_inv.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_108138 (h0 : topological_space (pseudo_metric_space (option (option unsigned)))) : totally_separated_space (pseudo_metric_space (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_108139 (h0 : uniform_space (canonically_ordered_comm_semiring (has_neg Type))) : separated_space (canonically_ordered_comm_semiring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_108140 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_108141 (h0 : add_group (linear_ordered_semiring (has_norm (has_top (has_norm linarith.comp))))) : is_add_cyclic (linear_ordered_semiring (has_norm (has_top (has_norm linarith.comp)))) := sorry --non-trivial
lemma new_lemma_108142 (h0 : topological_space (has_to_string (add_comm_monoid name))) : topological_space.separable_space (has_to_string (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_108143 (h0 : not (topological_space (has_top to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (has_top.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_108144 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_108145 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_108146 (h0 : ulower pnat) (h1 : pnat) : pnat.coprime (id (ulower.up h0)) h1 := sorry --non-trivial
lemma new_lemma_108147 (h0 : ring (normed_linear_ordered_group (semiring empty))) : rank_condition (normed_linear_ordered_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_108148 (h0 : list (cancel_monoid (boolean_algebra.core environment.implicit_infer_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_108149 (h0 : functor.add_const (group (has_add linarith.comp)) (has_zero (has_zero pos))) : @is_simple_group.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} linarith.comp)) (has_zero.{0} (has_zero.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_108150 (h0 : functor.add_const (uniform_space (boolean_algebra.core environment.implicit_infer_kind)) pos) : @separated_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_108151 (h0 : ring (uniform_space (mul_one_class enat))) : is_domain (uniform_space (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_108152 (h0 : functor.add_const (complete_lattice (has_nndist unsigned)) Type) : @is_compactly_generated.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_nndist.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_108153 (h1 : topological_space (with_bot num)) : t0_space (with_bot num) := sorry --non-trivial
lemma new_lemma_108154 (h0 : measurable_space (has_norm linarith.comp_source)) (h1 : function.extfun (has_norm linarith.comp_source) (fun (x : has_norm linarith.comp_source), Prop)) : measurable_set (function.extfun_app h1) := sorry --non-trivial
lemma new_lemma_108155 (h0 : complete_lattice (boolean_algebra.core linarith.comp)) : is_compactly_generated (boolean_algebra.core linarith.comp) := sorry --non-trivial
lemma new_lemma_108156 (h0 : functor.add_const (topological_space (add_group unsigned)) (semiring (semiring num))) : @normal_space.{0} (add_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} unsigned)) (semiring.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_108157 (h0 : add_group (mul_one_class (nondiscrete_normed_field fun_info))) : is_add_cyclic (mul_one_class (nondiscrete_normed_field fun_info)) := sorry --non-trivial
lemma new_lemma_108158 (h0 : topological_space (boolean_algebra (has_add (has_add (finset (finset pos)))))) : locally_compact_space (boolean_algebra (has_add (has_add (finset (finset pos))))) := sorry --non-trivial
lemma new_lemma_108159 (h0 : functor.add_const (topological_space (is_R_or_C unsigned)) empty) : @topological_space.separable_space.{0} (is_R_or_C.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (is_R_or_C.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_108160 (h0 : functor.add_const (topological_space (monoid unsigned)) num) : @totally_disconnected_space.{0} (monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_108161 (h0 : function.extfun nat fin) : @loc_path_connected_space.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_108162 (h0 : semiring (has_to_string empty)) : is_noetherian_ring (has_to_string empty) := sorry --non-trivial
lemma new_lemma_108163 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_108164 (h0 : functor.add_const (finset (add_group num)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_108165 (h0 : topological_space (has_union (has_norm empty))) : preirreducible_space (has_union (has_norm empty)) := sorry --non-trivial
lemma new_lemma_108166 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_108167 (h0 : add_group (has_norm (random_gen (comm_ring (random_gen (random_gen fun_info)))))) : is_add_cyclic (has_norm (random_gen (comm_ring (random_gen (random_gen fun_info))))) := sorry --non-trivial
lemma new_lemma_108168 (h0 : set.set_semiring char) (h1 : sym2 (set.set_semiring char)) : sym2.mem h0 h1 := sorry --non-trivial
lemma new_lemma_108169 (h0 : topological_space (has_one (has_top empty))) : locally_compact_space (has_one (has_top empty)) := sorry --non-trivial
lemma new_lemma_108170 (h0 : topological_space (ring (finset (has_add linarith.comp)))) : preirreducible_space (ring (finset (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_108171 (h0 : ordered_comm_monoid (finset (finset pos))) : has_exists_mul_of_le (finset (finset pos)) := sorry --non-trivial
lemma new_lemma_108172 (h0 : list (comm_group (has_add environment.implicit_infer_kind))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_108173 (h0 : ring (has_compl (has_repr (semi_normed_ring char)))) : rank_condition (has_compl (has_repr (semi_normed_ring char))) := sorry --non-trivial
lemma new_lemma_108174 (h0 : uniform_space (normed_field (metric_space (metric_space to_additive.value_type)))) : complete_space (normed_field (metric_space (metric_space to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_108175 (h0 : functor.add_const (add_group (semigroup environment.implicit_infer_kind)) (normed_comm_ring name)) : @is_add_cyclic.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_group.{0} (semigroup.{0} environment.implicit_infer_kind)) (normed_comm_ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_108176 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_108177 (h0 : topological_space (ring (option empty))) : t0_space (ring (option empty)) := sorry --non-trivial
lemma new_lemma_108178 (h0 : complete_lattice (is_R_or_C empty)) : is_atomistic (is_R_or_C empty) := sorry --non-trivial
lemma new_lemma_108179 (h0 : measurable_space (nondiscrete_normed_field std_gen)) (h1 : measure_theory.measure (nondiscrete_normed_field std_gen)) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_108180 (h0 : semiring string.iterator_imp) (h1 : string.iterator_imp) : even h1 := sorry --non-trivial
lemma new_lemma_108181 (h0 : functor.add_const (list (cancel_monoid name)) (boolean_algebra pos)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_108182 (h0 : functor.add_const (finset (finset linarith.comp)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_108183 (h1 : ring (distrib string_imp)) : is_domain (distrib string_imp) := sorry --non-trivial
lemma new_lemma_108184 (h0 : add_monoid (ordered_ring (semiring (semiring num)))) : add_monoid.fg (ordered_ring (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_108185 (h0 : pseudo_metric_space fun_info) (h1 : set fun_info) : metric.bounded h1 := sorry --non-trivial
lemma new_lemma_108186 (h0 : functor.comp topological_space pseudo_metric_space ennreal) : @loc_path_connected_space.{0} (pseudo_metric_space.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} pseudo_metric_space.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_108187 (h0 : functor.comp topological_space has_zero name) : @normal_space.{0} (has_zero.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} name h0)  := sorry --non-trivial
lemma new_lemma_108188 (h0 : ring (has_ssubset (random_gen (metric_space reducibility_hints)))) : is_domain (has_ssubset (random_gen (metric_space reducibility_hints))) := sorry --non-trivial
lemma new_lemma_108189 (h0 : ring (has_nndist num)) : strong_rank_condition (has_nndist num) := sorry --non-trivial
lemma new_lemma_108190 (h0 : functor.add_const (filter (comm_group Type)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_108191 (h0 : functor.add_const (topological_space (id unsigned)) congr_arg_kind) : @irreducible_space.{0} (@id.{2} Type unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (@id.{2} Type unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_108192 (h0 : functor.add_const (add_group (complete_distrib_lattice pos)) (add_comm_monoid Type)) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 1} (add_group.{0} (complete_distrib_lattice.{0} pos)) (add_comm_monoid.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_108193 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) linarith.comp) : @discrete_topology.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_108194 (h0 : topological_space (group_with_zero empty)) : normal_space (group_with_zero empty) := sorry --non-trivial
lemma new_lemma_108195 (h0 : monoid (complete_semilattice_Sup (has_inv (random_gen to_additive.value_type)))) : monoid.fg (complete_semilattice_Sup (has_inv (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_108196 (h0 : functor.add_const (complete_lattice (mul_zero_class unsigned)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (mul_zero_class.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_108197 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_108198 (h0 : topological_space (complete_semilattice_Sup (has_top (has_top (has_top congr_arg_kind))))) : locally_compact_space (complete_semilattice_Sup (has_top (has_top (has_top congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_108199 (h0 : complete_lattice (topological_space (has_nnnorm (has_nnnorm linarith.ineq)))) : is_compactly_generated (topological_space (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_108200 (h0 : complete_lattice (normed_group (has_norm (has_norm (has_norm linarith.comp_source))))) : is_atomistic (normed_group (has_norm (has_norm (has_norm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_108201 (h0 : topological_space (add_comm_semigroup linarith.ineq)) : totally_disconnected_space (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_108202 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_108203 (h0 : topological_space (has_add (has_nndist Type))) : discrete_topology (has_add (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_108204 (h0 : list (normed_group (comm_ring to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_108205 (h0 : group (id (has_inv to_additive.value_type))) : group.fg (id (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_108206 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_108207 (h0 : complete_lattice (option (option unsigned))) : is_atomistic (option (option unsigned)) := sorry --non-trivial
lemma new_lemma_108208 (h0 : functor.add_const (topological_space (mul_zero_class name)) pos) : @sequential_space.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_108209 (h0 : functor.add_const (add_group (boolean_algebra pos)) (add_comm_monoid pos)) : @is_add_cyclic.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (boolean_algebra.{0} pos)) (add_comm_monoid.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_108210 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @preirreducible_space.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_108211 (h0 : topological_space (has_Inf (ordered_ring linarith.comp))) : topological_space.separable_space (has_Inf (ordered_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_108212 (h0 : ordered_add_comm_monoid (add_cancel_monoid pos)) : archimedean (add_cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_108213 (h0 : finset (has_edist (option unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_108214 (h0 : functor.add_const (function.extfun Type list) pos) : palindrome (function.extfun_app (functor.add_const.run h0) (has_nndist unsigned)) := sorry --non-trivial
lemma new_lemma_108215 (h0 : functor.add_const (finset (has_zero name)) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_108216 (h0 : topological_space (semigroup (add_comm_monoid Type))) : t1_space (semigroup (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_108217 (h0 : preorder (metric_space linarith.comp_source)) (h1 : set (metric_space linarith.comp_source)) : set.ord_connected h1 := sorry --non-trivial
lemma new_lemma_108218 (h0 : functor.add_const (complete_lattice (has_nndist unsigned)) num) : @is_compactly_generated.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_108219 (h0 : topological_space (semi_normed_ring (has_nnnorm (metric_space (mul_one_class (mul_one_class fun_info)))))) (h1 : set (set (semi_normed_ring (has_nnnorm (metric_space (mul_one_class (mul_one_class fun_info))))))) : topological_space.is_topological_basis h1 := sorry --non-trivial
lemma new_lemma_108220 (h0 : topological_space (ordered_comm_ring pos)) : topological_space.separable_space (ordered_comm_ring pos) := sorry --non-trivial
lemma new_lemma_108221 (h0 : finset (is_R_or_C (semiring empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_108222 (h0 : functor.add_const (monoid (has_neg_part name)) pos) : @monoid.fg.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (has_neg_part.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_108223 (h0 : complete_lattice (lattice (semiring congr_arg_kind))) : is_atomistic (lattice (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_108224 (h0 : fin has_zero.zero) : @is_simple_group.{0} (sub_neg_monoid.{0} pos) (@matrix.vec_empty.{0} (group.{0} (sub_neg_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_108225 (h0 : not (ring (div_inv_monoid linarith.ineq) -> false)) : @strong_rank_condition.{0} (div_inv_monoid.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (div_inv_monoid.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_108226 (h0 : group (has_norm (has_nnnorm (has_nnnorm (random_gen to_additive.value_type))))) : group.fg (has_norm (has_nnnorm (has_nnnorm (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_108227 (h0 : list (left_cancel_monoid (option (option (ordered_ring empty))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_108228 (h0 : topological_space (linear_ordered_comm_group (option (option (option (option ennreal)))))) : preirreducible_space (linear_ordered_comm_group (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_108229 (h0 : group (has_neg (lex pos))) : group.fg (has_neg (lex pos)) := sorry --non-trivial
lemma new_lemma_108230 (h1 : topological_space (add_comm_semigroup linarith.ineq)) : topological_space.first_countable_topology (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_108231 (h0 : measurable_space (mul_one_class fun_info)) (h1 : set (mul_one_class fun_info)) : measurable_set h1 := sorry --non-trivial
lemma new_lemma_108232 (h0 : ordered_add_comm_monoid empty) : archimedean empty := sorry --non-trivial
lemma new_lemma_108233 (h0 : functor.add_const (ring (add_cancel_monoid Type)) (has_Inf (has_Inf Type))) : @rank_condition.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (add_cancel_monoid.{1} Type)) (has_Inf.{1} (has_Inf.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_108234 (h0 : not (topological_space (complete_semilattice_Sup num) -> false)) : @path_connected_space.{0} (complete_semilattice_Sup.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_108235 (h0 : topological_space (distrib (mul_one_class (mul_one_class string.iterator_imp)))) : t0_space (distrib (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_108236 (h0 : topological_space (plift (has_top empty))) : topological_space.separable_space (plift (has_top empty)) := sorry --non-trivial
lemma new_lemma_108237 (h0 : uniform_space (is_R_or_C empty)) : complete_space (is_R_or_C empty) := sorry --non-trivial
lemma new_lemma_108238 (h0 : topological_space (has_Inf (has_add (has_neg linarith.comp)))) : sequential_space (has_Inf (has_add (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_108239 (h0 : function.extfun Type topological_space) : @regular_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_108240 (h0 : functor.comp complete_lattice has_nndist ennreal) : @is_compactly_generated.{0} (has_nndist.{0} ennreal) (@functor.comp.run.{0 0 0} complete_lattice.{0} has_nndist.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_108241 (h0 : group (ordered_comm_ring (has_Inf (ring Type)))) : is_cyclic (ordered_comm_ring (has_Inf (ring Type))) := sorry --non-trivial
lemma new_lemma_108242 (h0 : topological_space (comm_monoid congr_arg_kind)) : loc_path_connected_space (comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_108243 (h0 : ordered_add_comm_monoid (has_add (has_bot name))) : archimedean (has_add (has_bot name)) := sorry --non-trivial
lemma new_lemma_108244 (h0 : functor.add_const (add_monoid (boolean_algebra pos)) (has_add Type)) : @add_monoid.fg.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (add_monoid.{0} (boolean_algebra.{0} pos)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_108245 (h0 : ordered_add_comm_monoid (mul_zero_class (boolean_algebra.core Type))) : archimedean (mul_zero_class (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_108246 (h0 : semiring (ordered_comm_ring (finset (ring Type)))) : is_noetherian_ring (ordered_comm_ring (finset (ring Type))) := sorry --non-trivial
lemma new_lemma_108247 (h0 : ring (dlist (has_nnnorm (has_nnnorm linarith.ineq)))) : strong_rank_condition (dlist (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_108248 (h0 : list environment.implicit_infer_kind) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_108249 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) name) : @preirreducible_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_108250 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @add_monoid.fg.{1} (mul_zero_class.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 add_monoid.{1}) (mul_zero_class.{1} Type))  := sorry --non-trivial
lemma new_lemma_108251 (h0 : add_group (has_bot (has_pos_part real))) : is_add_cyclic (has_bot (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_108252 (h0 : ring (sub_neg_monoid name)) : is_principal_ideal_ring (sub_neg_monoid name) := sorry --non-trivial
lemma new_lemma_108253 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_108254 (h0 : functor.add_const Prop (has_neg (option name))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_108255 (h0 : topological_space (add_right_cancel_monoid (has_add unsigned))) : sequential_space (add_right_cancel_monoid (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_108256 (h0 : functor.add_const (monoid (has_add linarith.comp)) Type) : @monoid.fg.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (monoid.{0} (has_add.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_108257 (h0 : filter (with_one (has_norm (has_union (has_one linarith.comp))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_108258 (h0 : topological_space (complete_semilattice_Sup (random_gen (random_gen fun_info)))) : t0_space (complete_semilattice_Sup (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_108259 (h0 : function.extfun Type ring) : @is_domain.{0} (add_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_108260 (h0 : functor.add_const (topological_space (linear_order empty)) (semiring empty)) : @locally_compact_space.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_order.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_108261 (h0 : functor.comp list has_neg Type) : palindrome (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_108262 (h0 : ordered_comm_monoid (has_Inf (has_pos_part (ring (has_pos_part linarith.comp))))) : has_exists_mul_of_le (has_Inf (has_pos_part (ring (has_pos_part linarith.comp)))) := sorry --non-trivial
lemma new_lemma_108263 (h0 : functor.add_const (group (generalized_boolean_algebra pos)) (has_neg pos)) : @group.fg.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (generalized_boolean_algebra.{0} pos)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_108264 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (filter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (filter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_108265 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (has_norm.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_norm.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_108266 (h0 : functor.add_const (topological_space (comm_group name)) environment.implicit_infer_kind) : @loc_path_connected_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_108267 (h0 : functor.add_const (list (has_edist empty)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_108268 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (semiring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_108269 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_add.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_add.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_108270 (h0 : topological_space (has_union (semiring (has_norm linarith.comp)))) : locally_compact_space (has_union (semiring (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_108271 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 add_group.{0}) (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_108272 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) Type) : @totally_separated_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (boolean_algebra.core.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_108273 (h0 : topological_space (has_ssubset (random_gen (has_ssubset (random_gen (random_gen linarith.comp_source)))))) : t0_space (has_ssubset (random_gen (has_ssubset (random_gen (random_gen linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_108274 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (with_one.{0} empty) (@id.{1} (topological_space.{0} (with_one.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} empty)))  := sorry --non-trivial
lemma new_lemma_108275 (h1 : uniform_space (semi_normed_comm_ring to_additive.value_type)) : complete_space (semi_normed_comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_108276 (h0 : ring (complete_distrib_lattice (has_add pos))) : strong_rank_condition (complete_distrib_lattice (has_add pos)) := sorry --non-trivial
lemma new_lemma_108277 (h0 : topological_space (is_R_or_C (option unsigned))) : irreducible_space (is_R_or_C (option unsigned)) := sorry --non-trivial
lemma new_lemma_108278 (h0 : functor.add_const (topological_space (semigroup name)) pos) : @locally_compact_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_108279 (h0 : topological_space (has_neg (finset (finset pos)))) : sequential_space (has_neg (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_108280 (h0 : ring (uniform_space (mul_one_class linarith.ineq))) : is_domain (uniform_space (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_108281 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_top.{0} char) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_top.{0} char))  := sorry --non-trivial
lemma new_lemma_108282 (h0 : functor.add_const (topological_space (ordered_comm_ring Type)) (has_neg Type)) : @sequential_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ordered_comm_ring.{1} Type)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_108283 (h0 : has_mem.mem (with_bot to_additive.value_type) has_emptyc.emptyc) : @is_atomistic.{0} (with_bot.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_bot.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_108284 (h0 : functor.add_const (topological_space (has_Inf pos)) real) : @t0_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_108285 (h0 : monoid (ring (boolean_algebra Type))) : monoid.fg (ring (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_108286 (h0 : topological_space (cancel_monoid (option (option unsigned)))) : normal_space (cancel_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_108287 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ordered_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_108288 (h0 : ordered_add_comm_monoid (has_nndist (has_add (has_nndist (has_nndist name))))) : archimedean (has_nndist (has_add (has_nndist (has_nndist name)))) := sorry --non-trivial
lemma new_lemma_108289 (h0 : ordered_comm_monoid (normed_comm_ring (comm_group unsigned))) : has_exists_mul_of_le (normed_comm_ring (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_108290 (h0 : functor.add_const (topological_space (has_nndist Type)) linarith.comp) : @totally_disconnected_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_108291 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (pseudo_metric_space.{0} (option.{0} congr_arg_kind)) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (pseudo_metric_space.{0} (option.{0} congr_arg_kind)))  := sorry --non-trivial
lemma new_lemma_108292 (h0 : functor.add_const (topological_space (has_nndist Type)) environment.implicit_infer_kind) : @normal_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_108293 (h0 : not (group (has_add fun_info) -> false)) : @is_cyclic.{0} (has_add.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (has_add.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_108294 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm num))) : @rank_condition.{0} (has_norm.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (has_norm.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_108295 (h0 : not (complete_lattice reducibility_hints -> false)) : @is_compactly_generated.{0} reducibility_hints (@classical.by_contradiction'.{1} (complete_lattice.{0} reducibility_hints) h0)  := sorry --non-trivial
lemma new_lemma_108296 (h0 : function.extfun Type group) : @group.fg.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_108297 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (random_gen.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_108298 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (complete_distrib_lattice.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} empty))  := sorry --non-trivial
lemma new_lemma_108299 (h0 : monoid (ordered_cancel_add_comm_monoid (semiring unsigned))) : monoid.fg (ordered_cancel_add_comm_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_108300 (h0 : ring (has_neg environment.implicit_infer_kind)) : is_principal_ideal_ring (has_neg environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_108301 (h0 : functor.add_const (topological_space (has_add linarith.comp)) (has_to_string pos)) : @topological_space.separable_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) (has_to_string.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_108302 (h0 : functor.add_const (topological_space (monoid ennreal)) num) : @preirreducible_space.{0} (monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_108303 (h0 : ordered_comm_monoid (simple_graph (ring (has_pos_part Type)))) : has_exists_mul_of_le (simple_graph (ring (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_108304 (h0 : function.extfun Type topological_space) : @t1_space.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_108305 (h1 : ring (metric_space (non_unital_non_assoc_semiring string_imp))) : is_domain (metric_space (non_unital_non_assoc_semiring string_imp)) := sorry --non-trivial
lemma new_lemma_108306 (h0 : function.extfun (Type 1) topological_space) : @preconnected_space.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_108307 (h0 : group (has_zero (ring (boolean_algebra Type)))) : normalizer_condition (has_zero (ring (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_108308 (h0 : topological_space (comm_ring (has_nnnorm (random_gen reducibility_hints)))) : t0_space (comm_ring (has_nnnorm (random_gen reducibility_hints))) := sorry --non-trivial
lemma new_lemma_108309 (h0 : functor.add_const (add_group (ordered_comm_group empty)) num) : @is_add_cyclic.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (ordered_comm_group.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_108310 (h1 : has_neg (has_lt linarith.comp_source)) (h2 : measurable_space (has_lt linarith.comp_source)) : has_measurable_neg (has_lt linarith.comp_source) := sorry --non-trivial
lemma new_lemma_108311 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @loc_path_connected_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_108312 (h0 : ring (has_append (mul_one_class fun_info))) : rank_condition (has_append (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_108313 (h0 : filter (has_pos_part linarith.comp)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_108314 (h0 : add_monoid (ordered_comm_ring (boolean_algebra.core pos))) : add_monoid.fg (ordered_comm_ring (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_108315 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_inter.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_inter.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_108316 (h0 : ordered_comm_monoid (semigroup (has_neg pos))) : has_exists_mul_of_le (semigroup (has_neg pos)) := sorry --non-trivial
lemma new_lemma_108317 (h0 : ring (has_to_string (finset ennreal))) : strong_rank_condition (has_to_string (finset ennreal)) := sorry --non-trivial
lemma new_lemma_108318 (h0 : complete_lattice (has_norm (has_inv to_additive.value_type))) : is_atomistic (has_norm (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_108319 (h2 : is_empty (add_cancel_comm_monoid linarith.comp_source)) (h3 : add_cancel_comm_monoid linarith.comp_source) : @is_compactly_generated.{0} (has_append.{0} char) (@is_empty.elim'.{1 1} (add_cancel_comm_monoid.{0} linarith.comp_source) (complete_lattice.{0} (has_append.{0} char)) h2 h3)  := sorry --non-trivial
lemma new_lemma_108320 (h0 : topological_space (has_bot (option unsigned))) : irreducible_space (has_bot (option unsigned)) := sorry --non-trivial
lemma new_lemma_108321 (h0 : functor.add_const (function.extfun (Type 1) group) pos) : @is_cyclic.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) pos h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_108322 (h0 : function.extfun (Type 1) add_group) : @is_add_cyclic.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} h0 (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_108323 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) (has_Inf name)) : @totally_disconnected_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} pos)) (has_Inf.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_108324 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_108325 (h0 : topological_space (simple_graph Type)) : totally_disconnected_space (simple_graph Type) := sorry --non-trivial
lemma new_lemma_108326 (h0 : ring (has_lt (mul_one_class linarith.ineq))) : rank_condition (has_lt (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_108327 (h1 : add_group (dlist (has_nnnorm (random_gen (random_gen char))))) : is_add_cyclic (dlist (has_nnnorm (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_108328 (h0 : function.extfun Type group) : @group.fg.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_108329 (h0 : functor.add_const (topological_space (preorder congr_arg_kind)) num) : @preirreducible_space.{0} (preorder.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_108330 (h0 : not (ring (semi_normed_ring (mul_one_class char)) -> false)) : @strong_rank_condition.{0} (semi_normed_ring.{0} (mul_one_class.{0} char)) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_ring.{0} (mul_one_class.{0} char))) h0)  := sorry --non-trivial
lemma new_lemma_108331 (h0 : functor.add_const (function.extfun Type complete_lattice) Type) : @is_compactly_generated.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type complete_lattice.{0}) Type h0) (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_108332 (h0 : ring (measurable_space.dynkin_system (semiring unsigned))) : rank_condition (measurable_space.dynkin_system (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_108333 (h0 : complete_lattice (distrib_lattice fun_info)) : is_atomistic (distrib_lattice fun_info) := sorry --non-trivial
lemma new_lemma_108334 (h0 : functor.add_const (ordered_comm_monoid (has_add pos)) (finset (finset pos))) : @has_exists_mul_of_le.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_add.{0} pos)) (finset.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_108335 (h0 : topological_space (generalized_boolean_algebra (has_neg pos))) : irreducible_space (generalized_boolean_algebra (has_neg pos)) := sorry --non-trivial
lemma new_lemma_108336 (h0 : not (ring (dlist linarith.comp_source) -> false)) : @rank_condition.{0} (dlist.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (dlist.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_108337 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_add_cyclic.{1} Type (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 add_group.{1}) Type)  := sorry --non-trivial
lemma new_lemma_108338 (h0 : function.extfun Type (functor.add_const (filter (add_comm_monoid pos)))) : filter.ne_bot (functor.add_const.run (function.extfun_app h0 pos)) := sorry --non-trivial
lemma new_lemma_108339 (h0 : functor.add_const (group linarith.comp) (has_neg pos)) : @is_cyclic.{0} linarith.comp (@functor.add_const.run.{0 0} (group.{0} linarith.comp) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_108340 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring linarith.comp)) name) : @preirreducible_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_108341 (h1 : list (ring (denumerable char))) (h2 : ne h1 list.nil) : @rank_condition.{0} (denumerable.{0} char) (@list.last.{0} (ring.{0} (denumerable.{0} char)) h1 h2)  := sorry --non-trivial
lemma new_lemma_108342 (h1 : topological_space (normed_group congr_arg_kind)) : discrete_topology (normed_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_108343 (h0 : uniform_space (add_comm_monoid (has_add name))) : separated_space (add_comm_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_108344 (h0 : function.extfun Type (functor.add_const (filter pos))) : countable_Inter_filter (functor.add_const.run (function.extfun_app h0 (option unsigned))) := sorry --non-trivial
lemma new_lemma_108345 (h0 : has_mem.mem unsigned has_emptyc.emptyc) : @is_atomistic.{0} unsigned (@finset.pi.empty.{1 0} Type complete_lattice.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_108346 (h0 : topological_space (pseudo_metric_space ennreal)) : discrete_topology (pseudo_metric_space ennreal) := sorry --non-trivial
lemma new_lemma_108347 (h0 : not (complete_lattice (complete_semilattice_Sup linarith.ineq) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (complete_semilattice_Sup.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_108348 (h1 : function.extfun Type topological_space) : @path_connected_space.{0} (has_norm.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (has_norm.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_108349 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_108350 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) (has_neg (has_neg linarith.comp))) : @preirreducible_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) (has_neg.{0} (has_neg.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_108351 (h0 : fin has_zero.zero) : @monoid.fg.{0} (canonically_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type monoid.{0}) h0) (canonically_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_108352 (h0 : uniform_space (linear_ordered_cancel_comm_monoid congr_arg_kind)) : separated_space (linear_ordered_cancel_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_108353 (h0 : ring (finset (has_to_string pos))) : is_principal_ideal_ring (finset (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_108354 (h2 : ring (div_inv_monoid (random_gen string_imp))) : is_domain (div_inv_monoid (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_108355 (h0 : monoid (has_star unsigned)) : monoid.fg (has_star unsigned) := sorry --non-trivial
lemma new_lemma_108356 (h2 : has_nnnorm to_additive.value_type -> has_nnnorm to_additive.value_type -> Prop) : is_equiv (has_nnnorm to_additive.value_type) h2 := sorry --non-trivial
lemma new_lemma_108357 (h0 : not (topological_space (random_gen num) -> false)) : @discrete_topology.{0} (random_gen.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_108358 (h1 : filter (has_inv string_imp)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_108359 (h0 : complete_lattice (semi_normed_ring string.iterator_imp)) : complete_lattice.is_Sup_finite_compact (semi_normed_ring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_108360 (h0 : topological_space (add_comm_monoid (has_neg real))) : preirreducible_space (add_comm_monoid (has_neg real)) := sorry --non-trivial
lemma new_lemma_108361 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (measurable_space.dynkin_system.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (measurable_space.dynkin_system.{0} empty))  := sorry --non-trivial
lemma new_lemma_108362 (h0 : add_monoid (has_Inf (has_Inf (has_Inf real)))) : add_monoid.fg (has_Inf (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_108363 (h0 : functor.add_const (finset (has_to_string pos)) (boolean_algebra Type)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_108364 (h0 : topological_space (metric_space unsigned)) : discrete_topology (metric_space unsigned) := sorry --non-trivial
lemma new_lemma_108365 (h0 : finset (has_norm (semiring congr_arg_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_108366 (h0 : topological_space (distrib_lattice (has_top linarith.ineq))) : t0_space (distrib_lattice (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_108367 (h0 : group (cancel_monoid (has_add pos))) : group.fg (cancel_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_108368 (h0 : complete_lattice (boolean_algebra.core (finset pos))) : complete_lattice.is_Sup_finite_compact (boolean_algebra.core (finset pos)) := sorry --non-trivial
lemma new_lemma_108369 (h1 : not (monoid linarith.comp -> false)) : @monoid.fg.{0} linarith.comp (@classical.by_contradiction'.{1} (monoid.{0} linarith.comp) h1)  := sorry --non-trivial
lemma new_lemma_108370 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) Type) : @preirreducible_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_108371 (h0 : functor.comp topological_space has_neg_part environment.implicit_infer_kind) : @sequential_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_108372 (h0 : complete_lattice (fintype string_imp)) : complete_lattice.is_Sup_finite_compact (fintype string_imp) := sorry --non-trivial
lemma new_lemma_108373 (h0 : functor.add_const (topological_space (mul_zero_class ennreal)) name) : @topological_space.separable_space.{0} (mul_zero_class.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_108374 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (semigroup name)) := sorry --non-trivial
lemma new_lemma_108375 (h1 : set (ereal -> mul_one_class linarith.ineq)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_108376 (h0 : functor.add_const (ordered_add_comm_monoid (non_assoc_semiring empty)) congr_arg_kind) : @archimedean.{0} (non_assoc_semiring.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (non_assoc_semiring.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_108377 (h0 : complete_lattice (has_zero (ring (ring Type)))) : complete_lattice.is_Sup_finite_compact (has_zero (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_108378 (h0 : functor.add_const (complete_lattice (has_nndist environment.implicit_infer_kind)) (has_add (add_comm_monoid Type))) : @is_compactly_generated.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_nndist.{0} environment.implicit_infer_kind)) (has_add.{1} (add_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_108379 (h1 : ring (topological_space (random_gen (random_gen (random_gen to_additive.value_type))))) : is_domain (topological_space (random_gen (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_108380 (h0 : group (canonically_ordered_monoid (has_Inf (has_Inf pos)))) : is_simple_group (canonically_ordered_monoid (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_108381 (h0 : ordered_comm_monoid (canonically_ordered_monoid (has_add linarith.comp))) : has_exists_mul_of_le (canonically_ordered_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_108382 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) pos) : @sequential_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_108383 (h0 : complete_lattice (has_le (mul_one_class string.iterator_imp))) : is_compactly_generated (has_le (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_108384 (h0 : function.extfun Type (functor.add_const (function.extfun Type group))) : @group.fg.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) unsigned (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type group.{0})) h0 unsigned)) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_108385 (h0 : functor.add_const (topological_space (has_nndist Type)) Type) : @totally_separated_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_nndist.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_108386 (h0 : topological_space (has_zero (ring pos))) : t0_space (has_zero (ring pos)) := sorry --non-trivial
lemma new_lemma_108387 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_108388 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (left_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (left_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_108389 (h0 : functor.comp semiring semigroup ennreal) : @is_noetherian_ring.{0} (semigroup.{0} ennreal) (@functor.comp.run.{0 0 0} semiring.{0} semigroup.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_108390 (h0 : ordered_add_comm_monoid (ordered_comm_ring (has_bot name))) : archimedean (ordered_comm_ring (has_bot name)) := sorry --non-trivial
lemma new_lemma_108391 (h0 : ring (normed_field std_gen)) : is_domain (normed_field std_gen) := sorry --non-trivial
lemma new_lemma_108392 (h0 : add_group (has_inner Type Type)) : is_add_cyclic (has_inner Type Type) := sorry --non-trivial
lemma new_lemma_108393 (h0 : ring (canonically_ordered_monoid name)) : is_principal_ideal_ring (canonically_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_108394 (h0 : functor.add_const (function.extfun Type monoid) Type) : @monoid.fg.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type monoid.{0}) Type h0) (complete_distrib_lattice.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_108395 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_108396 (h0 : functor.add_const (topological_space (ordered_comm_ring Type)) pos) : @preirreducible_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_108397 (h0 : functor.add_const (uniform_space (add_cancel_monoid pos)) (ring Type)) : @complete_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (add_cancel_monoid.{0} pos)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_108398 (h1 : topological_space (distrib string_imp)) : t0_space (distrib string_imp) := sorry --non-trivial
lemma new_lemma_108399 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_108400 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_108401 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (ordered_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_108402 (h0 : ring (normed_group num)) : is_domain (normed_group num) := sorry --non-trivial
lemma new_lemma_108403 (h0 : add_group (mul_one_class (nondiscrete_normed_field (normed_field ereal)))) : is_add_cyclic (mul_one_class (nondiscrete_normed_field (normed_field ereal))) := sorry --non-trivial
lemma new_lemma_108404 (h0 : not (group (has_compl fun_info) -> false)) : @is_cyclic.{0} (has_compl.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (has_compl.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_108405 (h0 : group (normed_comm_ring (has_neg (has_add linarith.comp)))) : is_cyclic (normed_comm_ring (has_neg (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_108406 (h0 : ring (has_to_string (has_neg Type))) : is_domain (has_to_string (has_neg Type)) := sorry --non-trivial
lemma new_lemma_108407 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_dist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_dist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_108408 (h0 : list (has_top (denumerable fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_108409 (h0 : set (set unsigned)) : is_countably_spanning h0 := sorry --non-trivial
lemma new_lemma_108410 (h0 : group (has_one congr_arg_kind)) : is_cyclic (has_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_108411 (h0 : topological_space (mul_zero_class num)) : topological_space.separable_space (mul_zero_class num) := sorry --non-trivial
lemma new_lemma_108412 (h0 : functor.add_const (functor.add_const Prop ennreal) ennreal) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_108413 (h0 : topological_space (add_cancel_monoid (has_neg pos))) : t1_space (add_cancel_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_108414 (h0 : functor.add_const (add_group (add_cancel_monoid pos)) Type) : @is_add_cyclic.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (add_group.{0} (add_cancel_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_108415 (h0 : not (has_mem.mem (complete_semilattice_Sup linarith.comp_source) has_emptyc.emptyc -> false)) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_108416 (h0 : set (has_nnnorm (mul_one_class char))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_108417 (h0 : functor.add_const (group (finset pos)) environment.implicit_infer_kind) : @is_simple_group.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_108418 (h0 : group (has_neg (ring pos))) : normalizer_condition (has_neg (ring pos)) := sorry --non-trivial
lemma new_lemma_108419 (h0 : prod (semigroup (option (option name))) (semigroup (option (option name)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_108420 (h0 : ordered_comm_monoid (has_bot (has_neg pos))) : has_exists_mul_of_le (has_bot (has_neg pos)) := sorry --non-trivial
lemma new_lemma_108421 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @normalizer_condition.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_108422 (h1 : measurable_space (add_comm_semigroup linarith.ineq)) (h2 : measure_theory.measure (add_comm_semigroup linarith.ineq)) : measure_theory.is_finite_measure h2 := sorry --non-trivial
lemma new_lemma_108423 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_108424 (h0 : ring (has_append (random_gen to_additive.value_type))) : rank_condition (has_append (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_108425 (h0 : functor.add_const (function.extfun Type topological_space) name) : @discrete_topology.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_108426 (h1 : ring (topological_space linarith.ineq)) : is_domain (topological_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_108427 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_108428 (h0 : add_group (random_gen (has_ssubset fun_info))) : is_add_cyclic (random_gen (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_108429 (h0 : fin has_zero.zero) : id (matrix.vec_empty (id (matrix.vec_empty h0))) := sorry --non-trivial
lemma new_lemma_108430 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_108431 (h0 : topological_space (with_bot (has_top (random_gen (has_top (random_gen (has_top fun_info))))))) : totally_separated_space (with_bot (has_top (random_gen (has_top (random_gen (has_top fun_info)))))) := sorry --non-trivial
lemma new_lemma_108432 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_108433 (h0 : ordered_add_comm_monoid (normed_lattice_add_comm_group name)) : archimedean (normed_lattice_add_comm_group name) := sorry --non-trivial
lemma new_lemma_108434 (h1 : add_group (has_nnnorm (denumerable char))) : is_add_cyclic (has_nnnorm (denumerable char)) := sorry --non-trivial
lemma new_lemma_108435 (h0 : function.extfun Type (functor.add_const (cancel_comm_monoid_with_zero pos))) : @unique_factorization_monoid.{0} pos (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} pos) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (cancel_comm_monoid_with_zero.{0} pos)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_108436 (h0 : functor.add_const (complete_lattice (pseudo_metric_space num)) ennreal) : @is_atomistic.{0} (pseudo_metric_space.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (pseudo_metric_space.{0} num)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_108437 (h0 : functor.add_const (group (finset environment.implicit_infer_kind)) pos) : @group.fg.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_108438 (h0 : topological_space (canonically_ordered_comm_semiring (boolean_algebra pos))) : t0_space (canonically_ordered_comm_semiring (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_108439 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_inter.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} empty))  := sorry --non-trivial
lemma new_lemma_108440 (h0 : ring (has_to_string (has_nndist Type))) : strong_rank_condition (has_to_string (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_108441 (h0 : add_group (with_bot (has_norm (has_norm to_additive.value_type)))) : is_add_cyclic (with_bot (has_norm (has_norm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_108442 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_108443 (h0 : list (option num)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_108444 (h0 : cancel_comm_monoid_with_zero (id (has_top empty))) : unique_factorization_monoid (id (has_top empty)) := sorry --non-trivial
lemma new_lemma_108445 (h0 : not (filter (id congr_arg_kind) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_108446 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_108447 (h0 : functor.add_const (add_monoid (ordered_ring empty)) empty) : @add_monoid.fg.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (ordered_ring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_108448 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (comm_semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_108449 (h2 : topological_space environment.projection_info) : t0_space environment.projection_info := sorry --non-trivial
lemma new_lemma_108450 (h1 : ring string.iterator_imp) : rank_condition string.iterator_imp := sorry --non-trivial
lemma new_lemma_108451 (h3 : set (ereal -> add_comm_semigroup enat)) : set.separates_points h3 := sorry --non-trivial
lemma new_lemma_108452 (h0 : group (has_nnnorm (has_nnnorm fun_info))) : group.fg (has_nnnorm (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_108453 (h0 : function.extfun Type ring) : @is_domain.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_108454 (h2 : uniform_space (add_comm_semigroup environment.projection_info)) : complete_space (add_comm_semigroup environment.projection_info) := sorry --non-trivial
lemma new_lemma_108455 (h0 : not (add_monoid (with_bot unsigned) -> false)) : @add_monoid.fg.{0} (with_bot.{0} unsigned) (@classical.by_contradiction'.{1} (add_monoid.{0} (with_bot.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_108456 (h1 : function.extfun Type add_group) : @is_add_cyclic.{0} (measurable_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type add_group.{0} h1 (measurable_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_108457 (h0 : filter (has_zero (comm_group pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_108458 (h0 : filter (has_top unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_108459 (h0 : functor.comp ring boolean_algebra unsigned) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} unsigned) (@functor.comp.run.{0 0 0} ring.{0} boolean_algebra.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_108460 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_separated_space.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_108461 (h0 : function.extfun nat fin) : @totally_disconnected_space.{0} fun_info (@matrix.vec_empty.{0} (topological_space.{0} fun_info) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_108462 (h0 : topological_space (finset (finset pos))) : topological_space.separable_space (finset (finset pos)) := sorry --non-trivial
lemma new_lemma_108463 (h0 : topological_space (mul_zero_class (has_neg_part ennreal))) : irreducible_space (mul_zero_class (has_neg_part ennreal)) := sorry --non-trivial
lemma new_lemma_108464 (h0 : functor.add_const (topological_space (ring linarith.comp)) Type) : @preirreducible_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_108465 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_108466 (h0 : list (semigroup (has_nndist Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_108467 (h0 : filter (normed_comm_ring congr_arg_kind)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_108468 (h0 : ordered_add_comm_monoid (canonically_linear_ordered_monoid (option pos))) : archimedean (canonically_linear_ordered_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_108469 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (complete_distrib_lattice.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_108470 (h0 : ring (has_zero (finset Type))) : is_domain (has_zero (finset Type)) := sorry --non-trivial
lemma new_lemma_108471 (h0 : topological_space (finset (ring (has_neg Type)))) : t1_space (finset (ring (has_neg Type))) := sorry --non-trivial
lemma new_lemma_108472 (h0 : ring (has_pos_part (has_pos_part real))) : is_principal_ideal_ring (has_pos_part (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_108473 (h0 : topological_space (semigroup (option unsigned))) : preconnected_space (semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_108474 (h0 : function.extfun nat fin) : @is_cyclic.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (group.{1} (has_pos_part.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_108475 (h0 : ring (has_edist (semiring (semiring empty)))) : is_principal_ideal_ring (has_edist (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_108476 (h0 : functor.add_const (topological_space (has_dist empty)) num) : @normal_space.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_108477 (h0 : topological_space (canonically_ordered_monoid (has_bot real))) : sequential_space (canonically_ordered_monoid (has_bot real)) := sorry --non-trivial
lemma new_lemma_108478 (h0 : has_mem.mem (with_one num) has_emptyc.emptyc) : @is_cyclic.{0} (with_one.{0} num) (@finset.pi.empty.{1 0} Type group.{0} (with_one.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_108479 (h1 : ring (has_norm (has_top (has_top (has_top (has_emptyc linarith.comp_source)))))) : strong_rank_condition (has_norm (has_top (has_top (has_top (has_emptyc linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_108480 (h0 : functor.add_const (uniform_space (finset unsigned)) (option unsigned)) : @complete_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (finset.{0} unsigned)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_108481 (h1 : set (linarith.ineq -> add_cancel_monoid char)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_108482 (h0 : complete_lattice (has_top (with_bot string_imp))) : is_atomistic (has_top (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_108483 (h0 : finset (linear_ordered_comm_ring empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_108484 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_108485 (h0 : fin has_zero.zero) : @add_monoid.fg.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) add_monoid.{1}) h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_108486 (h0 : functor.add_const (topological_space (left_cancel_semigroup congr_arg_kind)) unsigned) : @preirreducible_space.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_108487 (h0 : functor.add_const (ring (linear_ordered_cancel_comm_monoid num)) congr_arg_kind) : @is_domain.{0} (linear_ordered_cancel_comm_monoid.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (linear_ordered_cancel_comm_monoid.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_108488 (h0 : functor.add_const (list (has_neg name)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_108489 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (monoid empty)) := sorry --non-trivial
lemma new_lemma_108490 (h0 : functor.comp ring pseudo_metric_space (finset (has_nndist (has_add (has_add ennreal))))) : @strong_rank_condition.{0} (pseudo_metric_space.{0} (finset.{0} (has_nndist.{0} (has_add.{0} (has_add.{0} ennreal))))) (@functor.comp.run.{0 0 0} ring.{0} pseudo_metric_space.{0} (finset.{0} (has_nndist.{0} (has_add.{0} (has_add.{0} ennreal)))) h0)  := sorry --non-trivial
lemma new_lemma_108491 (h0 : functor.add_const (group (linear_ordered_comm_monoid_with_zero unsigned)) congr_arg_kind) : @is_cyclic.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_108492 (h1 : group (random_gen string_imp)) : normalizer_condition (random_gen string_imp) := sorry --non-trivial
lemma new_lemma_108493 (h0 : topological_space (non_unital_non_assoc_semiring string_imp)) : t0_space (non_unital_non_assoc_semiring string_imp) := sorry --non-trivial
lemma new_lemma_108494 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_108495 (h0 : add_group (option congr_arg_kind)) : is_add_cyclic (option congr_arg_kind) := sorry --non-trivial
lemma new_lemma_108496 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_108497 (h0 : topological_space (complete_distrib_lattice (boolean_algebra (has_add pos)))) : preconnected_space (complete_distrib_lattice (boolean_algebra (has_add pos))) := sorry --non-trivial
lemma new_lemma_108498 (h0 : list (dlist (random_gen (random_gen (random_gen linarith.comp_source))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_108499 (h0 : add_monoid (has_neg num)) : add_monoid.fg (has_neg num) := sorry --non-trivial
lemma new_lemma_108500 (h0 : topological_space (has_dist (has_nnnorm linarith.ineq))) : totally_disconnected_space (has_dist (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_108501 (h0 : functor.add_const (complete_lattice (complete_distrib_lattice pos)) Type) : @is_compactly_generated.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (complete_distrib_lattice.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_108502 (h0 : topological_space (has_top (has_top linarith.comp))) : locally_compact_space (has_top (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_108503 (h0 : ring (ordered_comm_ring fun_info)) : is_domain (ordered_comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_108504 (h1 : complete_lattice (add_comm_semigroup string.iterator_imp)) : complete_lattice.is_Sup_finite_compact (add_comm_semigroup string.iterator_imp) := sorry --non-trivial
lemma new_lemma_108505 (h0 : uniform_space (mul_zero_class Type)) : complete_space (mul_zero_class Type) := sorry --non-trivial
lemma new_lemma_108506 (h0 : ring (complete_distrib_lattice environment.implicit_infer_kind)) : is_principal_ideal_ring (complete_distrib_lattice environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_108507 (h0 : has_mem.mem (measurable_space num) has_emptyc.emptyc) : @is_cyclic.{0} (measurable_space.{0} num) (@finset.pi.empty.{1 0} Type group.{0} (measurable_space.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_108508 (h0 : topological_space (normed_field (has_ssubset linarith.ineq))) : path_connected_space (normed_field (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_108509 (h0 : group (denumerable string_imp)) : group.fg (denumerable string_imp) := sorry --non-trivial
lemma new_lemma_108510 (h0 : semiring (simple_graph pos)) : is_noetherian_ring (simple_graph pos) := sorry --non-trivial
lemma new_lemma_108511 (h0 : filter (finset (has_to_string name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_108512 (h0 : ring (has_norm (random_gen (random_gen (random_gen linarith.ineq))))) : rank_condition (has_norm (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_108513 (h0 : function.extfun Type topological_space) : @normal_space.{0} real.angle (@function.extfun_app.{2 1} Type topological_space.{0} h0 real.angle)  := sorry --non-trivial
lemma new_lemma_108514 (h0 : monoid (linear_ordered_field (option (option (option (option (option (option unsigned)))))))) : monoid.fg (linear_ordered_field (option (option (option (option (option (option unsigned))))))) := sorry --non-trivial
lemma new_lemma_108515 (h0 : topological_space znum) : regular_space znum := sorry --non-trivial
lemma new_lemma_108516 (h0 : not (topological_space (distrib char) -> false)) : @path_connected_space.{0} (distrib.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_108517 (h0 : topological_space (has_zero (finset (finset (ring environment.implicit_infer_kind))))) : t1_space (has_zero (finset (finset (ring environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_108518 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_108519 (h1 : complete_lattice (semi_normed_ring (has_compl linarith.ineq))) : is_compactly_generated (semi_normed_ring (has_compl linarith.ineq)) := sorry --non-trivial
lemma new_lemma_108520 (h0 : group (add_cancel_monoid (has_to_string name))) : group.fg (add_cancel_monoid (has_to_string name)) := sorry --non-trivial
lemma new_lemma_108521 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (add_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_group.{0} num))  := sorry --non-trivial
lemma new_lemma_108522 (h0 : semiring std_gen) (h4 : ideal std_gen) : ideal.is_prime h4 := sorry --non-trivial
lemma new_lemma_108523 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (add_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_108524 (h0 : complete_lattice (has_emptyc (has_norm linarith.comp_source))) : is_atomistic (has_emptyc (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_108525 (h0 : not (topological_space (measurable_space to_additive.value_type) -> false)) : @discrete_topology.{0} (measurable_space.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_108526 (h0 : functor.add_const (monoid (add_group empty)) congr_arg_kind) : @monoid.fg.{0} (add_group.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (add_group.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_108527 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_108528 (h0 : functor.add_const (topological_space (complete_distrib_lattice unsigned)) num) : @totally_separated_space.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_108529 (h0 : ring (simple_graph fun_info)) : is_domain (simple_graph fun_info) := sorry --non-trivial
lemma new_lemma_108530 (h0 : functor.add_const (topological_space (mul_zero_class name)) Type) : @t1_space.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (mul_zero_class.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_108531 (h0 : functor.add_const (ordered_comm_monoid (has_to_string linarith.comp)) linarith.comp) : @has_exists_mul_of_le.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_to_string.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_108532 (h0 : topological_space (left_cancel_monoid (option empty))) : locally_compact_space (left_cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_108533 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (ring name)) := sorry --non-trivial
lemma new_lemma_108534 (h0 : set (fun_info -> enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_108535 (h3 : topological_space (topological_space char)) : totally_disconnected_space (topological_space char) := sorry --non-trivial
lemma new_lemma_108536 (h0 : ordered_comm_monoid (semigroup (has_Inf pos))) : has_exists_mul_of_le (semigroup (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_108537 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_sub.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_sub.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_108538 (h0 : list (semigroup unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_108539 (h0 h1 : list fun_info) : list.is_infix h0 h1 := sorry --non-trivial
lemma new_lemma_108540 (h0 : functor.add_const (topological_space (complete_distrib_lattice name)) linarith.comp) : @totally_disconnected_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_108541 (h0 : functor.add_const (filter (has_neg_part Type)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_108542 (h0 : topological_space (boolean_algebra (has_Inf (has_add real)))) : preconnected_space (boolean_algebra (has_Inf (has_add real))) := sorry --non-trivial
lemma new_lemma_108543 (h0 : topological_space (partial_order (semiring empty))) : totally_disconnected_space (partial_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_108544 (h0 : has_mem.mem (linear_ordered_semiring to_additive.value_type) has_emptyc.emptyc) : @totally_disconnected_space.{0} (linear_ordered_semiring.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_108545 (h0 : topological_space (has_zero (option name))) : path_connected_space (has_zero (option name)) := sorry --non-trivial
lemma new_lemma_108546 (h0 : topological_space (encodable char)) : totally_disconnected_space (encodable char) := sorry --non-trivial
lemma new_lemma_108547 (h0 : functor.add_const (uniform_space (has_add Type)) (has_to_string Type)) : @separated_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (has_add.{1} Type)) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_108548 (h0 : complete_lattice (normed_group (random_gen (random_gen (has_ssubset to_additive.value_type))))) : is_compactly_generated (normed_group (random_gen (random_gen (has_ssubset to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_108549 (h0 : functor.add_const Prop (has_neg environment.implicit_infer_kind)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_108550 (h0 : topological_space (has_div reducibility_hints)) (h1 : preorder (has_div reducibility_hints)) : order_closed_topology (has_div reducibility_hints) := sorry --non-trivial
lemma new_lemma_108551 (h0 : functor.add_const (semiring (ring name)) linarith.comp) : @is_noetherian_ring.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_108552 (h0 : not (add_group (complete_semilattice_Sup linarith.comp_source) -> false)) : @add_group.fg.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (add_group.{0} (complete_semilattice_Sup.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_108553 (h0 : monoid (with_bot (random_gen (has_inv (random_gen fun_info))))) : monoid.fg (with_bot (random_gen (has_inv (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_108554 (h0 : functor.add_const (add_group (bin_tree congr_arg_kind)) unsigned) : @is_add_cyclic.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (add_group.{0} (bin_tree.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_108555 (h0 : function.extfun Type group) : @is_simple_group.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_108556 (h0 : functor.add_const (list (ordered_ring unsigned)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_108557 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_108558 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_108559 (h0 : topological_space (canonically_ordered_comm_semiring (option ennreal))) : sequential_space (canonically_ordered_comm_semiring (option ennreal)) := sorry --non-trivial
lemma new_lemma_108560 (h0 : topological_space (finset (option unsigned))) : preconnected_space (finset (option unsigned)) := sorry --non-trivial
lemma new_lemma_108561 (h1 : uniform_space (has_ssubset (has_nnnorm (has_inv to_additive.value_type)))) : complete_space (has_ssubset (has_nnnorm (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_108562 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_108563 (h0 : filter to_additive.value_type) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_108564 (h0 : functor.add_const (add_group (generalized_boolean_algebra name)) Type) : @is_add_cyclic.{0} (generalized_boolean_algebra.{0} name) (@functor.add_const.run.{0 1} (add_group.{0} (generalized_boolean_algebra.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_108565 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (measure_theory.measure_space.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (measure_theory.measure_space.{0} num))  := sorry --non-trivial
lemma new_lemma_108566 (h0 : topological_space (has_add (has_add pos))) : t0_space (has_add (has_add pos)) := sorry --non-trivial
lemma new_lemma_108567 (h0 : uniform_space (boolean_algebra (finset (finset linarith.comp)))) : separated_space (boolean_algebra (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_108568 (h0 : filter (denumerable (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_108569 (h0 : complete_lattice (generalized_boolean_algebra (ring Type))) : is_compactly_generated (generalized_boolean_algebra (ring Type)) := sorry --non-trivial
lemma new_lemma_108570 (h0 : list (pseudo_metric_space pos)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_108571 (h0 : not (uniform_space to_additive.value_type -> false)) : @complete_space.{0} to_additive.value_type (@classical.by_contradiction'.{1} (uniform_space.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_108572 (h2 : ring (dlist linarith.ineq)) : strong_rank_condition (dlist linarith.ineq) := sorry --non-trivial
lemma new_lemma_108573 (h0 : functor.comp ring has_neg_part pos) : @rank_condition.{0} (has_neg_part.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} has_neg_part.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_108574 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_108575 (h0 : ring (linear_ordered_comm_group_with_zero string_imp)) : strong_rank_condition (linear_ordered_comm_group_with_zero string_imp) := sorry --non-trivial
lemma new_lemma_108576 (h0 : topological_space (has_compl enat)) (h1 : preorder (has_compl enat)) : order_closed_topology (has_compl enat) := sorry --non-trivial
lemma new_lemma_108577 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_108578 (h0 : function.extfun Type ring) : @is_domain.{0} (left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_108579 (h0 : functor.add_const (topological_space (complete_distrib_lattice linarith.comp)) linarith.comp) : @loc_path_connected_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_108580 (h3 : ring (has_lt to_additive.value_type)) : strong_rank_condition (has_lt to_additive.value_type) := sorry --non-trivial
lemma new_lemma_108581 (h0 : topological_space (add_left_cancel_monoid char)) : path_connected_space (add_left_cancel_monoid char) := sorry --non-trivial
lemma new_lemma_108582 (h0 : topological_space congr_arg_kind) : t1_space congr_arg_kind := sorry --non-trivial
lemma new_lemma_108583 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_108584 (h0 : functor.add_const (complete_lattice (has_add ennreal)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (has_add.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_add.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_108585 (h0 : functor.add_const (finset (has_Sup unsigned)) congr_arg_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_108586 (h0 : topological_space (boolean_algebra (has_Inf (ring (has_pos_part pos))))) : regular_space (boolean_algebra (has_Inf (ring (has_pos_part pos)))) := sorry --non-trivial
lemma new_lemma_108587 (h0 : topological_space (linear_ordered_field unsigned)) : t0_space (linear_ordered_field unsigned) := sorry --non-trivial
lemma new_lemma_108588 (h0 : topological_space (cancel_monoid (boolean_algebra Type))) : discrete_topology (cancel_monoid (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_108589 (h0 : function.extfun Type group) : @is_cyclic.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_108590 (h0 : group (measurable_space (monoid_with_zero congr_arg_kind))) : normalizer_condition (measurable_space (monoid_with_zero congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_108591 (h0 : not (topological_space (has_star num) -> false)) : @t1_space.{0} (has_star.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_star.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_108592 (h0 : topological_space (ordered_comm_ring (has_pos_part (has_add Type)))) : irreducible_space (ordered_comm_ring (has_pos_part (has_add Type))) := sorry --non-trivial
lemma new_lemma_108593 (h0 : filter (has_nndist (has_neg_part (has_neg_part (has_neg_part unsigned))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_108594 (h0 : topological_space (has_dist ennreal)) : t1_space (has_dist ennreal) := sorry --non-trivial
lemma new_lemma_108595 (h0 : complete_lattice (comm_ring reducibility_hints)) : complete_lattice.is_Sup_finite_compact (comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_108596 (h0 : prod (has_Sup (option unsigned)) (has_Sup (option unsigned))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_108597 (h0 : functor.comp group cancel_monoid pos) : @normalizer_condition.{0} (cancel_monoid.{0} pos) (@functor.comp.run.{0 0 0} group.{0} cancel_monoid.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_108598 (h0 : group (semi_normed_comm_ring (linear_ordered_add_comm_group linarith.comp_source))) : group.fg (semi_normed_comm_ring (linear_ordered_add_comm_group linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_108599 (h0 : functor.add_const (cancel_comm_monoid_with_zero (finset Type)) linarith.comp) : @unique_factorization_monoid.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (finset.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_108600 (h0 : functor.add_const (topological_space (finset Type)) linarith.comp) : @locally_compact_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_108601 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_108602 (h0 : topological_space (normed_group unsigned)) : discrete_topology (normed_group unsigned) := sorry --non-trivial
lemma new_lemma_108603 (h0 : complete_lattice (has_zero (ring (finset (ring Type))))) : is_compactly_generated (has_zero (ring (finset (ring Type)))) := sorry --non-trivial
lemma new_lemma_108604 (h0 : list (normed_group (has_inv (has_inv (has_inv linarith.comp_source))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_108605 (h0 : ring (has_neg (ring linarith.comp))) : rank_condition (has_neg (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_108606 (h0 : topological_space (has_norm (has_top (has_top (random_gen congr_arg_kind))))) : discrete_topology (has_norm (has_top (has_top (random_gen congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_108607 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (simple_graph.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (simple_graph.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_108608 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) h0) (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_108609 (h0 : monoid (metric_space (semiring (semiring congr_arg_kind)))) : monoid.fg (metric_space (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_108610 (h0 : functor.add_const (filter (div_inv_monoid fun_info)) to_additive.value_type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_108611 (h0 : function.extfun Type group) : @is_cyclic.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_108612 (h0 : ring (dlist (has_ssubset (with_one string_imp)))) : strong_rank_condition (dlist (has_ssubset (with_one string_imp))) := sorry --non-trivial
lemma new_lemma_108613 (h0 : functor.add_const (topological_space (is_R_or_C unsigned)) empty) : @discrete_topology.{0} (is_R_or_C.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (is_R_or_C.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_108614 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (mul_zero_class.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (mul_zero_class.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_108615 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (group.{0} (ordered_comm_ring.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_108616 (h0 : measurable_space (linear_ordered_comm_monoid_with_zero empty)) (h1 : function.extfun Type has_mul) : @has_measurable_mul₂.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) h0 (@function.extfun_app.{2 1} Type has_mul.{0} h1 (linear_ordered_comm_monoid_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_108617 (h0 : fin has_zero.zero) : @sequential_space.{0} (generalized_boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_108618 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (add_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_108619 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (canonically_ordered_add_monoid.{0} (option.{0} (option.{0} empty))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_add_monoid.{0} (option.{0} (option.{0} empty))))  := sorry --non-trivial
lemma new_lemma_108620 (h0 : uniform_space (normed_group (random_gen (random_gen (random_gen (comm_ring fun_info)))))) : complete_space (normed_group (random_gen (random_gen (random_gen (comm_ring fun_info))))) := sorry --non-trivial
lemma new_lemma_108621 (h0 : functor.add_const (uniform_space (has_pos_part name)) pos) : @complete_space.{0} (has_pos_part.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_pos_part.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_108622 (h0 : not (topological_space (option congr_arg_kind) -> false)) : @topological_space.separable_space.{0} (option.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (option.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_108623 (h0 : uniform_space (complete_semilattice_Sup (semiring (semiring (semiring num))))) : complete_space (complete_semilattice_Sup (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_108624 (h0 : functor.add_const (ordered_comm_monoid (has_nndist linarith.comp)) pos) : @has_exists_mul_of_le.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_nndist.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_108625 (h0 : semiring (measure_theory.measure_space (semiring environment.implicit_infer_kind))) : is_noetherian_ring (measure_theory.measure_space (semiring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_108626 (h0 : topological_space (ordered_comm_ring (has_neg Type))) : totally_separated_space (ordered_comm_ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_108627 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_108628 (h0 : topological_space (has_add (mul_one_class Type))) : irreducible_space (has_add (mul_one_class Type)) := sorry --non-trivial
lemma new_lemma_108629 (h0 : not (ring (measurable_space empty) -> false)) : @rank_condition.{0} (measurable_space.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (measurable_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_108630 (h0 : topological_space (cancel_monoid empty)) : topological_space.separable_space (cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_108631 (h0 : group (normed_comm_ring (has_add environment.implicit_infer_kind))) : group.fg (normed_comm_ring (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_108632 (h1 : topological_space (with_one (has_norm congr_arg_kind))) : path_connected_space (with_one (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_108633 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @totally_separated_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_108634 (h0 : linarith.comp_source -> linarith.comp_source -> Prop) (h1 : function.extfun linarith.comp_source (fun (x : linarith.comp_source), Prop)) : set.unbounded h0 (function.extfun_app h1) := sorry --non-trivial
lemma new_lemma_108635 (h0 : topological_space (has_to_string (has_to_string Type))) : totally_separated_space (has_to_string (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_108636 (h0 : topological_space (has_bot (has_neg (has_neg (has_neg (has_neg name)))))) : discrete_topology (has_bot (has_neg (has_neg (has_neg (has_neg name))))) := sorry --non-trivial
lemma new_lemma_108637 (h0 : has_add char) (h1 : has_le char) (h2 : char) : add_le_cancellable h2 := sorry --non-trivial
lemma new_lemma_108638 (h0 : functor.add_const (uniform_space (omega_complete_partial_order empty)) empty) : @separated_space.{0} (omega_complete_partial_order.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (omega_complete_partial_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_108639 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_108640 (h0 : function.extfun (finset Type) (has_mem.mem linarith.comp_source)) : @irreducible_space.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type topological_space.{0} linarith.comp_source (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp_source) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_108641 (h0 : monoid (complete_semilattice_Sup (has_inv (has_inv (has_inv (has_inv to_additive.value_type)))))) : monoid.fg (complete_semilattice_Sup (has_inv (has_inv (has_inv (has_inv to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_108642 (h0 : functor.add_const (topological_space linarith.comp) Type) : @t0_space.{0} linarith.comp (@functor.add_const.run.{0 1} (topological_space.{0} linarith.comp) Type h0)  := sorry --non-trivial
lemma new_lemma_108643 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_108644 (h0 : nat) (h1 : vector Prop (nat.succ h0)) : vector.head h1 := sorry --non-trivial
lemma new_lemma_108645 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_108646 (h0 : topological_space (has_nndist (has_neg_part environment.implicit_infer_kind))) : normal_space (has_nndist (has_neg_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_108647 (h0 : set (add_comm_semigroup enat -> string.iterator_imp)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_108648 (h0 : complete_lattice (comm_group (has_add (has_add Type)))) : is_compactly_generated (comm_group (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_108649 (h0 : group (has_bot congr_arg_kind)) : normalizer_condition (has_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_108650 (h2 : cancel_comm_monoid_with_zero (distrib (comm_ring linarith.ineq))) : unique_factorization_monoid (distrib (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_108651 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_108652 (h0 : add_group (boolean_algebra (mul_one_class (ring Type)))) : is_add_cyclic (boolean_algebra (mul_one_class (ring Type))) := sorry --non-trivial
lemma new_lemma_108653 (h0 : topological_space (measurable_space (has_top (random_gen (has_top fun_info))))) : path_connected_space (measurable_space (has_top (random_gen (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_108654 (h0 : topological_space (has_neg (add_cancel_monoid name))) : irreducible_space (has_neg (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_108655 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) linarith.comp) : @archimedean.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) linarith.comp h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_108656 (h0 : topological_space (free_add_monoid congr_arg_kind)) : topological_space.separable_space (free_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_108657 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (linear_ordered_field.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_field.{0} num))  := sorry --non-trivial
lemma new_lemma_108658 (h0 : not (filter (has_sub num) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_108659 (h0 : function.extfun Type (functor.comp topological_space has_add)) : @t1_space.{0} (has_add.{0} (cancel_monoid.{0} pos)) (@functor.comp.run.{0 0 0} topological_space.{0} has_add.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_add.{0}) h0 (cancel_monoid.{0} pos)))  := sorry --non-trivial
lemma new_lemma_108660 (h0 : group (normed_lattice_add_comm_group (has_add (has_bot (has_Inf real))))) : group.fg (normed_lattice_add_comm_group (has_add (has_bot (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_108661 (h0 : functor.add_const (finset (has_nndist linarith.comp)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_108662 (h0 : topological_space (canonically_ordered_comm_semiring congr_arg_kind)) : discrete_topology (canonically_ordered_comm_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_108663 (h0 : functor.add_const (topological_space (has_neg Type)) Type) : @t0_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_neg.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_108664 (h0 : monoid (denumerable (random_gen linarith.ineq))) : monoid.fg (denumerable (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_108665 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_108666 (h0 : not (functor.add_const Prop (has_star unsigned) -> false)) : functor.add_const.run (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_108667 (h0 : add_comm_semigroup std_gen -> Prop) (h1 : filter (add_comm_semigroup std_gen)) : filter.eventually h0 h1 := sorry --non-trivial
lemma new_lemma_108668 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf real))) : loc_path_connected_space (normed_lattice_add_comm_group (has_Inf real)) := sorry --non-trivial
lemma new_lemma_108669 (h0 : functor.add_const (ring (mul_zero_class num)) num) : @is_principal_ideal_ring.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (mul_zero_class.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_108670 (h0 : functor.add_const (complete_lattice (pseudo_metric_space ennreal)) pos) : @is_compactly_generated.{0} (pseudo_metric_space.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (pseudo_metric_space.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_108671 (h0 : group (distrib_lattice (random_gen string_imp))) : is_cyclic (distrib_lattice (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_108672 (h0 : ordered_add_comm_monoid (semigroup (finset (ring linarith.comp)))) : archimedean (semigroup (finset (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_108673 (h0 : topological_space (has_to_string (finset (finset (has_Inf (has_Inf (normed_comm_ring pos))))))) : preconnected_space (has_to_string (finset (finset (has_Inf (has_Inf (normed_comm_ring pos)))))) := sorry --non-trivial
lemma new_lemma_108674 (h0 : topological_space (boolean_algebra (comm_semigroup pos))) : path_connected_space (boolean_algebra (comm_semigroup pos)) := sorry --non-trivial
lemma new_lemma_108675 (h0 : topological_space (canonically_ordered_comm_semiring congr_arg_kind)) : topological_space.separable_space (canonically_ordered_comm_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_108676 (h0 : functor.add_const (function.extfun Type topological_space) (has_add (has_add pos))) : @normal_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_add.{0} (has_add.{0} pos)) h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_108677 (h0 : add_group (comm_monoid congr_arg_kind)) : is_add_cyclic (comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_108678 (h1 : topological_space (id num)) : totally_separated_space (id num) := sorry --non-trivial
lemma new_lemma_108679 (h0 : uniform_space (has_add (has_pos_part linarith.comp))) : separated_space (has_add (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_108680 (h0 : ring (has_one (semiring congr_arg_kind))) : strong_rank_condition (has_one (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_108681 (h0 : functor.add_const (topological_space (has_nndist pos)) (finset Type)) : @discrete_topology.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} pos)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_108682 (h0 : functor.add_const (topological_space (finset unsigned)) Type) : @normal_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_108683 (h0 : ordered_comm_monoid (has_Inf (has_neg (ring Type)))) : has_exists_mul_of_le (has_Inf (has_neg (ring Type))) := sorry --non-trivial
lemma new_lemma_108684 (h0 : topological_space (simple_graph (has_Inf linarith.comp))) : irreducible_space (simple_graph (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_108685 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_108686 (h0 : functor.add_const (topological_space (complete_distrib_lattice unsigned)) unsigned) : @totally_separated_space.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_108687 (h0 : group (add_cancel_comm_monoid empty)) : normalizer_condition (add_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_108688 (h0 : add_group (has_bot pos)) : is_add_cyclic (has_bot pos) := sorry --non-trivial
lemma new_lemma_108689 (h0 : uniform_space (has_star (semiring (semiring (semiring num))))) : separated_space (has_star (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_108690 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (complete_distrib_lattice.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} empty))  := sorry --non-trivial
lemma new_lemma_108691 (h0 : has_mem.mem filter has_emptyc.emptyc) : filter.ne_bot (function.extfun_app (finset.pi.empty (function.extfun (Type 1)) filter h0) Type) := sorry --non-trivial
lemma new_lemma_108692 (h0 : functor.add_const (group (normed_comm_ring name)) pos) : @is_simple_group.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_108693 (h0 : not (topological_space (add_group unsigned) -> false)) : @path_connected_space.{0} (add_group.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (add_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_108694 (h0 : group (has_Inf (has_pos_part Type))) : group.fg (has_Inf (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_108695 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) name) : @is_compactly_generated.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) name h0) (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_108696 (h0 : list (linear_ordered_cancel_comm_monoid (option (option unsigned)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_108697 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_108698 (h0 : ring (with_one empty)) : strong_rank_condition (with_one empty) := sorry --non-trivial
lemma new_lemma_108699 (h0 : function.extfun Type group) : @is_cyclic.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_108700 (h0 : functor.add_const (topological_space (plift num)) num) : @topological_space.separable_space.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} num)) num h0)  := sorry --non-trivial
lemma new_lemma_108701 (h0 : prod (has_add environment.implicit_infer_kind) (has_add environment.implicit_infer_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_108702 (h0 : topological_space (dlist (random_gen linarith.ineq))) : path_connected_space (dlist (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_108703 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring unsigned)) linarith.comp) : @normal_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_108704 (h0 : topological_space (has_nndist (mul_zero_class Type))) : normal_space (has_nndist (mul_zero_class Type)) := sorry --non-trivial
lemma new_lemma_108705 (h0 : add_group (distrib_lattice (has_nnnorm (has_nnnorm linarith.ineq)))) : is_add_cyclic (distrib_lattice (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_108706 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (sub_neg_monoid.{0} pos) (@matrix.vec_empty.{0} (semiring.{0} (sub_neg_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_108707 (h0 : monoid (canonically_ordered_monoid (has_add linarith.comp))) : monoid.fg (canonically_ordered_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_108708 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @topological_space.separable_space.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_108709 (h0 : topological_space (semiring (option (option (option unsigned))))) : normal_space (semiring (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_108710 (h0 : cancel_comm_monoid_with_zero (has_pos_part (has_add Type))) : unique_factorization_monoid (has_pos_part (has_add Type)) := sorry --non-trivial
lemma new_lemma_108711 (h0 : has_mem.mem (semiring to_additive.value_type) has_emptyc.emptyc) : @irreducible_space.{0} (semiring.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_108712 (h0 : group (encodable (random_gen to_additive.value_type))) : is_cyclic (encodable (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_108713 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (pseudo_metric_space unsigned)) := sorry --non-trivial
lemma new_lemma_108714 (h0 : group (distrib_lattice (has_nnnorm fun_info))) : group.fg (distrib_lattice (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_108715 (h0 : functor.add_const (finset (semigroup Type)) (has_neg Type)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_108716 (h0 : functor.add_const (topological_space (complete_distrib_lattice unsigned)) empty) : @totally_disconnected_space.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_108717 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_nnnorm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_nnnorm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_108718 (h0 : filter (add_semigroup (option empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_108719 (h0 : function.extfun linarith.comp_source (fun (x : linarith.comp_source), monoid congr_arg_kind)) (h1 : unit) (h2 : linarith.comp_source) : @monoid.fg.{0} congr_arg_kind (@matrix.row.{0 0} linarith.comp_source (monoid.{0} congr_arg_kind) (@function.extfun_app.{1 1} linarith.comp_source (λ (x : linarith.comp_source), monoid.{0} congr_arg_kind) h0) h1 h2)  := sorry --non-trivial
lemma new_lemma_108720 (h0 : uniform_space (semi_normed_ring to_additive.value_type)) : complete_space (semi_normed_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_108721 (h0 : functor.add_const (group (normed_comm_ring linarith.comp)) Type) : @is_simple_group.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (normed_comm_ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_108722 (h0 : topological_space (ordered_comm_monoid (has_pos_part Type))) : preirreducible_space (ordered_comm_monoid (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_108723 (h0 : functor.add_const (complete_lattice (add_cancel_monoid empty)) empty) : @is_atomistic.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_108724 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_Inf.{0} (finset.{0} linarith.comp)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_Inf.{0} (finset.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_108725 (h0 : list (has_inv (has_nnnorm (has_nnnorm linarith.comp_source)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_108726 (h0 : topological_space (topological_space (has_nnnorm (has_nnnorm char)))) : path_connected_space (topological_space (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_108727 (h0 : preorder std_gen) (h1 : ring (pred_order std_gen)) : strong_rank_condition (pred_order std_gen) := sorry --non-trivial
lemma new_lemma_108728 (h0 : functor.add_const (topological_space (ring pos)) Type) : @totally_disconnected_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_108729 (h0 : topological_space (has_nndist (has_to_string pos))) : totally_separated_space (has_nndist (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_108730 (h0 : filter (metric_space (semiring (has_norm linarith.comp)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_108731 (h0 : ring (metric_space unsigned)) : rank_condition (metric_space unsigned) := sorry --non-trivial
lemma new_lemma_108732 (h0 : functor.add_const (complete_lattice (semiring unsigned)) congr_arg_kind) : @is_compactly_generated.{0} (semiring.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semiring.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_108733 (h0 : semiring (canonically_ordered_comm_semiring (has_Inf Type))) : is_noetherian_ring (canonically_ordered_comm_semiring (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_108734 (h0 : nat) (h1 h2 : list (array h0 Prop)) : list.head (array.rev_list (list.head (list.append h1 (id h2)))) := sorry --non-trivial
lemma new_lemma_108735 (h0 : uniform_space (with_zero (has_append linarith.ineq))) : complete_space (with_zero (has_append linarith.ineq)) := sorry --non-trivial
lemma new_lemma_108736 (h0 : ring (linear_ordered_comm_group (option unsigned))) : rank_condition (linear_ordered_comm_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_108737 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_108738 (h0 : topological_space (has_add (option ennreal))) : t1_space (has_add (option ennreal)) := sorry --non-trivial
lemma new_lemma_108739 (h0 : topological_space (comm_semigroup (comm_semigroup (has_bot real)))) : preirreducible_space (comm_semigroup (comm_semigroup (has_bot real))) := sorry --non-trivial
lemma new_lemma_108740 (h0 : functor.add_const (group (boolean_algebra.core Type)) name) : @is_cyclic.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (boolean_algebra.core.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_108741 (h0 : functor.add_const (group (mul_zero_class Type)) (has_add Type)) : @group.fg.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (mul_zero_class.{1} Type)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_108742 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_108743 (h0 : ring (canonically_ordered_comm_semiring (finset (has_nndist pos)))) : is_principal_ideal_ring (canonically_ordered_comm_semiring (finset (has_nndist pos))) := sorry --non-trivial
lemma new_lemma_108744 (h0 : add_group (canonically_ordered_comm_semiring (has_zero ennreal))) : is_add_cyclic (canonically_ordered_comm_semiring (has_zero ennreal)) := sorry --non-trivial
lemma new_lemma_108745 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_108746 (h0 : fin has_zero.zero) : @t0_space.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (comm_semigroup.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_108747 (h0 : not (ring (encodable fun_info) -> false)) : @rank_condition.{0} (encodable.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (encodable.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_108748 (h3 : preorder string.iterator_imp) (h4 : set string.iterator_imp) : set.is_pwo h4 := sorry --non-trivial
lemma new_lemma_108749 (h1 : topological_space ereal) (h2 : set ereal) : is_path_connected h2 := sorry --non-trivial
lemma new_lemma_108750 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_108751 (h0 : filter (topological_space (finset unsigned))) : @preirreducible_space.{0} (finset.{0} unsigned) (@filter.Limsup.{0} (topological_space.{0} (finset.{0} unsigned)) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} (finset.{0} unsigned)) (@topological_space.complete_lattice.{0} (finset.{0} unsigned))) h0)  := sorry --non-trivial
lemma new_lemma_108752 (h2 : semiring ereal) (h3 : ideal ereal) : ideal.is_prime h3 := sorry --non-trivial
lemma new_lemma_108753 (h0 : topological_space (non_unital_non_assoc_semiring (mul_one_class reducibility_hints))) : t0_space (non_unital_non_assoc_semiring (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_108754 (h0 : functor.add_const (monoid (comm_group pos)) pos) : @monoid.fg.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (comm_group.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_108755 (h3 : topological_space linarith.ineq) : topological_space.first_countable_topology linarith.ineq := sorry --non-trivial
lemma new_lemma_108756 (h0 : monoid (with_one (semiring (semiring (semiring num))))) : monoid.fg (with_one (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_108757 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (add_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_108758 (h0 : uniform_space (has_Sup unsigned)) : separated_space (has_Sup unsigned) := sorry --non-trivial
lemma new_lemma_108759 (h1 : ring (right_cancel_semigroup (random_gen (comm_ring fun_info)))) : strong_rank_condition (right_cancel_semigroup (random_gen (comm_ring fun_info))) := sorry --non-trivial
lemma new_lemma_108760 (h0 : group (has_nndist (has_nndist (finset (finset pos))))) : group.fg (has_nndist (has_nndist (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_108761 (h0 : add_monoid (monoid (option ennreal))) : add_monoid.fg (monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_108762 (h0 : topological_space (has_div (semi_normed_comm_ring ereal))) : path_connected_space (has_div (semi_normed_comm_ring ereal)) := sorry --non-trivial
lemma new_lemma_108763 (h0 : fin has_zero.zero) : @path_connected_space.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (comm_semigroup.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))))  := sorry --non-trivial
lemma new_lemma_108764 (h2 : preorder (add_comm_semigroup enat)) (h3 : set (add_comm_semigroup enat)) : set.is_pwo h3 := sorry --non-trivial
lemma new_lemma_108765 (h0 : add_group (has_div std_gen)) : is_add_cyclic (has_div std_gen) := sorry --non-trivial
lemma new_lemma_108766 (h0 : topological_space (linear_ordered_add_comm_group (random_gen (random_gen linarith.comp_source)))) : t0_space (linear_ordered_add_comm_group (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_108767 (h0 : group (ordered_comm_ring (has_nndist (ordered_ring name)))) : is_cyclic (ordered_comm_ring (has_nndist (ordered_ring name))) := sorry --non-trivial
lemma new_lemma_108768 (h0 : complete_lattice (measurable_space (random_gen to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (measurable_space (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_108769 (h1 : complete_lattice (comm_ring (has_nnnorm (has_nnnorm fun_info)))) : complete_lattice.is_Sup_finite_compact (comm_ring (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_108770 (h0 : ordered_comm_monoid (has_nndist (finset pos))) : has_exists_mul_of_le (has_nndist (finset pos)) := sorry --non-trivial
lemma new_lemma_108771 (h0 : topological_space (complete_distrib_lattice pos)) : t1_space (complete_distrib_lattice pos) := sorry --non-trivial
lemma new_lemma_108772 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (complete_distrib_lattice.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} empty))  := sorry --non-trivial
lemma new_lemma_108773 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_zero.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_108774 (h0 : topological_space (with_one (semiring (has_top unsigned)))) : locally_compact_space (with_one (semiring (has_top unsigned))) := sorry --non-trivial
lemma new_lemma_108775 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) linarith.comp) : @preconnected_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_108776 (h0 : functor.add_const (ordered_comm_monoid (cancel_monoid environment.implicit_infer_kind)) name) : @has_exists_mul_of_le.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_108777 (h0 : group (random_gen (denumerable (has_inv linarith.ineq)))) : normalizer_condition (random_gen (denumerable (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_108778 (h0 : topological_space (add_comm_monoid (has_to_string Type))) : totally_separated_space (add_comm_monoid (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_108779 (h0 : topological_space (monoid (option (option (option pos))))) : t1_space (monoid (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_108780 (h0 : topological_space (left_cancel_semigroup (semiring (semiring num)))) : totally_disconnected_space (left_cancel_semigroup (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_108781 (h0 : ring (encodable (random_gen to_additive.value_type))) : rank_condition (encodable (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_108782 (h0 : uniform_space (non_assoc_semiring congr_arg_kind)) : complete_space (non_assoc_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_108783 (h0 : fin has_zero.zero) : @monoid.fg.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (monoid.{0} (comm_semigroup.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_108784 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{1} (complete_distrib_lattice.{1} (boolean_algebra.core.{1} (boolean_algebra.core.{1} Type))) (@matrix.vec_empty.{1} (ordered_comm_monoid.{1} (complete_distrib_lattice.{1} (boolean_algebra.core.{1} (boolean_algebra.core.{1} Type)))) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_108785 (h0 : functor.add_const (topological_space (comm_group pos)) (option unsigned)) : @normal_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_108786 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_108787 (h0 : functor.comp topological_space semigroup Type) : @sequential_space.{1} (semigroup.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} semigroup.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_108788 (h0 : topological_space (boolean_algebra (comm_group Type))) : path_connected_space (boolean_algebra (comm_group Type)) := sorry --non-trivial
lemma new_lemma_108789 (h0 : not (function.extfun (Type 1) topological_space -> false)) : @preirreducible_space.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@classical.by_contradiction'.{3} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_108790 (h0 : ring (normed_comm_ring num)) : is_domain (normed_comm_ring num) := sorry --non-trivial
lemma new_lemma_108791 (h0 : semiring (monoid (add_cancel_comm_monoid empty))) : is_noetherian_ring (monoid (add_cancel_comm_monoid empty)) := sorry --non-trivial
lemma new_lemma_108792 (h0 : functor.add_const (filter Type) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_108793 (h0 : list (boolean_algebra pos)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_108794 (h0 : functor.add_const (topological_space (has_neg name)) pos) : @discrete_topology.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_108795 (h0 : finset (finset (has_Inf (has_pos_part Type)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_108796 (h0 : function.extfun Type topological_space) : @t0_space.{0} (with_bot.{0} (semiring.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} (semiring.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_108797 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_108798 (h0 : functor.add_const (semiring (has_neg pos)) (has_add pos)) : @is_noetherian_ring.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (has_neg.{0} pos)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_108799 (h0 : functor.add_const (add_group (has_zero linarith.comp)) pos) : @is_add_cyclic.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (has_zero.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_108800 (h0 : topological_space (add_comm_monoid (normed_comm_ring ennreal))) : path_connected_space (add_comm_monoid (normed_comm_ring ennreal)) := sorry --non-trivial
lemma new_lemma_108801 (h0 : functor.add_const (topological_space (left_cancel_monoid congr_arg_kind)) empty) : @totally_disconnected_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_108802 (h0 : functor.add_const (finset (bin_tree num)) congr_arg_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_108803 (h0 : ring (has_norm (has_inv fun_info))) : is_domain (has_norm (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_108804 (h0 : add_group (normed_group (semiring (semiring congr_arg_kind)))) : is_add_cyclic (normed_group (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_108805 (h0 : topological_space (has_nndist (has_to_string (has_add unsigned)))) : irreducible_space (has_nndist (has_to_string (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_108806 (h0 : functor.add_const (ordered_comm_monoid (canonically_ordered_comm_semiring linarith.comp)) Type) : @has_exists_mul_of_le.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_108807 (h0 : topological_space (complete_semilattice_Sup linarith.comp)) : normal_space (complete_semilattice_Sup linarith.comp) := sorry --non-trivial
lemma new_lemma_108808 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_108809 (h0 : functor.comp topological_space has_zero num) : @discrete_topology.{0} (has_zero.{0} num) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} num h0)  := sorry --non-trivial
lemma new_lemma_108810 (h0 : fin has_zero.zero) : @irreducible_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_108811 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_108812 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_108813 (h0 : ordered_comm_monoid (has_zero (finset environment.implicit_infer_kind))) : has_exists_mul_of_le (has_zero (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_108814 (h0 : functor.add_const (filter (ring Type)) unsigned) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_108815 (h0 : functor.add_const (ordered_add_comm_monoid (canonically_ordered_monoid real)) real) : @archimedean.{0} (canonically_ordered_monoid.{0} real) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (canonically_ordered_monoid.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_108816 (h0 : ring (has_compl (comm_ring (comm_ring char)))) : strong_rank_condition (has_compl (comm_ring (comm_ring char))) := sorry --non-trivial
lemma new_lemma_108817 (h1 : complete_lattice (random_gen to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_108818 (h0 : ring (complete_semilattice_Sup (random_gen linarith.ineq))) : rank_condition (complete_semilattice_Sup (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_108819 (h0 : uniform_space (measure_theory.measure_space (semiring congr_arg_kind))) : complete_space (measure_theory.measure_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_108820 (h0 : topological_space (cancel_monoid (comm_group name))) : irreducible_space (cancel_monoid (comm_group name)) := sorry --non-trivial
lemma new_lemma_108821 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (finset pos)) := sorry --non-trivial
lemma new_lemma_108822 (h0 : has_mem.mem (complete_semilattice_Sup fun_info) has_emptyc.emptyc) : @irreducible_space.{0} (complete_semilattice_Sup.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_108823 (h0 : uniform_space (has_emptyc empty)) : separated_space (has_emptyc empty) := sorry --non-trivial
lemma new_lemma_108824 (h0 : topological_space (has_norm congr_arg_kind)) : locally_compact_space (has_norm congr_arg_kind) := sorry --non-trivial
lemma new_lemma_108825 (h0 : group (has_to_string (has_zero (finset Type)))) : normalizer_condition (has_to_string (has_zero (finset Type))) := sorry --non-trivial
lemma new_lemma_108826 (h0 : topological_space (ordered_comm_group (option unsigned))) : t1_space (ordered_comm_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_108827 (h0 : ring (with_bot num)) : rank_condition (with_bot num) := sorry --non-trivial
lemma new_lemma_108828 (h0 : filter (has_zero (ring Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_108829 (h0 : group (boolean_algebra (semigroup unsigned))) : normalizer_condition (boolean_algebra (semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_108830 (h0 : topological_space (add_left_cancel_semigroup (option (option (option unsigned))))) : irreducible_space (add_left_cancel_semigroup (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_108831 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_108832 (h0 : topological_space (omega_complete_partial_order (option (option empty)))) : irreducible_space (omega_complete_partial_order (option (option empty))) := sorry --non-trivial
lemma new_lemma_108833 (h0 : group (comm_semigroup (comm_semigroup real))) : is_simple_group (comm_semigroup (comm_semigroup real)) := sorry --non-trivial
lemma new_lemma_108834 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_108835 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_108836 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @preconnected_space.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_108837 (h0 : functor.add_const (filter (has_nndist environment.implicit_infer_kind)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_108838 (h0 : topological_space (has_emptyc (semiring (has_top fun_info)))) : locally_compact_space (has_emptyc (semiring (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_108839 (h0 : uniform_space (ring (finset pos))) : separated_space (ring (finset pos)) := sorry --non-trivial
lemma new_lemma_108840 (h0 : topological_space (has_add (option ennreal))) : t0_space (has_add (option ennreal)) := sorry --non-trivial
lemma new_lemma_108841 (h0 : group (has_neg_part unsigned)) : is_simple_group (has_neg_part unsigned) := sorry --non-trivial
lemma new_lemma_108842 (h0 : topological_space (has_zero (finset (finset (has_neg Type))))) : totally_separated_space (has_zero (finset (finset (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_108843 (h0 : functor.add_const (add_group (has_inter empty)) unsigned) : @is_add_cyclic.{0} (has_inter.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (has_inter.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_108844 (h0 : group (semi_normed_ring (has_compl char))) : is_cyclic (semi_normed_ring (has_compl char)) := sorry --non-trivial
lemma new_lemma_108845 (h0 : functor.add_const (list (has_neg_part Type)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_108846 (h0 : ring (distrib_lattice (add_left_cancel_monoid (random_gen string_imp)))) : strong_rank_condition (distrib_lattice (add_left_cancel_monoid (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_108847 (h0 : topological_space (linear_ordered_cancel_comm_monoid (option unsigned))) : locally_compact_space (linear_ordered_cancel_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_108848 (h0 : group (has_inv (random_gen linarith.comp_source))) : normalizer_condition (has_inv (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_108849 (h0 : topological_space (boolean_algebra (ring pos))) : irreducible_space (boolean_algebra (ring pos)) := sorry --non-trivial
lemma new_lemma_108850 (h0 : topological_space (has_to_string (finset (ring (ring pos))))) : loc_path_connected_space (has_to_string (finset (ring (ring pos)))) := sorry --non-trivial
lemma new_lemma_108851 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_inter.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_inter.{0} num))  := sorry --non-trivial
lemma new_lemma_108852 (h0 : set (std_gen -> add_comm_semigroup enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_108853 (h0 : topological_space (with_one (random_gen num))) : totally_disconnected_space (with_one (random_gen num)) := sorry --non-trivial
lemma new_lemma_108854 (h0 : group (has_Inf (has_Inf linarith.comp))) : group.fg (has_Inf (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_108855 (h0 : has_mem.mem (metric_space linarith.comp) has_emptyc.emptyc) : @is_cyclic.{0} (metric_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type group.{0} (metric_space.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_108856 (h1 : topological_space (has_top (random_gen (semiring to_additive.value_type)))) : irreducible_space (has_top (random_gen (semiring to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_108857 (h0 : functor.add_const (topological_space (has_add unsigned)) linarith.comp) : @loc_path_connected_space.{0} (has_add.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_108858 (h0 : topological_space (normed_comm_ring pos)) : irreducible_space (normed_comm_ring pos) := sorry --non-trivial
lemma new_lemma_108859 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_108860 (h1 : topological_space (complete_distrib_lattice std_gen)) (h2 : preorder (complete_distrib_lattice std_gen)) : order_topology (complete_distrib_lattice std_gen) := sorry --non-trivial
lemma new_lemma_108861 (h1 : uniform_space (complete_semilattice_Sup linarith.comp_source)) : complete_space (complete_semilattice_Sup linarith.comp_source) := sorry --non-trivial
lemma new_lemma_108862 (h0 : functor.add_const (filter (option pos)) num) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_108863 (h0 : not (topological_space (partial_order (semiring (semiring (semiring (semiring empty))))) -> false)) : @preirreducible_space.{0} (partial_order.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty))))) (@classical.by_contradiction'.{1} (topological_space.{0} (partial_order.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty)))))) h0)  := sorry --non-trivial
lemma new_lemma_108864 (h0 : topological_space (has_neg (comm_group pos))) : t1_space (has_neg (comm_group pos)) := sorry --non-trivial
lemma new_lemma_108865 (h0 : uniform_space (with_bot (has_norm linarith.comp))) : separated_space (with_bot (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_108866 (h0 : monoid (normed_linear_ordered_group unsigned)) : monoid.fg (normed_linear_ordered_group unsigned) := sorry --non-trivial
lemma new_lemma_108867 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : totally_separated_space empty := sorry --non-trivial
lemma new_lemma_108868 (h0 : topological_space (has_neg_part (comm_group (has_add (comm_group Type))))) : loc_path_connected_space (has_neg_part (comm_group (has_add (comm_group Type)))) := sorry --non-trivial
lemma new_lemma_108869 (h0 : functor.add_const (group (has_star empty)) num) : @group.fg.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (has_star.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_108870 (h0 : functor.add_const (ring (semigroup empty)) empty) : @is_domain.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_108871 (h0 : group (add_cancel_monoid congr_arg_kind)) : normalizer_condition (add_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_108872 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_108873 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (mul_zero_class.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (mul_zero_class.{0} empty))  := sorry --non-trivial
lemma new_lemma_108874 (h0 : functor.add_const (finset (add_comm_monoid environment.implicit_infer_kind)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_108875 (h0 : ring (complete_distrib_lattice (ring (finset linarith.comp)))) : is_principal_ideal_ring (complete_distrib_lattice (ring (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_108876 (h0 : functor.add_const (complete_lattice (boolean_algebra.core congr_arg_kind)) congr_arg_kind) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.core.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_108877 (h0 : topological_space (random_gen fun_info)) : preirreducible_space (random_gen fun_info) := sorry --non-trivial
lemma new_lemma_108878 (h0 : topological_space (has_neg (finset (finset (finset pos))))) : discrete_topology (has_neg (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_108879 (h0 : functor.add_const (add_monoid (has_to_string linarith.comp)) (has_add environment.implicit_infer_kind)) : @add_monoid.fg.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_to_string.{0} linarith.comp)) (has_add.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_108880 (h0 : topological_space (random_gen (random_gen to_additive.value_type))) : totally_separated_space (random_gen (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_108881 (h0 : topological_space (semigroup (option (has_to_string pos)))) : t0_space (semigroup (option (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_108882 (h0 : group (has_edist (semiring (semiring empty)))) : is_cyclic (has_edist (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_108883 (h0 : not (function.extfun Type cancel_comm_monoid_with_zero -> false)) : @unique_factorization_monoid.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) h0) (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_108884 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (random_gen.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (random_gen.{0} empty))  := sorry --non-trivial
lemma new_lemma_108885 (h0 : functor.add_const (topological_space (mul_zero_class name)) name) : @t1_space.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_108886 (h0 : add_group (boolean_algebra.core linarith.comp)) : is_add_cyclic (boolean_algebra.core linarith.comp) := sorry --non-trivial
lemma new_lemma_108887 (h0 : list (has_ssubset (random_gen (random_gen (random_gen char))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_108888 (h0 : add_monoid (semigroup (cancel_monoid pos))) : add_monoid.fg (semigroup (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_108889 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen linarith.ineq))) : @separated_space.{0} (random_gen.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type uniform_space.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.ineq)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_108890 (h0 : functor.add_const (filter (ring unsigned)) unsigned) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_108891 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) pos) : @discrete_topology.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_108892 (h0 : group (comm_group (ring pos))) : group.fg (comm_group (ring pos)) := sorry --non-trivial
lemma new_lemma_108893 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_108894 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (is_R_or_C.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (is_R_or_C.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_108895 (h0 : functor.add_const (list (has_neg_part environment.implicit_infer_kind)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_108896 (h0 : finset (complete_linear_order (ordered_cancel_comm_monoid congr_arg_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_108897 (h0 : empty) : @complete_space.{0} (@id.{2} Type (linear_ordered_semiring.{0} unsigned)) (@empty.elim.{1} (uniform_space.{0} (@id.{2} Type (linear_ordered_semiring.{0} unsigned))) h0)  := sorry --non-trivial
lemma new_lemma_108898 (h0 : topological_space (semi_normed_comm_ring linarith.ineq)) : t0_space (semi_normed_comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_108899 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_108900 (h0 : topological_space (has_edist (option (option (option unsigned))))) : discrete_topology (has_edist (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_108901 (h0 : function.extfun (Type 1) finset) : finset.nonempty (function.extfun_app h0 (plift empty)) := sorry --non-trivial
lemma new_lemma_108902 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_108903 (h0 : ring (has_nndist environment.implicit_infer_kind)) : strong_rank_condition (has_nndist environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_108904 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring Type)) name) : @topological_space.separable_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (canonically_ordered_comm_semiring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_108905 (h0 : uniform_space (ordered_comm_semiring linarith.comp_source)) : complete_space (ordered_comm_semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_108906 (h0 : ring (bin_tree (semiring num))) : rank_condition (bin_tree (semiring num)) := sorry --non-trivial
lemma new_lemma_108907 (h0 : functor.add_const (group (ring Type)) linarith.comp) : @is_simple_group.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_108908 (h1 : has_mem.mem (random_gen num) has_emptyc.emptyc) : @strong_rank_condition.{0} (random_gen.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (random_gen.{0} num) h1)  := sorry --non-trivial
lemma new_lemma_108909 (h0 : group (generalized_boolean_algebra (sub_neg_monoid real))) : is_cyclic (generalized_boolean_algebra (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_108910 (h0 : semiring (add_comm_monoid num)) : is_noetherian_ring (add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_108911 (h0 : ring (add_cancel_monoid (finset environment.implicit_infer_kind))) : is_domain (add_cancel_monoid (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_108912 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) Type) : @irreducible_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (normed_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_108913 (h0 : functor.add_const (uniform_space (normed_comm_ring name)) name) : @complete_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (normed_comm_ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_108914 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_inter.{0} ennreal) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_inter.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_108915 (h0 : not (fin has_zero.zero -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_nnnorm.{0} char) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_nnnorm.{0} char)) (@classical.by_contradiction'.{1} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_108916 (h2 : set (random_gen to_additive.value_type)) : set.finite h2 := sorry --non-trivial
lemma new_lemma_108917 (h0 : functor.add_const (finset (comm_group linarith.comp)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_108918 (h0 : functor.add_const (monoid (cancel_monoid Type)) pos) : @monoid.fg.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (cancel_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_108919 (h0 : topological_space (complete_distrib_lattice (ring (ring linarith.comp)))) : t1_space (complete_distrib_lattice (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_108920 (h0 : functor.add_const (filter (omega_complete_partial_order empty)) empty) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_108921 (h0 : fin has_zero.zero) : @is_cyclic.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) group.{1}) h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_108922 (h0 : functor.add_const (function.extfun (Type 1) ring) (finset environment.implicit_infer_kind)) : @strong_rank_condition.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) (finset.{0} environment.implicit_infer_kind) h0) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_108923 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_dist.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_dist.{0} num))  := sorry --non-trivial
lemma new_lemma_108924 (h0 : topological_space (pseudo_metric_space num)) : totally_disconnected_space (pseudo_metric_space num) := sorry --non-trivial
lemma new_lemma_108925 (h1 : complete_lattice (normed_group fun_info)) : is_compactly_generated (normed_group fun_info) := sorry --non-trivial
lemma new_lemma_108926 (h0 : functor.add_const (function.extfun (Type 1) ring) name) : @is_domain.{1} Type (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) name h0) Type)  := sorry --non-trivial
lemma new_lemma_108927 (h0 : topological_space (has_dist (option empty))) : locally_compact_space (has_dist (option empty)) := sorry --non-trivial
lemma new_lemma_108928 (h1 : ring (with_zero (has_nnnorm fun_info))) : is_domain (with_zero (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_108929 (h0 : topological_space (ordered_cancel_add_comm_monoid ennreal)) : preirreducible_space (ordered_cancel_add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_108930 (h0 : functor.add_const (topological_space (has_to_string pos)) name) : @normal_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_108931 (h0 : functor.add_const (finset (left_cancel_semigroup empty)) (semiring empty)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_108932 (h0 h1 : not (multiset (has_ssubset reducibility_hints) -> false)) : multiset.disjoint (classical.by_contradiction' h0) (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_108933 (h0 : topological_space (has_inter (option unsigned))) : t0_space (has_inter (option unsigned)) := sorry --non-trivial
lemma new_lemma_108934 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_108935 (h0 : function.extfun Type group) : @normalizer_condition.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type group.{0} h0 (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_108936 (h0 : function.extfun Type (functor.add_const (list (add_left_cancel_semigroup num)))) : palindrome (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_108937 (h0 : function.extfun Type group) : @normalizer_condition.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_108938 (h0 : not (uniform_space (distrib linarith.ineq) -> false)) : @complete_space.{0} (distrib.{0} linarith.ineq) (@classical.by_contradiction'.{1} (uniform_space.{0} (distrib.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_108939 (h0 : topological_space (ordered_comm_ring (ordered_comm_ring pos))) : preirreducible_space (ordered_comm_ring (ordered_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_108940 (h0 : uniform_space (canonically_ordered_comm_semiring empty)) : separated_space (canonically_ordered_comm_semiring empty) := sorry --non-trivial
lemma new_lemma_108941 (h0 : topological_space znum) : discrete_topology znum := sorry --non-trivial
lemma new_lemma_108942 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_108943 (h0 : cancel_comm_monoid_with_zero (semigroup name)) : unique_factorization_monoid (semigroup name) := sorry --non-trivial
lemma new_lemma_108944 (h1 : group (encodable (with_bot to_additive.value_type))) : group.fg (encodable (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_108945 (h1 h2 : multiset (has_nnnorm linarith.ineq)) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_108946 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_108947 (h1 : ring (add_monoid (normed_field (mul_one_class fun_info)))) : is_domain (add_monoid (normed_field (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_108948 (h0 : functor.add_const (function.extfun (Type 1) filter) (finset (finset (has_zero (has_add linarith.comp))))) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) Type) := sorry --non-trivial
lemma new_lemma_108949 (h0 : list (has_top (random_gen fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_108950 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_108951 (h0 : functor.add_const (group (boolean_algebra unsigned)) Type) : @is_simple_group.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 1} (group.{0} (boolean_algebra.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_108952 (h0 : topological_space (has_div linarith.ineq)) (h1 : preorder (has_div linarith.ineq)) : order_topology (has_div linarith.ineq) := sorry --non-trivial
lemma new_lemma_108953 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} h0 (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_108954 (h0 : topological_space (has_add (has_to_string pos))) : totally_separated_space (has_add (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_108955 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @normal_space.{0} (ordered_comm_monoid.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} name)) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero))) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_108956 (h1 : add_group (bin_tree string.iterator_imp)) : is_add_cyclic (bin_tree string.iterator_imp) := sorry --non-trivial
lemma new_lemma_108957 (h0 : functor.add_const (group (has_to_string linarith.comp)) name) : @normalizer_condition.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_108958 (h0 : group (canonically_linear_ordered_monoid (has_Inf (has_add pos)))) : normalizer_condition (canonically_linear_ordered_monoid (has_Inf (has_add pos))) := sorry --non-trivial
lemma new_lemma_108959 (h0 : topological_space (pseudo_metric_space congr_arg_kind)) : totally_separated_space (pseudo_metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_108960 (h0 : functor.add_const (functor.add_const (function.extfun Type group) pos) Type) : @group.fg.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos (@functor.add_const.run.{1 1} (functor.add_const.{1 0} (function.extfun.{2 1} Type group.{0}) pos) Type h0)) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_108961 (h0 : not (topological_space (add_right_cancel_monoid unsigned) -> false)) : @path_connected_space.{0} (add_right_cancel_monoid.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (add_right_cancel_monoid.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_108962 (h0 : uniform_space (measurable_space (has_inv fun_info))) : complete_space (measurable_space (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_108963 (h0 : uniform_space ereal) : separated_space ereal := sorry --non-trivial
lemma new_lemma_108964 (h0 : functor.add_const (ring (add_cancel_monoid pos)) linarith.comp) : @strong_rank_condition.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_108965 (h0 : complete_lattice (measurable_space (random_gen (has_norm to_additive.value_type)))) : is_atomistic (measurable_space (random_gen (has_norm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_108966 (h0 : topological_space (with_one (has_top (has_sub unsigned)))) : normal_space (with_one (has_top (has_sub unsigned))) := sorry --non-trivial
lemma new_lemma_108967 (h0 : group (canonically_linear_ordered_monoid unsigned)) : is_simple_group (canonically_linear_ordered_monoid unsigned) := sorry --non-trivial
lemma new_lemma_108968 (h0 : ring (linear_ordered_add_comm_group (random_gen to_additive.value_type))) : rank_condition (linear_ordered_add_comm_group (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_108969 (h0 : add_group (distrib char)) : is_add_cyclic (distrib char) := sorry --non-trivial
lemma new_lemma_108970 (h0 : filter (ring (has_add (has_pos_part (ring (has_pos_part linarith.comp)))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_108971 (h0 : complete_lattice (add_cancel_monoid (option unsigned))) : complete_lattice.is_Sup_finite_compact (add_cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_108972 (h0 : topological_space (has_norm (has_nnnorm linarith.ineq))) : path_connected_space (has_norm (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_108973 (h0 : function.extfun (semigroup empty) (fun (x : semigroup empty), Prop)) : exists_unique (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_108974 (h0 : filter (has_add (option ennreal))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_108975 (h1 : topological_space (random_gen (random_gen (comm_ring (comm_ring linarith.comp_source))))) : t0_space (random_gen (random_gen (comm_ring (comm_ring linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_108976 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) name) : @loc_path_connected_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_108977 (h0 : functor.add_const (list (bin_tree congr_arg_kind)) congr_arg_kind) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_108978 (h0 : fin has_zero.zero) : @strong_rank_condition.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (comm_semigroup.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_108979 (h0 : functor.add_const (monoid (ring pos)) name) : @monoid.fg.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_108980 (h1 : filter (with_zero linarith.comp_source)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_108981 (h0 : ring (has_bot (sub_neg_monoid real))) : is_principal_ideal_ring (has_bot (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_108982 (h0 : filter (monoid_with_zero unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_108983 (h0 : complete_lattice (ordered_comm_monoid (has_Inf real))) : complete_lattice.is_Sup_finite_compact (ordered_comm_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_108984 (h0 : function.extfun Type ring) : @is_domain.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_108985 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} to_additive.value_type (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_108986 (h0 : complete_lattice (ordered_comm_ring (has_add real))) : is_atomistic (ordered_comm_ring (has_add real)) := sorry --non-trivial
lemma new_lemma_108987 (h0 : function.extfun Type (functor.comp topological_space complete_distrib_lattice)) : @t0_space.{0} (complete_distrib_lattice.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} complete_distrib_lattice.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_108988 (h0 : function.extfun Type (functor.add_const (group (linear_ordered_cancel_comm_monoid empty)))) : @is_cyclic.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (linear_ordered_cancel_comm_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} (linear_ordered_cancel_comm_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_108989 (h0 : monoid char) (h1 : char) : is_of_fin_order h1 := sorry --non-trivial
lemma new_lemma_108990 (h0 : topological_space (semigroup (has_Inf (boolean_algebra (has_pos_part pos))))) : path_connected_space (semigroup (has_Inf (boolean_algebra (has_pos_part pos)))) := sorry --non-trivial
lemma new_lemma_108991 (h0 : has_lt (canonically_linear_ordered_monoid to_additive.value_type)) : no_max_order (canonically_linear_ordered_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_108992 (h0 : has_mem.mem to_additive.value_type has_emptyc.emptyc) : @is_add_cyclic.{0} to_additive.value_type (@finset.pi.empty.{1 0} Type add_group.{0} to_additive.value_type h0)  := sorry --non-trivial
lemma new_lemma_108993 (h0 : filter (linear_ordered_comm_monoid_with_zero num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_108994 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (canonically_linear_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (canonically_linear_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_108995 (h0 : functor.add_const (group (add_left_cancel_semigroup unsigned)) unsigned) : @is_cyclic.{0} (add_left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (add_left_cancel_semigroup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_108996 (h0 : topological_space (canonically_ordered_monoid (has_neg (complete_distrib_lattice (has_neg real))))) : irreducible_space (canonically_ordered_monoid (has_neg (complete_distrib_lattice (has_neg real)))) := sorry --non-trivial
lemma new_lemma_108997 (h0 : set (linear_ordered_comm_group_with_zero (mul_one_class to_additive.value_type))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_108998 (h0 : topological_space (filter unsigned)) : normal_space (filter unsigned) := sorry --non-trivial
lemma new_lemma_108999 (h0 : add_group (semi_normed_ring (has_ssubset to_additive.value_type))) : is_add_cyclic (semi_normed_ring (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_109000 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @normal_space.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (metric_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_109001 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (canonically_ordered_comm_semiring ennreal)) := sorry --non-trivial
lemma new_lemma_109002 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) pos) := sorry --non-trivial
lemma new_lemma_109003 (h0 : filter (has_inter (option num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_109004 (h0 : fin has_zero.zero) : @path_connected_space.{0} (canonically_linear_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_109005 (h0 : topological_space (has_to_string ennreal)) : path_connected_space (has_to_string ennreal) := sorry --non-trivial
lemma new_lemma_109006 (h0 : add_group (semi_normed_ring (mul_one_class string.iterator_imp))) : is_add_cyclic (semi_normed_ring (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_109007 (h0 : not (ring (has_compl char) -> false)) : @strong_rank_condition.{0} (has_compl.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (has_compl.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_109008 (h0 : ring (has_top (has_norm num))) : is_domain (has_top (has_norm num)) := sorry --non-trivial
lemma new_lemma_109009 (h0 : add_monoid (mul_zero_class pos)) : add_monoid.fg (mul_zero_class pos) := sorry --non-trivial
lemma new_lemma_109010 (h0 : ring (has_append char)) : rank_condition (has_append char) := sorry --non-trivial
lemma new_lemma_109011 (h0 : add_group (normed_field (normed_field reducibility_hints))) : is_add_cyclic (normed_field (normed_field reducibility_hints)) := sorry --non-trivial
lemma new_lemma_109012 (h0 : has_lt string) : no_min_order string := sorry --non-trivial
lemma new_lemma_109013 (h0 : not (ring (has_compl linarith.ineq) -> false)) : @is_domain.{0} (has_compl.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (has_compl.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_109014 (h0 : topological_space (distrib_lattice (random_gen to_additive.value_type))) : locally_compact_space (distrib_lattice (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_109015 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (add_cancel_monoid empty)) := sorry --non-trivial
lemma new_lemma_109016 (h0 : ordered_add_comm_monoid (ring (ordered_ring linarith.comp))) : archimedean (ring (ordered_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_109017 (h0 : group (has_neg_part (has_nndist environment.implicit_infer_kind))) : is_simple_group (has_neg_part (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_109018 (h0 : has_mem.mem (semiring linarith.comp) has_emptyc.emptyc) : @group.fg.{0} (semiring.{0} linarith.comp) (@finset.pi.empty.{1 0} Type group.{0} (semiring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_109019 (h0 : filter (has_to_string (has_to_string (comm_group (has_to_string unsigned))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_109020 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_109021 (h0 : functor.add_const (function.extfun nat fin) pos) : @separated_space.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (has_add.{1} Type)) (@function.extfun_app.{1 1} nat fin (@functor.add_const.run.{0 0} (function.extfun.{1 1} nat fin) pos h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_109022 (h0 : functor.add_const (ring (mul_zero_class unsigned)) num) : @is_principal_ideal_ring.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (mul_zero_class.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_109023 (h0 : uniform_space (normed_comm_ring (add_comm_monoid environment.implicit_infer_kind))) : separated_space (normed_comm_ring (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_109024 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_109025 (h1 : filter num) : countable_Inter_filter h1 := sorry --non-trivial
lemma new_lemma_109026 (h3 : set (std_gen -> std_gen)) : set.separates_points h3 := sorry --non-trivial
lemma new_lemma_109027 (h0 : list (has_Sup num)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_109028 (h0 : ring (random_gen (has_nnnorm (has_nnnorm linarith.comp_source)))) : is_domain (random_gen (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_109029 (h0 : group (complete_distrib_lattice name)) : normalizer_condition (complete_distrib_lattice name) := sorry --non-trivial
lemma new_lemma_109030 (h0 : functor.add_const (topological_space (has_zero pos)) environment.implicit_infer_kind) : @totally_separated_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_109031 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_nndist.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} num))  := sorry --non-trivial
lemma new_lemma_109032 (h0 : complete_lattice (has_bot (has_add (has_Inf (has_add (has_add pos)))))) : is_compactly_generated (has_bot (has_add (has_Inf (has_add (has_add pos))))) := sorry --non-trivial
lemma new_lemma_109033 (h0 : topological_space (has_neg (semigroup unsigned))) : totally_disconnected_space (has_neg (semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_109034 (h0 : complete_lattice (bin_tree (option unsigned))) : complete_lattice.is_Sup_finite_compact (bin_tree (option unsigned)) := sorry --non-trivial
lemma new_lemma_109035 (h0 : functor.add_const (ring (left_cancel_monoid num)) congr_arg_kind) : @strong_rank_condition.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_109036 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring linarith.comp)) (ring (has_neg (ring linarith.comp)))) : @is_domain.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) (ring.{0} (has_neg.{0} (ring.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_109037 (h0 : fin has_zero.zero) : @totally_separated_space.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (sub_neg_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_109038 (h0 : functor.add_const (topological_space (has_zero unsigned)) (has_nndist (ring environment.implicit_infer_kind))) : @totally_disconnected_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) (has_nndist.{0} (ring.{0} environment.implicit_infer_kind)) h0)  := sorry --non-trivial
lemma new_lemma_109039 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (has_top.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_nnnorm.{0} char)))))) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_top.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_nnnorm.{0} char)))))))  := sorry --non-trivial
lemma new_lemma_109040 (h0 : functor.add_const (topological_space (has_neg name)) Type) : @totally_separated_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_109041 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @is_cyclic.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_109042 (h0 : function.extfun Type ring) : @rank_condition.{0} (right_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (right_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_109043 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) name) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) name h0) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_109044 (h0 : monoid (semigroup (boolean_algebra (has_nndist Type)))) : monoid.fg (semigroup (boolean_algebra (has_nndist Type))) := sorry --non-trivial
lemma new_lemma_109045 (h0 : has_mem.mem (measurable_space linarith.ineq) has_emptyc.emptyc) : @strong_rank_condition.{0} (measurable_space.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type ring.{0} (measurable_space.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_109046 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (finset.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (finset.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_109047 (h0 : functor.add_const (uniform_space (has_neg linarith.comp)) (has_neg Type)) : @complete_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_neg.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_109048 (h0 : topological_space num) : path_connected_space num := sorry --non-trivial
lemma new_lemma_109049 (h0 : complete_lattice (has_norm (has_emptyc linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (has_norm (has_emptyc linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_109050 (h0 : topological_space (comm_monoid (semiring (semiring unsigned)))) : irreducible_space (comm_monoid (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_109051 (h0 : preorder (has_star unsigned)) (h1 : pred_order (has_star unsigned)) : is_pred_archimedean (has_star unsigned) := sorry --non-trivial
lemma new_lemma_109052 (h0 : not (ring (has_ssubset (metric_space (random_gen char))) -> false)) : @is_domain.{0} (has_ssubset.{0} (metric_space.{0} (random_gen.{0} char))) (@classical.by_contradiction'.{1} (ring.{0} (has_ssubset.{0} (metric_space.{0} (random_gen.{0} char)))) h0)  := sorry --non-trivial
lemma new_lemma_109053 (h0 : functor.add_const (monoid (has_star congr_arg_kind)) congr_arg_kind) : @monoid.fg.{0} (has_star.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (monoid.{0} (has_star.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_109054 (h0 : functor.add_const (group (has_Inf linarith.comp)) Type) : @is_cyclic.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (has_Inf.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_109055 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_monoid_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_109056 (h0 : cancel_comm_monoid_with_zero (has_inter (option (option (option unsigned))))) : unique_factorization_monoid (has_inter (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_109057 (h0 : list (boolean_algebra (has_Inf linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_109058 (h0 : topological_space (dlist (has_nnnorm linarith.ineq))) : locally_compact_space (dlist (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_109059 (h0 : topological_space (boolean_algebra (normed_comm_ring environment.implicit_infer_kind))) : preirreducible_space (boolean_algebra (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_109060 (h0 : ordered_comm_monoid (complete_distrib_lattice (has_Inf pos))) : has_exists_mul_of_le (complete_distrib_lattice (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_109061 (h0 : functor.add_const (topological_space (simple_graph linarith.comp)) (finset (finset pos))) : @preirreducible_space.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} linarith.comp)) (finset.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_109062 (h0 : ring (fintype char)) : strong_rank_condition (fintype char) := sorry --non-trivial
lemma new_lemma_109063 (h0 : ordered_add_comm_monoid (semigroup (measurable_space Type))) : archimedean (semigroup (measurable_space Type)) := sorry --non-trivial
lemma new_lemma_109064 (h0 : functor.add_const (topological_space (canonically_ordered_monoid linarith.comp)) pos) : @t1_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_109065 (h1 : not (topological_space enat -> false)) : @t0_space.{0} enat (@classical.by_contradiction'.{1} (topological_space.{0} enat) h1)  := sorry --non-trivial
lemma new_lemma_109066 (h0 : topological_space (complete_distrib_lattice (ordered_comm_monoid linarith.comp))) : t1_space (complete_distrib_lattice (ordered_comm_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_109067 (h0 : uniform_space (linear_ordered_semiring (has_norm (random_gen num)))) : complete_space (linear_ordered_semiring (has_norm (random_gen num))) := sorry --non-trivial
lemma new_lemma_109068 (h0 : set (has_le (mul_one_class (mul_one_class (mul_one_class linarith.ineq))))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_109069 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (with_zero unsigned)) := sorry --non-trivial
lemma new_lemma_109070 (h0 : ring (has_nndist (option (option (option (comm_monoid empty)))))) : is_domain (has_nndist (option (option (option (comm_monoid empty))))) := sorry --non-trivial
lemma new_lemma_109071 (h1 : uniform_space (add_left_cancel_monoid (has_nnnorm to_additive.value_type))) : complete_space (add_left_cancel_monoid (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_109072 (h2 : ring (non_unital_non_assoc_semiring string_imp)) : strong_rank_condition (non_unital_non_assoc_semiring string_imp) := sorry --non-trivial
lemma new_lemma_109073 (h4 : topological_space (random_gen (has_nnnorm linarith.ineq))) : path_connected_space (random_gen (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_109074 (h0 : add_group (random_gen (mul_one_class (has_nnnorm reducibility_hints)))) : is_add_cyclic (random_gen (mul_one_class (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_109075 (h0 : topological_space (complete_semilattice_Sup unsigned)) : t1_space (complete_semilattice_Sup unsigned) := sorry --non-trivial
lemma new_lemma_109076 (h0 : topological_space (has_neg_part (option pos))) : totally_disconnected_space (has_neg_part (option pos)) := sorry --non-trivial
lemma new_lemma_109077 (h0 : complete_lattice (add_comm_monoid (finset pos))) : is_compactly_generated (add_comm_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_109078 (h0 : finset (semigroup (ring pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_109079 (h0 : topological_space (complete_semilattice_Sup (has_top (has_inv (has_norm string_imp))))) : t0_space (complete_semilattice_Sup (has_top (has_inv (has_norm string_imp)))) := sorry --non-trivial
lemma new_lemma_109080 (h0 : functor.add_const (semiring (ring pos)) (boolean_algebra pos)) : @is_noetherian_ring.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (ring.{0} pos)) (boolean_algebra.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_109081 (h0 : add_group (has_emptyc unsigned)) : is_add_cyclic (has_emptyc unsigned) := sorry --non-trivial
lemma new_lemma_109082 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (finset.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (finset.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_109083 (h0 : list (has_norm (has_nnnorm (has_nnnorm (has_ssubset fun_info))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_109084 (h0 : topological_space (has_add (has_neg environment.implicit_infer_kind))) : totally_separated_space (has_add (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_109085 (h0 : fin has_zero.zero) : matrix.vec_empty (id (matrix.vec_empty (id (id (id h0))))) := sorry --non-trivial
lemma new_lemma_109086 (h1 : topological_space (linear_ordered_comm_group_with_zero linarith.comp_source)) : totally_disconnected_space (linear_ordered_comm_group_with_zero linarith.comp_source) := sorry --non-trivial
lemma new_lemma_109087 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (comm_group.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (comm_group.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_109088 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (non_assoc_semiring.{0} num) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (non_assoc_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_109089 (h0 : ring (option num)) : is_domain (option num) := sorry --non-trivial
lemma new_lemma_109090 (h0 : filter (has_to_string congr_arg_kind)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_109091 (h0 : topological_space (add_cancel_monoid (option unsigned))) : totally_disconnected_space (add_cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_109092 (h0 : topological_space (ordered_comm_monoid (boolean_algebra.core (has_Inf pos)))) : preirreducible_space (ordered_comm_monoid (boolean_algebra.core (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_109093 (h0 : not (ring (denumerable linarith.ineq) -> false)) : @is_domain.{0} (denumerable.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (denumerable.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_109094 (h1 : topological_space (denumerable (random_gen (random_gen (random_gen char))))) : path_connected_space (denumerable (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_109095 (h0 : cancel_comm_monoid_with_zero (generalized_boolean_algebra (finset pos))) : unique_factorization_monoid (generalized_boolean_algebra (finset pos)) := sorry --non-trivial
lemma new_lemma_109096 (h0 : finset (has_to_string (option pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_109097 (h0 : functor.add_const (topological_space (ring empty)) num) : @normal_space.{0} (ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_109098 (h0 : enat -> enat -> bool) : is_dec_refl h0 := sorry --non-trivial
lemma new_lemma_109099 (h0 : uniform_space (boolean_algebra (has_add (has_add Type)))) : complete_space (boolean_algebra (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_109100 (h0 : functor.add_const (list (semigroup Type)) environment.implicit_infer_kind) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_109101 (h0 : has_mem.mem ring has_emptyc.emptyc) : @is_domain.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_109102 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_109103 (h0 : complete_lattice (measurable_space (has_top fun_info))) : complete_lattice.is_Sup_finite_compact (measurable_space (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_109104 (h0 : uniform_space (random_gen empty)) : separated_space (random_gen empty) := sorry --non-trivial
lemma new_lemma_109105 (h0 : topological_space (option unsigned)) : t1_space (option unsigned) := sorry --non-trivial
lemma new_lemma_109106 (h0 : not (uniform_space (normed_group unsigned) -> false)) : @separated_space.{0} (normed_group.{0} unsigned) (@classical.by_contradiction'.{1} (uniform_space.{0} (normed_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_109107 (h0 : not (topological_space (measurable_space linarith.comp) -> false)) : @path_connected_space.{0} (measurable_space.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_109108 (h0 : uniform_space (add_cancel_monoid (option unsigned))) : separated_space (add_cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_109109 (h0 : normed_comm_ring (finset pos) -> normed_comm_ring (finset pos) -> Prop) : is_antisymm (normed_comm_ring (finset pos)) h0 := sorry --non-trivial
lemma new_lemma_109110 (h0 : ring (denumerable (has_ssubset to_additive.value_type))) : is_domain (denumerable (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_109111 (h0 : not (has_mem.mem (normed_group num) has_emptyc.emptyc -> false)) : @locally_compact_space.{0} (normed_group.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_109112 (h1 : filter (distrib_lattice (has_nnnorm char))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_109113 (h0 : function.extfun Type group) : @is_simple_group.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_109114 (h0 : functor.comp semiring mul_zero_class ennreal) : @is_noetherian_ring.{0} (mul_zero_class.{0} ennreal) (@functor.comp.run.{0 0 0} semiring.{0} mul_zero_class.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_109115 (h0 : monoid (comm_group (finset environment.implicit_infer_kind))) : monoid.fg (comm_group (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_109116 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_109117 (h0 : topological_space (preorder (option unsigned))) : topological_space.separable_space (preorder (option unsigned)) := sorry --non-trivial
lemma new_lemma_109118 (h0 : list (mul_zero_class (has_add (has_to_string (has_add ennreal))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_109119 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_109120 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (ring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_109121 (h0 : topological_space (has_to_string (has_neg_part name))) : t1_space (has_to_string (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_109122 (h0 : functor.add_const (filter (boolean_algebra name)) (boolean_algebra (boolean_algebra Type))) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_109123 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) pos) : @separated_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) uniform_space.{1}) pos h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_109124 (h0 : topological_space (plift (option unsigned))) : totally_disconnected_space (plift (option unsigned)) := sorry --non-trivial
lemma new_lemma_109125 (h0 : topological_space (has_to_string (has_Inf (semigroup pos)))) : preconnected_space (has_to_string (has_Inf (semigroup pos))) := sorry --non-trivial
lemma new_lemma_109126 (h0 : topological_space (canonically_linear_ordered_monoid Type)) : loc_path_connected_space (canonically_linear_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_109127 (h0 : functor.add_const (topological_space (ring name)) linarith.comp) : @t0_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_109128 (h0 : functor.add_const (function.extfun Type topological_space) (has_pos_part linarith.comp)) : @irreducible_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_pos_part.{0} linarith.comp) h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_109129 (h0 : topological_space (generalized_boolean_algebra (has_nndist (has_add (ring pos))))) : preirreducible_space (generalized_boolean_algebra (has_nndist (has_add (ring pos)))) := sorry --non-trivial
lemma new_lemma_109130 (h0 : topological_space (has_neg_part environment.implicit_infer_kind)) : totally_separated_space (has_neg_part environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_109131 (h0 : functor.add_const (function.extfun (Type 1) cancel_comm_monoid_with_zero) name) : @unique_factorization_monoid.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1}) name h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_109132 (h0 : group (canonically_ordered_monoid (has_Inf (finset (has_Inf (has_Inf pos)))))) : is_cyclic (canonically_ordered_monoid (has_Inf (finset (has_Inf (has_Inf pos))))) := sorry --non-trivial
lemma new_lemma_109133 (h0 : topological_space (has_top (with_one (random_gen (has_nnnorm fun_info))))) : t0_space (has_top (with_one (random_gen (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_109134 (h0 : uniform_space (topological_space (has_nnnorm (has_nnnorm fun_info)))) : complete_space (topological_space (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_109135 (h0 : filter (comm_monoid unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_109136 (h0 : not (ring (topological_space to_additive.value_type) -> false)) : @strong_rank_condition.{0} (topological_space.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (topological_space.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_109137 (h0 : has_mem.mem topological_space has_emptyc.emptyc) (h1 : has_norm num) (h2 : function.extfun Type uniform_space) : @complete_space.{0} (@topological_space.open_nhds_of.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_norm.{0} num)) h1) (@function.extfun_app.{2 1} Type uniform_space.{0} h2 (@topological_space.open_nhds_of.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_norm.{0} num)) h1))  := sorry --non-trivial
lemma new_lemma_109138 (h0 : functor.add_const (monoid (boolean_algebra pos)) (comm_group Type)) : @monoid.fg.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (monoid.{0} (boolean_algebra.{0} pos)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_109139 (h0 : filter (semigroup (has_nndist name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_109140 (h0 : ring (random_gen (has_nnnorm (has_nnnorm linarith.ineq)))) : strong_rank_condition (random_gen (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_109141 (h0 : functor.add_const (ring (complete_distrib_lattice linarith.comp)) linarith.comp) : @strong_rank_condition.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_109142 (h1 : complete_lattice (dlist (random_gen string_imp))) : complete_lattice.is_Sup_finite_compact (dlist (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_109143 (h0 : finset (finset (has_add real))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_109144 (h0 : functor.add_const (group (has_zero Type)) (has_to_string (has_to_string Type))) : @is_simple_group.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (has_zero.{1} Type)) (has_to_string.{1} (has_to_string.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_109145 (h0 : functor.add_const (function.extfun Type complete_lattice) name) : @is_atomistic.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) name h0) (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_109146 (h0 : add_group (option (semiring (semiring empty)))) : is_add_cyclic (option (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_109147 (h0 : finset (ring congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_109148 (h1 : not (topological_space (fintype char) -> false)) : @t0_space.{0} (fintype.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (fintype.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_109149 (h0 : has_neg_part ennreal -> has_neg_part ennreal -> Prop) : is_refl (has_neg_part ennreal) h0 := sorry --non-trivial
lemma new_lemma_109150 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_109151 (h0 : topological_space (normed_group (has_top (has_norm congr_arg_kind)))) : discrete_topology (normed_group (has_top (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_109152 (h0 : functor.add_const (monoid (comm_group environment.implicit_infer_kind)) Type) : @monoid.fg.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (monoid.{0} (comm_group.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_109153 (h0 : functor.add_const (ring nnreal) unsigned) : @strong_rank_condition.{0} nnreal (@functor.add_const.run.{0 0} (ring.{0} nnreal) unsigned h0)  := sorry --non-trivial
lemma new_lemma_109154 (h0 : ring (has_bot (ordered_comm_monoid (ordered_comm_monoid real)))) : rank_condition (has_bot (ordered_comm_monoid (ordered_comm_monoid real))) := sorry --non-trivial
lemma new_lemma_109155 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_109156 (h0 : topological_space (finset congr_arg_kind)) : normal_space (finset congr_arg_kind) := sorry --non-trivial
lemma new_lemma_109157 (h0 : ring (has_nnnorm (mul_one_class (mul_one_class (has_lt (mul_one_class enat)))))) : strong_rank_condition (has_nnnorm (mul_one_class (mul_one_class (has_lt (mul_one_class enat))))) := sorry --non-trivial
lemma new_lemma_109158 (h0 : functor.add_const (functor.add_const (add_group nnreal) unsigned) unsigned) : @is_add_cyclic.{0} nnreal (@functor.add_const.run.{0 0} (add_group.{0} nnreal) unsigned (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (add_group.{0} nnreal) unsigned) unsigned h0))  := sorry --non-trivial
lemma new_lemma_109159 (h0 : functor.add_const (topological_space (has_to_string name)) linarith.comp) : @loc_path_connected_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_109160 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_109161 (h0 : topological_space (has_inter congr_arg_kind)) : totally_disconnected_space (has_inter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_109162 (h0 : topological_space (add_group (has_union (has_union linarith.comp)))) : discrete_topology (add_group (has_union (has_union linarith.comp))) := sorry --non-trivial
lemma new_lemma_109163 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_domain.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) ring.{0}) (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_109164 (h0 : functor.add_const (complete_lattice (is_R_or_C unsigned)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (is_R_or_C.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (is_R_or_C.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_109165 (h0 : has_mem.mem (with_bot num) has_emptyc.emptyc) : @add_monoid.fg.{0} (with_bot.{0} num) (@finset.pi.empty.{1 0} Type add_monoid.{0} (with_bot.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_109166 (h0 : topological_space (encodable (random_gen (random_gen string_imp)))) : path_connected_space (encodable (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_109167 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_mul.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_mul.{0} empty))  := sorry --non-trivial
lemma new_lemma_109168 (h0 : ring (monoid pos)) : is_domain (monoid pos) := sorry --non-trivial
lemma new_lemma_109169 (h1 : complete_lattice (non_unital_non_assoc_semiring to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (non_unital_non_assoc_semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_109170 (h0 : uniform_space (omega_complete_partial_order (option unsigned))) : separated_space (omega_complete_partial_order (option unsigned)) := sorry --non-trivial
lemma new_lemma_109171 (h0 : monoid (left_cancel_semigroup (semiring empty))) : monoid.fg (left_cancel_semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_109172 (h0 : function.extfun Type group) : @group.fg.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_109173 (h0 : uniform_space (linear_ordered_add_comm_group linarith.comp_source)) : complete_space (linear_ordered_add_comm_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_109174 (h2 : uniform_space (mul_one_class std_gen)) : complete_space (mul_one_class std_gen) := sorry --non-trivial
lemma new_lemma_109175 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_109176 (h0 : functor.add_const (function.extfun Type uniform_space) Type) : @complete_space.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) Type h0) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_109177 (h2 : set (enat -> add_comm_semigroup linarith.ineq)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_109178 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @topological_space.separable_space.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_109179 (h0 : topological_space (has_nndist (has_to_string unsigned))) : irreducible_space (has_nndist (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_109180 (h0 : uniform_space (random_gen num)) : separated_space (random_gen num) := sorry --non-trivial
lemma new_lemma_109181 (h0 : function.extfun nat fin) : @is_cyclic.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (group.{1} (has_bot.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_109182 (h0 : uniform_space (mul_zero_class (semiring empty))) : separated_space (mul_zero_class (semiring empty)) := sorry --non-trivial
lemma new_lemma_109183 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_109184 (h0 : topological_space (metric_space (has_norm (has_top (has_norm (has_norm empty)))))) : preirreducible_space (metric_space (has_norm (has_top (has_norm (has_norm empty))))) := sorry --non-trivial
lemma new_lemma_109185 (h0 : fin has_zero.zero) : @t1_space.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_109186 (h1 : not (ring (add_monoid to_additive.value_type) -> false)) : @is_domain.{0} (add_monoid.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (add_monoid.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_109187 (h0 : functor.add_const (ordered_add_comm_monoid (pseudo_metric_space empty)) empty) : @archimedean.{0} (pseudo_metric_space.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (pseudo_metric_space.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_109188 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (preorder.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_109189 (h0 : add_group (random_gen (has_norm linarith.comp))) : is_add_cyclic (random_gen (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_109190 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring ennreal)) Type) : @loc_path_connected_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (canonically_ordered_comm_semiring.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_109191 (h0 : finset (order_dual congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_109192 (h0 : uniform_space (with_bot empty)) : separated_space (with_bot empty) := sorry --non-trivial
lemma new_lemma_109193 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (is_R_or_C.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (is_R_or_C.{0} empty))  := sorry --non-trivial
lemma new_lemma_109194 (h0 : topological_space (has_add string_imp)) : totally_disconnected_space (has_add string_imp) := sorry --non-trivial
lemma new_lemma_109195 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) (finset Type)) : @regular_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} linarith.comp)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_109196 (h0 : add_monoid (has_union (semiring (semiring congr_arg_kind)))) : add_monoid.fg (has_union (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_109197 (h0 : topological_space (semigroup num)) : locally_compact_space (semigroup num) := sorry --non-trivial
lemma new_lemma_109198 (h0 : not (has_mem.mem (with_bot empty) has_emptyc.emptyc -> false)) : @monoid.fg.{0} (with_bot.{0} empty) (@finset.pi.empty.{1 0} Type monoid.{0} (with_bot.{0} empty) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} empty) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_109199 (h0 : functor.add_const (function.extfun (Type 1) filter) name) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (ordered_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_109200 (h0 : group (simple_graph pos)) : is_cyclic (simple_graph pos) := sorry --non-trivial
lemma new_lemma_109201 (h0 : not (has_mem.mem (semiring linarith.comp_source) has_emptyc.emptyc -> false)) : @totally_disconnected_space.{0} (semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_109202 (h0 : not (ring (linear_ordered_semiring to_additive.value_type) -> false)) : @strong_rank_condition.{0} (linear_ordered_semiring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_semiring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_109203 (h0 : cancel_comm_monoid_with_zero (add_right_cancel_monoid congr_arg_kind)) : unique_factorization_monoid (add_right_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_109204 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_109205 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @t1_space.{0} (has_pos_part.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_109206 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (free_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (free_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_109207 (h0 : complete_lattice (ordered_comm_ring (comm_semigroup Type))) : is_atomistic (ordered_comm_ring (comm_semigroup Type)) := sorry --non-trivial
lemma new_lemma_109208 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_109209 (h0 : ring (canonically_ordered_comm_semiring (option unsigned))) : is_domain (canonically_ordered_comm_semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_109210 (h0 : filter (option (cancel_monoid pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_109211 (h0 : functor.add_const (uniform_space (cancel_monoid environment.implicit_infer_kind)) name) : @complete_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_109212 (h0 : list (boolean_algebra (add_comm_monoid pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_109213 (h0 : uniform_space (normed_field (random_gen (mul_one_class char)))) : complete_space (normed_field (random_gen (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_109214 (h0 : functor.add_const (finset (cancel_monoid environment.implicit_infer_kind)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_109215 (h0 : topological_space (denumerable (has_nnnorm (mul_one_class reducibility_hints)))) : t0_space (denumerable (has_nnnorm (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_109216 (h0 : add_monoid (has_neg_part (finset name))) : add_monoid.fg (has_neg_part (finset name)) := sorry --non-trivial
lemma new_lemma_109217 (h0 : topological_space (has_neg_part (mul_zero_class name))) : locally_compact_space (has_neg_part (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_109218 (h0 : group (has_pos_part (ring pos))) : is_cyclic (has_pos_part (ring pos)) := sorry --non-trivial
lemma new_lemma_109219 (h0 : group (has_norm linarith.ineq)) : normalizer_condition (has_norm linarith.ineq) := sorry --non-trivial
lemma new_lemma_109220 (h0 : functor.add_const (list (normed_comm_ring linarith.comp)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_109221 (h0 : not (list (semi_normed_comm_ring linarith.comp_source) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_109222 (h0 : semiring (has_pos_part (cancel_monoid (linear_ordered_field ennreal)))) : is_noetherian_ring (has_pos_part (cancel_monoid (linear_ordered_field ennreal))) := sorry --non-trivial
lemma new_lemma_109223 (h0 : not (group (complete_semilattice_Sup char) -> false)) : @is_cyclic.{0} (complete_semilattice_Sup.{0} char) (@classical.by_contradiction'.{1} (group.{0} (complete_semilattice_Sup.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_109224 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @irreducible_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_109225 (h0 : topological_space (semiring empty)) : t0_space (semiring empty) := sorry --non-trivial
lemma new_lemma_109226 (h0 : list (has_pos_part real)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_109227 (h0 : functor.add_const (ordered_comm_monoid (has_to_string Type)) linarith.comp) : @has_exists_mul_of_le.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (has_to_string.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_109228 (h0 : group (has_inv (has_inv (has_inv linarith.comp_source)))) : normalizer_condition (has_inv (has_inv (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_109229 (h0 : functor.add_const (ordered_add_comm_monoid (semigroup name)) (has_add environment.implicit_infer_kind)) : @archimedean.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (semigroup.{0} name)) (has_add.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_109230 (h0 : ordered_add_comm_monoid (ordered_ring (semiring empty))) : archimedean (ordered_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_109231 (h0 : topological_space (nondiscrete_normed_field enat)) (h6 : Prop) : is_path_connected (id (fun (h1 : nondiscrete_normed_field enat), h6)) := sorry --non-trivial
lemma new_lemma_109232 (h0 : functor.add_const (filter environment.implicit_infer_kind) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_109233 (h0 : prod (has_nndist pos) (has_nndist pos)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_109234 (h0 : ring (has_compl reducibility_hints)) : rank_condition (has_compl reducibility_hints) := sorry --non-trivial
lemma new_lemma_109235 (h0 : ring (generalized_boolean_algebra (has_to_string Type))) : is_domain (generalized_boolean_algebra (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_109236 (h0 : add_monoid (boolean_algebra.core (normed_comm_ring (option name)))) : add_monoid.fg (boolean_algebra.core (normed_comm_ring (option name))) := sorry --non-trivial
lemma new_lemma_109237 (h0 : group (add_cancel_comm_monoid (mul_one_class char))) : is_cyclic (add_cancel_comm_monoid (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_109238 (h0 : topological_space (ring (has_add name))) : locally_compact_space (ring (has_add name)) := sorry --non-trivial
lemma new_lemma_109239 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_109240 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_inter ennreal)) := sorry --non-trivial
lemma new_lemma_109241 (h0 : not (complete_lattice (id linarith.ineq) -> false)) : @is_compactly_generated.{0} (@id.{2} Type linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (@id.{2} Type linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_109242 (h0 : group (add_cancel_monoid (option (option name)))) : group.fg (add_cancel_monoid (option (option name))) := sorry --non-trivial
lemma new_lemma_109243 (h0 : group (has_zero (ring Type))) : group.fg (has_zero (ring Type)) := sorry --non-trivial
lemma new_lemma_109244 (h0 : topological_space (has_one (semiring unsigned))) : preirreducible_space (has_one (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_109245 (h0 : ring (has_append (canonically_ordered_monoid to_additive.value_type))) : rank_condition (has_append (canonically_ordered_monoid to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_109246 (h0 : filter (has_top to_additive.value_type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_109247 (h0 : ordered_add_comm_monoid (complete_distrib_lattice (comm_semigroup real))) : archimedean (complete_distrib_lattice (comm_semigroup real)) := sorry --non-trivial
lemma new_lemma_109248 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (simple_graph.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} name))  := sorry --non-trivial
lemma new_lemma_109249 (h0 : function.extfun Type list -> Prop) (h1 : Exists (fun (x : function.extfun Type list), h0 x)) : list.nodup (function.extfun_app (classical.some h1) (option empty)) := sorry --non-trivial
lemma new_lemma_109250 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_109251 (h0 h1 : multiset (has_ssubset (mul_one_class char))) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_109252 (h0 : ring (generalized_boolean_algebra (has_Inf linarith.comp))) : strong_rank_condition (generalized_boolean_algebra (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_109253 (h0 : not (complete_lattice (has_div enat) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_div.{0} enat) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_div.{0} enat)) h0)  := sorry --non-trivial
lemma new_lemma_109254 (h0 : add_group (boolean_algebra.core Type)) : is_add_cyclic (boolean_algebra.core Type) := sorry --non-trivial
lemma new_lemma_109255 (h0 : function.extfun (finset Type) (has_mem.mem (id linarith.comp))) : @preirreducible_space.{0} (@id.{2} Type linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (@id.{2} Type linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_109256 (h0 : monoid (boolean_algebra (add_cancel_monoid pos))) : monoid.fg (boolean_algebra (add_cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_109257 (h0 : functor.add_const (finset (plift congr_arg_kind)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_109258 (h0 : filter (pseudo_metric_space (option pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_109259 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (partial_order.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_109260 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_109261 (h0 : uniform_space (finset (has_pos_part Type))) : complete_space (finset (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_109262 (h0 : ring (add_comm_semigroup ereal)) : is_domain (add_comm_semigroup ereal) := sorry --non-trivial
lemma new_lemma_109263 (h0 : ring (canonically_ordered_comm_semiring (has_to_string name))) : is_principal_ideal_ring (canonically_ordered_comm_semiring (has_to_string name)) := sorry --non-trivial
lemma new_lemma_109264 (h0 : topological_space (boolean_algebra (normed_comm_ring Type))) : totally_disconnected_space (boolean_algebra (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_109265 (h0 : topological_space (has_ssubset (random_gen (random_gen (has_top linarith.ineq))))) : locally_compact_space (has_ssubset (random_gen (random_gen (has_top linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_109266 (h0 : topological_space (cancel_monoid Type)) : sequential_space (cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_109267 (h0 : topological_space (has_to_string (option empty))) : totally_disconnected_space (has_to_string (option empty)) := sorry --non-trivial
lemma new_lemma_109268 (h0 : topological_space (add_right_cancel_monoid (has_top congr_arg_kind))) : t0_space (add_right_cancel_monoid (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_109269 (h0 : functor.add_const (topological_space (has_pos_part name)) (has_add (has_Inf Type))) : @preirreducible_space.{0} (has_pos_part.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_pos_part.{0} name)) (has_add.{1} (has_Inf.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_109270 (h0 : function.extfun nat fin) : @is_add_cyclic.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (add_group.{1} (ordered_comm_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_109271 (h0 : functor.add_const (topological_space bool) empty) : loc_path_connected_space bool := sorry --non-trivial
lemma new_lemma_109272 (h0 : monoid (has_neg (has_neg_part (finset pos)))) : monoid.fg (has_neg (has_neg_part (finset pos))) := sorry --non-trivial
lemma new_lemma_109273 (h0 : ring (has_emptyc (has_emptyc linarith.comp_source))) : is_domain (has_emptyc (has_emptyc linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_109274 (h1 : filter (encodable (random_gen to_additive.value_type))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_109275 (h0 : topological_space (semigroup environment.implicit_infer_kind)) : discrete_topology (semigroup environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_109276 (h0 : topological_space (ring Type)) : t0_space (ring Type) := sorry --non-trivial
lemma new_lemma_109277 (h0 : topological_space (has_neg_part (finset pos))) : topological_space.separable_space (has_neg_part (finset pos)) := sorry --non-trivial
lemma new_lemma_109278 (h0 : functor.add_const (monoid (boolean_algebra Type)) (add_comm_monoid (has_add pos))) : @monoid.fg.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (boolean_algebra.{1} Type)) (add_comm_monoid.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_109279 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_bot.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_109280 (h0 : has_lt (non_unital_non_assoc_semiring linarith.ineq)) : no_max_order (non_unital_non_assoc_semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_109281 (h0 : functor.add_const Prop (boolean_algebra (has_add (finset Type)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_109282 (h0 : prod (has_add pos) (has_add pos)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_109283 (h0 : functor.add_const (ordered_add_comm_monoid (simple_graph Type)) pos) : @archimedean.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (simple_graph.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_109284 (h0 : topological_space (cancel_monoid (comm_group name))) : preconnected_space (cancel_monoid (comm_group name)) := sorry --non-trivial
lemma new_lemma_109285 (h0 : group (encodable (has_nnnorm (has_nnnorm char)))) : is_cyclic (encodable (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_109286 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_109287 (h0 : uniform_space (has_pos_part (has_pos_part Type))) : complete_space (has_pos_part (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_109288 (h2 : topological_space (distrib (has_nnnorm (has_nnnorm (has_nnnorm char))))) : t0_space (distrib (has_nnnorm (has_nnnorm (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_109289 (h0 : ring (has_div (mul_one_class enat))) : rank_condition (has_div (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_109290 (h0 : not (topological_space (fintype string_imp) -> false)) : @t0_space.{0} (fintype.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (fintype.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_109291 (h0 : ring (generalized_boolean_algebra (sub_neg_monoid real))) : rank_condition (generalized_boolean_algebra (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_109292 (h0 : topological_space (has_neg (boolean_algebra.core (ring (has_neg pos))))) : irreducible_space (has_neg (boolean_algebra.core (ring (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_109293 (h0 : topological_space (has_to_string (has_add (has_add (has_add unsigned))))) : normal_space (has_to_string (has_add (has_add (has_add unsigned)))) := sorry --non-trivial
lemma new_lemma_109294 (h0 : not (topological_space (with_bot (has_top linarith.ineq)) -> false)) : @irreducible_space.{0} (with_bot.{0} (has_top.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} (has_top.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_109295 (h0 : topological_space (normed_comm_ring (ring (finset (finset (ring linarith.comp)))))) : t1_space (normed_comm_ring (ring (finset (finset (ring linarith.comp))))) := sorry --non-trivial
lemma new_lemma_109296 (h0 : add_monoid (add_cancel_monoid (finset (has_pos_part Type)))) : add_monoid.fg (add_cancel_monoid (finset (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_109297 (h0 : functor.add_const (topological_space (add_left_cancel_semigroup unsigned)) empty) : @totally_separated_space.{0} (add_left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_109298 (h0 : topological_space (measurable_space (has_norm (has_norm linarith.ineq)))) : totally_separated_space (measurable_space (has_norm (has_norm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_109299 (h1 : filter (fintype (has_nnnorm fun_info))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_109300 (h0 : uniform_space (random_gen linarith.comp)) : complete_space (random_gen linarith.comp) := sorry --non-trivial
lemma new_lemma_109301 (h0 : topological_space (has_Inf (has_add pos))) : loc_path_connected_space (has_Inf (has_add pos)) := sorry --non-trivial
lemma new_lemma_109302 (h0 : list (has_add (normed_comm_ring (has_neg linarith.comp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_109303 (h0 : functor.add_const (monoid (boolean_algebra.core linarith.comp)) name) : @monoid.fg.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (boolean_algebra.core.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_109304 (h0 : ordered_add_comm_monoid (has_nndist (option ennreal))) : archimedean (has_nndist (option ennreal)) := sorry --non-trivial
lemma new_lemma_109305 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (complete_semilattice_Sup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_109306 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_109307 (h0 : uniform_space (add_cancel_monoid (semiring (semiring unsigned)))) : separated_space (add_cancel_monoid (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_109308 (h0 : topological_space (normed_comm_ring (option (option (option (option (option ennreal))))))) : path_connected_space (normed_comm_ring (option (option (option (option (option ennreal)))))) := sorry --non-trivial
lemma new_lemma_109309 (h0 : measurable_space (mul_one_class (mul_one_class enat))) (h1 : measure_theory.measure (mul_one_class (mul_one_class enat))) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_109310 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) pos) : @regular_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_109311 (h0 : functor.add_const (group (has_Inf linarith.comp)) Type) : @group.fg.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (has_Inf.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_109312 (h0 : function.extfun (finset ((Type -> Type) -> Type 1)) (has_mem.mem (function.extfun Type))) : @strong_rank_condition.{0} empty (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) (@function.extfun_app.{3 0} (finset.{2} ((Type → Type) → Type 1)) (@has_mem.mem.{2 2} ((Type → Type) → Type 1) (finset.{2} ((Type → Type) → Type 1)) (@finset.has_mem.{2} ((Type → Type) → Type 1)) (function.extfun.{2 1} Type)) h0 (@has_emptyc.emptyc.{2} (finset.{2} ((Type → Type) → Type 1)) (@finset.has_emptyc.{2} ((Type → Type) → Type 1))))) ring.{0}) empty)  := sorry --non-trivial
lemma new_lemma_109313 (h0 : not (complete_lattice (encodable fun_info) -> false)) : @is_compactly_generated.{0} (encodable.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (encodable.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_109314 (h0 : topological_space (linear_order (option (canonically_ordered_add_monoid unsigned)))) : t1_space (linear_order (option (canonically_ordered_add_monoid unsigned))) := sorry --non-trivial
lemma new_lemma_109315 (h0 : topological_space (cancel_monoid linarith.comp)) : irreducible_space (cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_109316 (h0 : with_bot (list Prop)) (h1 : ne h0 has_bot.bot) : list.head (with_bot.unbot h0 h1) := sorry --non-trivial
lemma new_lemma_109317 (h0 : filter (semigroup (ring Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_109318 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_add pos)) := sorry --non-trivial
lemma new_lemma_109319 (h0 : ring (comm_ring (comm_ring (comm_ring reducibility_hints)))) : is_domain (comm_ring (comm_ring (comm_ring reducibility_hints))) := sorry --non-trivial
lemma new_lemma_109320 (h0 : topological_space (add_group linarith.comp)) : totally_disconnected_space (add_group linarith.comp) := sorry --non-trivial
lemma new_lemma_109321 (h0 : ring (comm_group (comm_group pos))) : is_domain (comm_group (comm_group pos)) := sorry --non-trivial
lemma new_lemma_109322 (h0 : topological_space (boolean_algebra (has_add (ring linarith.comp)))) : totally_separated_space (boolean_algebra (has_add (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_109323 (h0 h1 : multiset (has_le string.iterator_imp)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_109324 (h0 : ordered_add_comm_monoid (boolean_algebra (comm_group pos))) : archimedean (boolean_algebra (comm_group pos)) := sorry --non-trivial
lemma new_lemma_109325 (h2 : topological_space (comm_ring to_additive.value_type)) : t0_space (comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_109326 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (has_union.{0} stieltjes_function) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_union.{0} stieltjes_function))  := sorry --non-trivial
lemma new_lemma_109327 (h0 : ring (canonically_ordered_comm_semiring (finset (finset Type)))) : is_principal_ideal_ring (canonically_ordered_comm_semiring (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_109328 (h0 : topological_space (semigroup unsigned)) : discrete_topology (semigroup unsigned) := sorry --non-trivial
lemma new_lemma_109329 (h0 : prod (linear_ordered_field congr_arg_kind) (linear_ordered_field congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_109330 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_109331 (h0 : ring (ring (boolean_algebra Type))) : is_principal_ideal_ring (ring (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_109332 (h0 : function.extfun nat fin) : @locally_compact_space.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_109333 (h0 : complete_lattice (add_group (has_norm num))) : complete_lattice.is_Sup_finite_compact (add_group (has_norm num)) := sorry --non-trivial
lemma new_lemma_109334 (h0 : group (dlist (random_gen to_additive.value_type))) : group.fg (dlist (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_109335 (h0 : functor.comp topological_space comm_group pos) : @topological_space.separable_space.{0} (comm_group.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_109336 (h0 : topological_space (normed_group fun_info)) : locally_compact_space (normed_group fun_info) := sorry --non-trivial
lemma new_lemma_109337 (h0 : topological_space (add_left_cancel_monoid to_additive.value_type)) : totally_disconnected_space (add_left_cancel_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_109338 (h0 : group (has_zero unsigned)) : normalizer_condition (has_zero unsigned) := sorry --non-trivial
lemma new_lemma_109339 (h0 : finset (boolean_algebra.core (has_neg (add_cancel_monoid Type)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_109340 (h0 : has_lt (has_div reducibility_hints)) : no_max_order (has_div reducibility_hints) := sorry --non-trivial
lemma new_lemma_109341 (h0 : list (ring num)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_109342 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_109343 (h0 : monoid (id (has_top (has_top unsigned)))) : monoid.fg (id (has_top (has_top unsigned))) := sorry --non-trivial
lemma new_lemma_109344 (h0 : add_group (add_comm_semigroup (add_right_cancel_monoid char))) : is_add_cyclic (add_comm_semigroup (add_right_cancel_monoid char)) := sorry --non-trivial
lemma new_lemma_109345 (h0 : not (ring (measure_theory.measure_space unsigned) -> false)) : @rank_condition.{0} (measure_theory.measure_space.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (measure_theory.measure_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_109346 (h0 : not (uniform_space (simple_graph char) -> false)) : @complete_space.{0} (simple_graph.{0} char) (@classical.by_contradiction'.{1} (uniform_space.{0} (simple_graph.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_109347 (h0 : fin has_zero.zero) : @path_connected_space.{0} (generalized_boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_109348 (h0 : ring (mul_zero_class (semigroup environment.implicit_infer_kind))) : rank_condition (mul_zero_class (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_109349 (h0 : ring (has_inv (has_norm (comm_ring (random_gen fun_info))))) : is_domain (has_inv (has_norm (comm_ring (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_109350 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_109351 (h0 : topological_space (semigroup (semiring (semiring (semiring num))))) : t1_space (semigroup (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_109352 (h0 : group (encodable (random_gen (random_gen (random_gen (random_gen linarith.ineq)))))) : is_cyclic (encodable (random_gen (random_gen (random_gen (random_gen linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_109353 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_dist.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_dist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_109354 (h0 : has_mem.mem real.angle has_emptyc.emptyc) : @is_atomistic.{0} real.angle (@finset.pi.empty.{1 0} Type complete_lattice.{0} real.angle h0)  := sorry --non-trivial
lemma new_lemma_109355 (h0 : monoid (group_with_zero (option unsigned))) : monoid.fg (group_with_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_109356 (h0 : topological_space (has_neg_part (option (ring ennreal)))) : totally_disconnected_space (has_neg_part (option (ring ennreal))) := sorry --non-trivial
lemma new_lemma_109357 (h0 : list (boolean_algebra (has_zero (has_zero (has_zero Type))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_109358 (h0 : group (has_nnnorm (random_gen (random_gen (random_gen linarith.comp_source))))) : group.fg (has_nnnorm (random_gen (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_109359 (h0 : topological_space (mul_zero_class (has_add name))) : totally_disconnected_space (mul_zero_class (has_add name)) := sorry --non-trivial
lemma new_lemma_109360 (h0 : functor.add_const (complete_lattice (ordered_comm_ring real)) real) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_comm_ring.{0} real) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_comm_ring.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_109361 (h0 : group (normed_group (semiring unsigned))) : group.fg (normed_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_109362 (h0 : ring (dlist (has_ssubset (random_gen fun_info)))) : is_domain (dlist (has_ssubset (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_109363 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_109364 (h0 : ring (has_ssubset (has_ssubset linarith.comp_source))) : rank_condition (has_ssubset (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_109365 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_109366 (h0 : ring (pseudo_metric_space (option empty))) : strong_rank_condition (pseudo_metric_space (option empty)) := sorry --non-trivial
lemma new_lemma_109367 (h0 : finset (has_zero (finset Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_109368 (h1 : not (filter (add_left_cancel_monoid string_imp) -> false)) : filter.ne_bot (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_109369 (h0 : group (has_neg (has_nndist Type))) : is_simple_group (has_neg (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_109370 (h0 : topological_space (option num)) : normal_space (option num) := sorry --non-trivial
lemma new_lemma_109371 (h0 : add_group (semiring (random_gen num))) : is_add_cyclic (semiring (random_gen num)) := sorry --non-trivial
lemma new_lemma_109372 (h0 : complete_lattice (mul_one_class (mul_one_class string_imp))) : is_compactly_generated (mul_one_class (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_109373 (h0 : topological_space (has_bot (option (option (option unsigned))))) : totally_separated_space (has_bot (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_109374 (h0 : function.extfun Type ring) : @is_domain.{0} (simple_graph.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (simple_graph.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_109375 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_sub.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_sub.{0} num))  := sorry --non-trivial
lemma new_lemma_109376 (h0 : group (has_to_string (option ennreal))) : is_cyclic (has_to_string (option ennreal)) := sorry --non-trivial
lemma new_lemma_109377 (h0 : topological_space (has_to_string (option (option (option ennreal))))) : locally_compact_space (has_to_string (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_109378 (h0 : group (has_neg_part (has_add ennreal))) : group.fg (has_neg_part (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_109379 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_edist.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_edist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_109380 (h0 : functor.comp ordered_comm_monoid complete_distrib_lattice name) : @has_exists_mul_of_le.{0} (complete_distrib_lattice.{0} name) (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} complete_distrib_lattice.{0} name h0)  := sorry --non-trivial
lemma new_lemma_109381 (h0 : ring (semi_normed_ring (random_gen (has_nnnorm fun_info)))) : strong_rank_condition (semi_normed_ring (random_gen (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_109382 (h0 : ordered_comm_monoid (has_neg (option unsigned))) : has_exists_mul_of_le (has_neg (option unsigned)) := sorry --non-trivial
lemma new_lemma_109383 (h0 : topological_space (has_add (has_neg (finset Type)))) : regular_space (has_add (has_neg (finset Type))) := sorry --non-trivial
lemma new_lemma_109384 (h0 : cancel_comm_monoid_with_zero (comm_group (semigroup environment.implicit_infer_kind))) : unique_factorization_monoid (comm_group (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_109385 (h0 : functor.add_const (group (left_cancel_monoid congr_arg_kind)) unsigned) : @is_cyclic.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (left_cancel_monoid.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_109386 (h0 : topological_space (dlist fun_info)) : totally_disconnected_space (dlist fun_info) := sorry --non-trivial
lemma new_lemma_109387 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_sub.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_sub.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_109388 (h1 : function.extfun Type topological_space) : totally_separated_space empty := sorry --non-trivial
lemma new_lemma_109389 (h0 : complete_lattice (has_emptyc (semiring (has_norm num)))) : is_compactly_generated (has_emptyc (semiring (has_norm num))) := sorry --non-trivial
lemma new_lemma_109390 (h0 : group (distrib (has_nnnorm linarith.ineq))) : is_cyclic (distrib (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_109391 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @topological_space.separable_space.{0} pos (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) pos)  := sorry --non-trivial
lemma new_lemma_109392 (h0 : topological_space (add_cancel_monoid (finset linarith.comp))) : preirreducible_space (add_cancel_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_109393 (h0 : topological_space (generalized_boolean_algebra Type)) : regular_space (generalized_boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_109394 (h1 : topological_space (complete_semilattice_Sup string_imp)) : totally_disconnected_space (complete_semilattice_Sup string_imp) := sorry --non-trivial
lemma new_lemma_109395 (h0 : monoid (has_union unsigned)) : monoid.fg (has_union unsigned) := sorry --non-trivial
lemma new_lemma_109396 (h0 : finset (complete_distrib_lattice unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_109397 (h0 : functor.add_const (topological_space (has_bot linarith.comp)) linarith.comp) : @totally_separated_space.{0} (has_bot.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_109398 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (bin_tree.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (bin_tree.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_109399 (h0 : topological_space (canonically_ordered_monoid (ordered_comm_ring real))) : sequential_space (canonically_ordered_monoid (ordered_comm_ring real)) := sorry --non-trivial
lemma new_lemma_109400 (h0 : add_zero_class (simple_graph char)) (h1 : ring (add_submonoid (simple_graph char))) : strong_rank_condition (add_submonoid (simple_graph char)) := sorry --non-trivial
lemma new_lemma_109401 (h0 : topological_space (has_dist (option (option empty)))) : path_connected_space (has_dist (option (option empty))) := sorry --non-trivial
lemma new_lemma_109402 (h0 : function.extfun (Type 1) monoid) : @monoid.fg.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} h0 (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_109403 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_109404 (h0 : function.extfun Type ring) : @rank_condition.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_109405 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_109406 (h0 : has_to_string (group_with_zero ennreal) -> has_to_string (group_with_zero ennreal) -> Prop) : is_symm (has_to_string (group_with_zero ennreal)) h0 := sorry --non-trivial
lemma new_lemma_109407 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_109408 (h0 : ring (finset (has_to_string (has_to_string (has_to_string pos))))) : rank_condition (finset (has_to_string (has_to_string (has_to_string pos)))) := sorry --non-trivial
lemma new_lemma_109409 (h0 : function.extfun (Type 1) ring) : @strong_rank_condition.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_109410 (h0 : topological_space (has_Sup empty)) : normal_space (has_Sup empty) := sorry --non-trivial
lemma new_lemma_109411 (h0 : function.extfun Type ring) : @is_domain.{0} (distrib_lattice.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (distrib_lattice.{0} real))  := sorry --non-trivial
lemma new_lemma_109412 (h0 : ordered_comm_monoid (normed_comm_ring (comm_group pos))) : has_exists_mul_of_le (normed_comm_ring (comm_group pos)) := sorry --non-trivial
lemma new_lemma_109413 (h0 : ring (mul_zero_class num)) : is_principal_ideal_ring (mul_zero_class num) := sorry --non-trivial
lemma new_lemma_109414 (h0 : list (cancel_monoid (normed_comm_ring (has_add pos)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_109415 (h0 : function.extfun Type group) : @is_simple_group.{0} (boolean_algebra.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (boolean_algebra.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_109416 (h0 : functor.add_const (topological_space (measure_theory.measure_space unsigned)) name) : @sequential_space.{0} (measure_theory.measure_space.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (measure_theory.measure_space.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_109417 (h0 : function.extfun (finset Type) (has_mem.mem (complete_semilattice_Sup congr_arg_kind))) : @is_cyclic.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type group.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_109418 (h0 : topological_space (complete_linear_order (semiring (semiring congr_arg_kind)))) : path_connected_space (complete_linear_order (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_109419 (h0 : function.extfun nat fin) : @is_domain.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (has_bot.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_109420 (h0 : set (has_ssubset std_gen)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_109421 (h0 : topological_space (has_bot (has_pos_part pos))) : preconnected_space (has_bot (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_109422 (h0 : ordered_comm_monoid (has_neg (ring (ring name)))) : has_exists_mul_of_le (has_neg (ring (ring name))) := sorry --non-trivial
lemma new_lemma_109423 (h0 : topological_space (normed_lattice_add_comm_group real)) : t0_space (normed_lattice_add_comm_group real) := sorry --non-trivial
lemma new_lemma_109424 (h0 : function.extfun Type topological_space) : @regular_space.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_109425 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @is_cyclic.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_109426 (h0 : functor.comp topological_space has_neg_part (boolean_algebra.core ennreal)) : @regular_space.{0} (has_neg_part.{0} (boolean_algebra.core.{0} ennreal)) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} (boolean_algebra.core.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_109427 (h0 : topological_space (cancel_monoid (has_add (has_add environment.implicit_infer_kind)))) : preconnected_space (cancel_monoid (has_add (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_109428 (h0 : not (ring (uniform_space reducibility_hints) -> false)) : @rank_condition.{0} (uniform_space.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (uniform_space.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_109429 (h0 : functor.add_const (list (has_Inf pos)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_109430 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_109431 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (partial_order.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_109432 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_109433 (h0 : complete_lattice (plift (semiring (semiring (semiring unsigned))))) : complete_lattice.is_Sup_finite_compact (plift (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_109434 (h0 : functor.add_const (complete_lattice (boolean_algebra.core Type)) Type) : @is_compactly_generated.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (boolean_algebra.core.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_109435 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_109436 (h0 : topological_space (has_zero (comm_group Type))) : totally_disconnected_space (has_zero (comm_group Type)) := sorry --non-trivial
lemma new_lemma_109437 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_109438 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) (has_add Type)) : @has_exists_mul_of_le.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) (has_add.{1} Type) h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_109439 (h0 : topological_space (normed_comm_ring (cancel_monoid Type))) : normal_space (normed_comm_ring (cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_109440 (h0 : topological_space (linear_ordered_comm_ring (has_top (semiring unsigned)))) : preirreducible_space (linear_ordered_comm_ring (has_top (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_109441 (h0 : group (random_gen (has_top string_imp))) : group.fg (random_gen (has_top string_imp)) := sorry --non-trivial
lemma new_lemma_109442 (h0 : monoid (id (random_gen (random_gen (random_gen linarith.comp_source))))) : monoid.fg (id (random_gen (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_109443 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : palindrome (function.extfun_app (function.extfun_app h0 list) (has_add Type)) := sorry --non-trivial
lemma new_lemma_109444 (h0 : complete_lattice (normed_comm_ring ennreal)) : is_atomistic (normed_comm_ring ennreal) := sorry --non-trivial
lemma new_lemma_109445 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) linarith.comp) : @topological_space.separable_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_109446 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_109447 (h0 : filter (has_neg (finset (finset pos)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_109448 (h0 : ring (distrib (comm_ring string_imp))) : is_domain (distrib (comm_ring string_imp)) := sorry --non-trivial
lemma new_lemma_109449 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_109450 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_109451 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (has_union linarith.comp)) := sorry --non-trivial
lemma new_lemma_109452 (h0 : topological_space (has_neg (has_pos_part pos))) : locally_compact_space (has_neg (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_109453 (h0 : function.extfun Type group) : @is_cyclic.{0} (with_bot.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h0 (with_bot.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_109454 (h0 : functor.add_const (complete_lattice (boolean_algebra.core pos)) pos) : @is_compactly_generated.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_109455 (h0 : functor.add_const (add_group (plift num)) congr_arg_kind) : @is_add_cyclic.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (add_group.{1} (plift.{1} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_109456 (h2 : topological_space (linear_ordered_add_comm_group to_additive.value_type)) : path_connected_space (linear_ordered_add_comm_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_109457 (h1 : topological_space (has_one empty)) : path_connected_space (has_one empty) := sorry --non-trivial
lemma new_lemma_109458 (h0 : functor.add_const (topological_space (has_Inf Type)) Type) : @irreducible_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_Inf.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_109459 (h1 : complete_lattice (non_unital_non_assoc_semiring linarith.comp_source)) : is_compactly_generated (non_unital_non_assoc_semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_109460 (h0 : uniform_space (ordered_comm_ring real)) : complete_space (ordered_comm_ring real) := sorry --non-trivial
lemma new_lemma_109461 (h0 : topological_space (semigroup (has_neg_part (has_neg_part environment.implicit_infer_kind)))) : totally_disconnected_space (semigroup (has_neg_part (has_neg_part environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_109462 (h0 : ring (canonically_ordered_add_monoid (option (option empty)))) : is_domain (canonically_ordered_add_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_109463 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (monoid_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (monoid_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_109464 (h0 : functor.add_const (group (normed_comm_ring pos)) unsigned) : @normalizer_condition.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_109465 (h0 : semiring (has_Inf (has_Inf Type))) : is_noetherian_ring (has_Inf (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_109466 (h0 : functor.add_const (semiring (bin_tree num)) congr_arg_kind) : @is_noetherian_ring.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (semiring.{0} (bin_tree.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_109467 (h0 : function.extfun Type topological_space) : @t0_space.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_109468 (h0 : group (has_inv (random_gen to_additive.value_type))) : is_cyclic (has_inv (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_109469 (h0 : cancel_comm_monoid_with_zero (simple_graph string_imp)) : unique_factorization_monoid (simple_graph string_imp) := sorry --non-trivial
lemma new_lemma_109470 (h0 : functor.add_const (filter (has_neg_part unsigned)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_109471 (h0 : linear_ordered_field (linear_ordered_field pos) -> linear_ordered_field (linear_ordered_field pos) -> Prop) : is_symm (linear_ordered_field (linear_ordered_field pos)) h0 := sorry --non-trivial
lemma new_lemma_109472 (h0 : group (ordered_comm_ring (generalized_boolean_algebra (ring linarith.comp)))) : is_simple_group (ordered_comm_ring (generalized_boolean_algebra (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_109473 (h0 : functor.add_const (topological_space (free_add_monoid unsigned)) congr_arg_kind) : @locally_compact_space.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_109474 (h0 : topological_space (canonically_ordered_comm_semiring (has_nndist Type))) : path_connected_space (canonically_ordered_comm_semiring (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_109475 (h0 : semiring (has_pos_part name)) : is_noetherian_ring (has_pos_part name) := sorry --non-trivial
lemma new_lemma_109476 (h0 : ordered_comm_monoid (has_add (sub_neg_monoid real))) : has_exists_mul_of_le (has_add (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_109477 (h0 : topological_space (add_comm_monoid (option (option empty)))) : discrete_topology (add_comm_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_109478 (h0 : functor.add_const (topological_space (has_add linarith.comp)) (ordered_ring (ring (has_neg name)))) : @sequential_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) (ordered_ring.{0} (ring.{0} (has_neg.{0} name))) h0)  := sorry --non-trivial
lemma new_lemma_109479 (h2 : topological_space (normed_group (random_gen char))) : t0_space (normed_group (random_gen char)) := sorry --non-trivial
lemma new_lemma_109480 (h0 : topological_space (with_bot (has_norm fun_info))) : irreducible_space (with_bot (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_109481 (h0 : function.extfun Type complete_lattice) : is_atomistic (measurable_space fun_info) := sorry --non-trivial
lemma new_lemma_109482 (h0 : group (dlist linarith.comp_source)) : group.fg (dlist linarith.comp_source) := sorry --non-trivial
lemma new_lemma_109483 (h0 : not (topological_space (with_bot empty) -> false)) : @irreducible_space.{0} (with_bot.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_109484 (h0 : not (topological_space (id empty) -> false)) : @normal_space.{0} (@id.{2} Type empty) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type empty)) h0)  := sorry --non-trivial
lemma new_lemma_109485 (h0 : add_monoid (canonically_linear_ordered_monoid unsigned)) : add_monoid.fg (canonically_linear_ordered_monoid unsigned) := sorry --non-trivial
lemma new_lemma_109486 (h0 : functor.add_const (topological_space (has_to_string unsigned)) environment.implicit_infer_kind) : @regular_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_109487 (h0 : add_monoid (monoid_with_zero unsigned)) : add_monoid.fg (monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_109488 (h0 : group (has_nndist (add_comm_monoid pos))) : is_cyclic (has_nndist (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_109489 (h0 : topological_space (has_pos_part Type)) : locally_compact_space (has_pos_part Type) := sorry --non-trivial
lemma new_lemma_109490 (h0 : function.extfun nat fin) : @path_connected_space.{0} (simple_graph.{0} (has_add.{0} linarith.comp)) (@matrix.vec_empty.{0} (topological_space.{0} (simple_graph.{0} (has_add.{0} linarith.comp))) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_109491 (h0 : functor.add_const (group (has_nndist Type)) ennreal) : @group.fg.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_nndist.{1} Type)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_109492 (h0 : functor.add_const (ring (has_to_string pos)) (has_nndist name)) : @is_domain.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} pos)) (has_nndist.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_109493 (h0 : functor.add_const (ring (add_cancel_monoid Type)) environment.implicit_infer_kind) : @rank_condition.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (add_cancel_monoid.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_109494 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (add_right_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_right_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_109495 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @preirreducible_space.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_109496 (h0 : cancel_comm_monoid_with_zero (normed_comm_ring empty)) : unique_factorization_monoid (normed_comm_ring empty) := sorry --non-trivial
lemma new_lemma_109497 (h0 : semiring (has_star (semiring (semiring (semiring (semiring (semiring unsigned))))))) : is_noetherian_ring (has_star (semiring (semiring (semiring (semiring (semiring unsigned)))))) := sorry --non-trivial
lemma new_lemma_109498 (h0 : topological_space (has_add (ring (ring (ordered_ring Type))))) : sequential_space (has_add (ring (ring (ordered_ring Type)))) := sorry --non-trivial
lemma new_lemma_109499 (h0 : group (has_ssubset (linear_ordered_add_comm_group fun_info))) : group.fg (has_ssubset (linear_ordered_add_comm_group fun_info)) := sorry --non-trivial
lemma new_lemma_109500 (h0 : topological_space (add_left_cancel_monoid (has_inv (random_gen (random_gen fun_info))))) : t0_space (add_left_cancel_monoid (has_inv (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_109501 (h0 : functor.add_const (group (linear_ordered_cancel_comm_monoid empty)) empty) : @group.fg.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (linear_ordered_cancel_comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_109502 (h0 : add_monoid (pseudo_metric_space name)) : add_monoid.fg (pseudo_metric_space name) := sorry --non-trivial
lemma new_lemma_109503 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_109504 (h0 : topological_space (canonically_ordered_monoid (has_neg (has_neg name)))) : irreducible_space (canonically_ordered_monoid (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_109505 (h0 : group (has_norm (has_top (has_top fun_info)))) : normalizer_condition (has_norm (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_109506 (h0 : topological_space (semiring (has_top linarith.comp))) : normal_space (semiring (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_109507 (h0 : add_group (add_comm_monoid (has_Inf real))) : is_add_cyclic (add_comm_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_109508 (h0 : functor.add_const (uniform_space (ring linarith.comp)) environment.implicit_infer_kind) : @complete_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (ring.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_109509 (h0 : topological_space (has_inv to_additive.value_type)) : totally_separated_space (has_inv to_additive.value_type) := sorry --non-trivial
lemma new_lemma_109510 (h0 : uniform_space (with_one (random_gen (random_gen (has_nnnorm (has_nnnorm string_imp)))))) : complete_space (with_one (random_gen (random_gen (has_nnnorm (has_nnnorm string_imp))))) := sorry --non-trivial
lemma new_lemma_109511 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (finset name)) := sorry --non-trivial
lemma new_lemma_109512 (h0 : semiring (add_group (semiring empty))) : is_noetherian_ring (add_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_109513 (h0 : topological_space (topological_space (random_gen string_imp))) : path_connected_space (topological_space (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_109514 (h2 : topological_space (add_comm_semigroup ereal)) : t0_space (add_comm_semigroup ereal) := sorry --non-trivial
lemma new_lemma_109515 (h0 : add_group (has_zero pos)) : is_add_cyclic (has_zero pos) := sorry --non-trivial
lemma new_lemma_109516 (h0 : add_monoid (linear_ordered_comm_ring congr_arg_kind)) : add_monoid.fg (linear_ordered_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_109517 (h0 : topological_space (complete_distrib_lattice (normed_comm_ring name))) : regular_space (complete_distrib_lattice (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_109518 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (complete_distrib_lattice.{0} linarith.comp) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (complete_distrib_lattice.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_109519 (h0 : filter (ring (has_neg name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_109520 (h0 : add_group (bin_tree (option (option (add_cancel_monoid (option (option empty))))))) : is_add_cyclic (bin_tree (option (option (add_cancel_monoid (option (option empty)))))) := sorry --non-trivial
lemma new_lemma_109521 (h0 : add_group (encodable (random_gen (has_nnnorm fun_info)))) : is_add_cyclic (encodable (random_gen (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_109522 (h0 : functor.add_const (ring (complete_distrib_lattice unsigned)) empty) : @rank_condition.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_109523 (h1 : ring (uniform_space (metric_space to_additive.value_type))) : strong_rank_condition (uniform_space (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_109524 (h0 : semiring (has_pos_part (has_add pos))) : is_noetherian_ring (has_pos_part (has_add pos)) := sorry --non-trivial
lemma new_lemma_109525 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @irreducible_space.{0} (canonically_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_109526 (h0 : ring (has_neg (ring Type))) : rank_condition (has_neg (ring Type)) := sorry --non-trivial
lemma new_lemma_109527 (h0 : function.extfun nat fin) : @path_connected_space.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_109528 (h0 : add_group (has_emptyc fun_info)) : is_add_cyclic (has_emptyc fun_info) := sorry --non-trivial
lemma new_lemma_109529 (h0 : ordered_add_comm_monoid (free_add_monoid (option (option unsigned)))) : archimedean (free_add_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_109530 (h0 : has_mem.mem (has_compl environment.projection_info) has_zero.zero) : @t0_space.{0} (has_compl.{0} environment.projection_info) (@multiset.pi.empty.{1 0} Type topological_space.{0} (has_compl.{0} environment.projection_info) h0)  := sorry --non-trivial
lemma new_lemma_109531 (h0 : add_monoid (linear_ordered_comm_ring (semiring congr_arg_kind))) : add_monoid.fg (linear_ordered_comm_ring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_109532 (h0 : not (uniform_space (non_unital_non_assoc_semiring linarith.ineq) -> false)) : @complete_space.{0} (non_unital_non_assoc_semiring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (uniform_space.{0} (non_unital_non_assoc_semiring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_109533 (h0 : monoid (cancel_monoid (finset (has_add (normed_comm_ring name))))) : monoid.fg (cancel_monoid (finset (has_add (normed_comm_ring name)))) := sorry --non-trivial
lemma new_lemma_109534 (h0 : monoid (linear_ordered_semiring (random_gen (random_gen (random_gen (random_gen num)))))) : monoid.fg (linear_ordered_semiring (random_gen (random_gen (random_gen (random_gen num))))) := sorry --non-trivial
lemma new_lemma_109535 (h0 : topological_space (complete_distrib_lattice (semiring empty))) : loc_path_connected_space (complete_distrib_lattice (semiring empty)) := sorry --non-trivial
lemma new_lemma_109536 (h0 : functor.add_const (ordered_add_comm_monoid (has_Inf pos)) name) : @archimedean.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_Inf.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_109537 (h0 : function.extfun Type ring) : @is_domain.{0} (free_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (free_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_109538 (h1 : topological_space (has_ssubset ereal)) (h2 : add_group (has_ssubset ereal)) : topological_add_group (has_ssubset ereal) := sorry --non-trivial
lemma new_lemma_109539 (h0 : topological_space (ordered_comm_monoid (has_add (has_Inf (ordered_comm_ring linarith.comp))))) : path_connected_space (ordered_comm_monoid (has_add (has_Inf (ordered_comm_ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_109540 (h0 : filter (monoid unsigned)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_109541 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (option.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_109542 (h0 : functor.add_const (complete_lattice (partial_order empty)) empty) : @is_compactly_generated.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (partial_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_109543 (h0 : functor.add_const (ordered_add_comm_monoid (canonically_ordered_monoid name)) Type) : @archimedean.{0} (canonically_ordered_monoid.{0} name) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (canonically_ordered_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_109544 (h0 : ring (group_with_zero empty)) : is_principal_ideal_ring (group_with_zero empty) := sorry --non-trivial
lemma new_lemma_109545 (h0 : uniform_space (ring name)) : separated_space (ring name) := sorry --non-trivial
lemma new_lemma_109546 (h0 : has_mem.mem (random_gen (has_top linarith.comp_source)) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} (has_top.{0} linarith.comp_source)) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (random_gen.{0} (has_top.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_109547 (h0 h1 : multiset (add_comm_semigroup (mul_one_class enat))) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_109548 (h0 : add_monoid (add_cancel_comm_monoid congr_arg_kind)) : add_monoid.fg (add_cancel_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_109549 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_109550 (h0 : complete_lattice (has_inter congr_arg_kind)) : is_atomistic (has_inter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_109551 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_109552 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (linear_ordered_add_comm_group.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_add_comm_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_109553 (h0 : topological_space (normed_lattice_add_comm_group (comm_semigroup pos))) : totally_disconnected_space (normed_lattice_add_comm_group (comm_semigroup pos)) := sorry --non-trivial
lemma new_lemma_109554 (h0 : ring (has_nndist (boolean_algebra.core pos))) : is_principal_ideal_ring (has_nndist (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_109555 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_109556 (h0 : functor.add_const (function.extfun (Type 1) list) environment.implicit_infer_kind) : palindrome (function.extfun_app (functor.add_const.run h0) (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_109557 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_cyclic.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_109558 (h0 : functor.add_const (topological_space (has_to_string ennreal)) num) : @irreducible_space.{0} (has_to_string.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_109559 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_109560 (h0 : ring (has_one (semiring (semiring unsigned)))) : strong_rank_condition (has_one (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_109561 (h0 : functor.add_const (cancel_comm_monoid_with_zero (preorder empty)) unsigned) : @unique_factorization_monoid.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (preorder.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_109562 (h1 : add_group (div_inv_monoid (has_nnnorm (has_nnnorm char)))) : is_add_cyclic (div_inv_monoid (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_109563 (h0 : functor.comp finset has_zero ennreal) : finset.nonempty (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_109564 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_109565 (h0 : functor.add_const (topological_space (has_neg_part ennreal)) name) : @sequential_space.{0} (has_neg_part.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_109566 (h1 : not (ring (has_norm linarith.comp_source) -> false)) : @strong_rank_condition.{0} (has_norm.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (has_norm.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_109567 (h0 : functor.comp complete_lattice complete_semilattice_Sup linarith.comp_source) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@functor.comp.run.{0 0 0} complete_lattice.{0} complete_semilattice_Sup.{0} linarith.comp_source h0)  := sorry --non-trivial
lemma new_lemma_109568 (h0 : ring (canonically_ordered_monoid (has_Inf (has_Inf (has_Inf real))))) : is_domain (canonically_ordered_monoid (has_Inf (has_Inf (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_109569 (h0 : topological_space (ordered_ring num)) : path_connected_space (ordered_ring num) := sorry --non-trivial
lemma new_lemma_109570 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (add_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (add_group.{0} num))  := sorry --non-trivial
lemma new_lemma_109571 (h0 : complete_lattice (has_top (has_inv to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (has_top (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_109572 (h1 : ring (distrib (has_nnnorm linarith.comp_source))) : is_domain (distrib (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_109573 (h0 : topological_space (add_semigroup unsigned)) : t1_space (add_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_109574 (h0 : ring (comm_semigroup real)) : rank_condition (comm_semigroup real) := sorry --non-trivial
lemma new_lemma_109575 (h0 : monoid (complete_distrib_lattice (option (option ennreal)))) : monoid.fg (complete_distrib_lattice (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_109576 (h0 : not (add_group (normed_field (mul_one_class (has_ssubset string_imp))) -> false)) : @is_add_cyclic.{0} (normed_field.{0} (mul_one_class.{0} (has_ssubset.{0} string_imp))) (@classical.by_contradiction'.{1} (add_group.{0} (normed_field.{0} (mul_one_class.{0} (has_ssubset.{0} string_imp)))) h0)  := sorry --non-trivial
lemma new_lemma_109577 (h0 : complete_lattice (semi_normed_comm_ring to_additive.value_type)) : is_compactly_generated (semi_normed_comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_109578 (h0 : add_group (id (random_gen (random_gen (random_gen to_additive.value_type))))) : is_add_cyclic (id (random_gen (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_109579 (h0 : functor.comp cancel_comm_monoid_with_zero cancel_monoid Type) : @unique_factorization_monoid.{1} (cancel_monoid.{1} Type) (@functor.comp.run.{1 1 1} cancel_comm_monoid_with_zero.{1} cancel_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_109580 (h0 : topological_space (complete_semilattice_Sup unsigned)) : normal_space (complete_semilattice_Sup unsigned) := sorry --non-trivial
lemma new_lemma_109581 (h0 : ring (has_nnnorm (random_gen (random_gen (random_gen (random_gen char)))))) : rank_condition (has_nnnorm (random_gen (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_109582 (h0 : functor.add_const (topological_space (ring name)) Type) : @path_connected_space.{0} (ring.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_109583 (h0 : topological_space (comm_group (option (option unsigned)))) : sequential_space (comm_group (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_109584 (h0 : topological_space (has_to_string (comm_group (comm_group name)))) : discrete_topology (has_to_string (comm_group (comm_group name))) := sorry --non-trivial
lemma new_lemma_109585 (h0 : topological_space (plift (option congr_arg_kind))) : path_connected_space (plift (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_109586 (h0 : topological_space (normed_comm_ring (option (option (option (option ennreal)))))) : topological_space.separable_space (normed_comm_ring (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_109587 (h0 : nat) (h1 : fin (nat.succ h0) -> fin has_zero.zero) (h2 : fin h0) : id (matrix.vec_empty (matrix.vec_empty (matrix.vec_empty (matrix.vec_tail h1 (id h2))))) := sorry --non-trivial
lemma new_lemma_109588 (h0 : group (has_Inf real)) : is_cyclic (has_Inf real) := sorry --non-trivial
lemma new_lemma_109589 (h0 : ring (has_ssubset enat)) : strong_rank_condition (has_ssubset enat) := sorry --non-trivial
lemma new_lemma_109590 (h0 : functor.add_const (group (finset pos)) Type) : @is_cyclic.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (finset.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_109591 (h0 : monoid (has_nndist (finset name))) : monoid.fg (has_nndist (finset name)) := sorry --non-trivial
lemma new_lemma_109592 (h0 : topological_space (mul_one_class string.iterator_imp)) : path_connected_space (mul_one_class string.iterator_imp) := sorry --non-trivial
lemma new_lemma_109593 (h0 : topological_space (pseudo_metric_space (option pos))) : preirreducible_space (pseudo_metric_space (option pos)) := sorry --non-trivial
lemma new_lemma_109594 (h0 : functor.add_const (function.extfun Type uniform_space) (finset (has_neg linarith.comp))) : @complete_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) (finset.{0} (has_neg.{0} linarith.comp)) h0) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_109595 (h0 : ring (measurable_space unsigned)) : strong_rank_condition (measurable_space unsigned) := sorry --non-trivial
lemma new_lemma_109596 (h0 : cancel_comm_monoid_with_zero (filter empty)) : unique_factorization_monoid (filter empty) := sorry --non-trivial
lemma new_lemma_109597 (h0 : not (ring (has_top linarith.ineq) -> false)) : @rank_condition.{0} (has_top.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (has_top.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_109598 (h0 : cancel_comm_monoid_with_zero (has_nndist (ordered_ring pos))) : unique_factorization_monoid (has_nndist (ordered_ring pos)) := sorry --non-trivial
lemma new_lemma_109599 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_109600 (h0 : add_group (finset name)) : is_add_cyclic (finset name) := sorry --non-trivial
lemma new_lemma_109601 (h0 : monoid (has_top (has_norm fun_info))) : monoid.fg (has_top (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_109602 (h0 : topological_space (dlist (has_inv to_additive.value_type))) : totally_separated_space (dlist (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_109603 (h0 : topological_space (has_nndist (has_nndist pos))) : totally_disconnected_space (has_nndist (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_109604 (h0 : add_monoid (linear_ordered_comm_group ennreal)) : add_monoid.fg (linear_ordered_comm_group ennreal) := sorry --non-trivial
lemma new_lemma_109605 (h0 : ordered_comm_monoid (has_zero (add_cancel_monoid (comm_group name)))) : has_exists_mul_of_le (has_zero (add_cancel_monoid (comm_group name))) := sorry --non-trivial
lemma new_lemma_109606 (h0 : add_group (ordered_comm_ring (has_add real))) : is_add_cyclic (ordered_comm_ring (has_add real)) := sorry --non-trivial
lemma new_lemma_109607 (h0 : has_mem.mem (semiring linarith.comp_source) has_emptyc.emptyc) : @rank_condition.{0} (semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_109608 (h0 : ereal -> ereal -> Prop) : is_antisymm ereal h0 := sorry --non-trivial
lemma new_lemma_109609 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_109610 (h0 : function.extfun Type (functor.add_const (complete_lattice (option empty)))) : @complete_lattice.is_Sup_finite_compact.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (option.{0} empty)) (semiring.{0} empty) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (option.{0} empty))) h0 (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_109611 (h0 : has_mem.mem uniform_space has_emptyc.emptyc) : @complete_space.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} h0) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_109612 (h0 : functor.add_const (topological_space (generalized_boolean_algebra Type)) pos) : @discrete_topology.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_109613 (h0 : functor.add_const (group (has_zero name)) pos) : @is_simple_group.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_109614 (h0 : ring (ring (comm_group (ring (cancel_monoid name))))) : is_principal_ideal_ring (ring (comm_group (ring (cancel_monoid name)))) := sorry --non-trivial
lemma new_lemma_109615 (h0 : topological_space (has_compl string.iterator_imp)) : totally_disconnected_space (has_compl string.iterator_imp) := sorry --non-trivial
lemma new_lemma_109616 (h0 : function.extfun Type (functor.add_const (topological_space Type))) : @regular_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) environment.implicit_infer_kind (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (topological_space.{1} Type)) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_109617 (h0 : topological_space (ordered_comm_monoid (finset (has_Inf linarith.comp)))) : sequential_space (ordered_comm_monoid (finset (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_109618 (h0 : filter (has_nndist (finset (finset environment.implicit_infer_kind)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_109619 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (option.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (option.{0} name))  := sorry --non-trivial
lemma new_lemma_109620 (h0 : functor.add_const (topological_space (has_zero name)) pos) : @loc_path_connected_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_109621 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_109622 (h0 : functor.add_const (list (add_cancel_monoid pos)) (normed_comm_ring Type)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_109623 (h0 : topological_space (add_group (linear_ordered_semiring empty))) : irreducible_space (add_group (linear_ordered_semiring empty)) := sorry --non-trivial
lemma new_lemma_109624 (h0 : function.extfun Type (functor.comp topological_space has_to_string)) : @preirreducible_space.{0} (has_to_string.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_to_string.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_109625 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_109626 (h0 : not (has_mem.mem linarith.comp_source has_emptyc.emptyc -> false)) : @totally_disconnected_space.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type topological_space.{0} linarith.comp_source (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp_source (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_109627 (h0 : uniform_space (add_cancel_monoid empty)) : complete_space (add_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_109628 (h0 : functor.add_const (complete_lattice (has_nndist environment.implicit_infer_kind)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_109629 (h0 : complete_lattice (id (has_norm linarith.comp))) : is_atomistic (id (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_109630 (h0 : has_lt (has_lt (normed_field (normed_field environment.projection_info)))) : no_max_order (has_lt (normed_field (normed_field environment.projection_info))) := sorry --non-trivial
lemma new_lemma_109631 (h0 : uniform_space (normed_field (mul_one_class (metric_space (metric_space to_additive.value_type))))) : complete_space (normed_field (mul_one_class (metric_space (metric_space to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_109632 (h0 : topological_space (boolean_algebra.core (comm_group (has_add Type)))) : preconnected_space (boolean_algebra.core (comm_group (has_add Type))) := sorry --non-trivial
lemma new_lemma_109633 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_109634 (h0 : functor.add_const (ring (has_zero linarith.comp)) pos) : @is_domain.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_109635 (h0 : functor.add_const (topological_space environment.implicit_infer_kind) Type) : @topological_space.separable_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 1} (topological_space.{0} environment.implicit_infer_kind) Type h0)  := sorry --non-trivial
lemma new_lemma_109636 (h0 : functor.add_const (function.extfun Type monoid) linarith.comp) : @monoid.fg.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) linarith.comp h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_109637 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (simple_graph.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (simple_graph.{0} empty))  := sorry --non-trivial
lemma new_lemma_109638 (h0 : has_mem.mem (normed_group fun_info) has_emptyc.emptyc) : @complete_space.{0} (normed_group.{0} fun_info) (@finset.pi.empty.{1 0} Type uniform_space.{0} (normed_group.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_109639 (h0 : functor.add_const (complete_lattice Type) (has_zero pos)) : @is_compactly_generated.{1} Type (@functor.add_const.run.{1 0} (complete_lattice.{1} Type) (has_zero.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_109640 (h0 : add_monoid (has_pos_part (has_Inf (boolean_algebra.core pos)))) : add_monoid.fg (has_pos_part (has_Inf (boolean_algebra.core pos))) := sorry --non-trivial
lemma new_lemma_109641 (h0 : uniform_space (boolean_algebra (boolean_algebra (has_pos_part (has_pos_part pos))))) : complete_space (boolean_algebra (boolean_algebra (has_pos_part (has_pos_part pos)))) := sorry --non-trivial
lemma new_lemma_109642 (h0 : linear_ordered_comm_ring empty -> linear_ordered_comm_ring empty -> Prop) : is_strict_order (linear_ordered_comm_ring empty) h0 := sorry --non-trivial
lemma new_lemma_109643 (h0 : list (denumerable (random_gen string_imp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_109644 (h0 : functor.add_const (topological_space (has_nndist name)) environment.implicit_infer_kind) : @t0_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_109645 (h0 : functor.add_const (topological_space (has_nndist Type)) environment.implicit_infer_kind) : @discrete_topology.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_109646 (h0 : group (with_one linarith.comp_source)) : group.fg (with_one linarith.comp_source) := sorry --non-trivial
lemma new_lemma_109647 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_109648 (h0 : topological_space (sub_neg_monoid (sub_neg_monoid real))) : locally_compact_space (sub_neg_monoid (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_109649 (h0 : complete_lattice (bin_tree (mul_one_class reducibility_hints))) : complete_lattice.is_Sup_finite_compact (bin_tree (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_109650 (h0 : ordered_comm_monoid (add_comm_monoid (finset Type))) : has_exists_mul_of_le (add_comm_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_109651 (h0 : functor.add_const (ring (filter unsigned)) unsigned) : @rank_condition.{0} (filter.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (filter.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_109652 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_separated_space.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_109653 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_disconnected_space.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_109654 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @discrete_topology.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_109655 (h0 : topological_space (left_cancel_semigroup num)) : t0_space (left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_109656 (h0 : functor.add_const (complete_lattice (has_add pos)) (ring Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_add.{0} pos)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_109657 (h0 : functor.add_const (function.extfun Type group) Type) : @is_simple_group.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_109658 (h0 : function.extfun (finset Type) (has_mem.mem (complete_semilattice_Sup num))) : @is_domain.{0} (complete_semilattice_Sup.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_109659 (h0 : (group reducibility_hints -> false) -> false) (h1 : group reducibility_hints -> false) (h2 : false) : @is_cyclic.{0} reducibility_hints (@classical.by_contradiction'.{1} (group.{0} reducibility_hints) (@function.update.{0 0} (group.{0} reducibility_hints → false) (λ (a : group.{0} reducibility_hints → false), false) (λ (a b : group.{0} reducibility_hints → false), @decidable_eq_of_subsingleton.{0} (group.{0} reducibility_hints → false) (@pi.subsingleton.{1 0} (group.{0} reducibility_hints) (λ (ᾰ : group.{0} reducibility_hints), false) (λ (a : group.{0} reducibility_hints), subsingleton_prop false)) a b) h0 h1 h2))  := sorry --trivial
lemma new_lemma_109660 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_disconnected_space.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_109661 (h0 : complete_lattice (add_monoid linarith.ineq)) : complete_lattice.is_Sup_finite_compact (add_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_109662 (h0 : monoid (semigroup (semigroup Type))) : monoid.fg (semigroup (semigroup Type)) := sorry --non-trivial
lemma new_lemma_109663 (h0 : ring (normed_field (has_lt linarith.comp_source))) : is_domain (normed_field (has_lt linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_109664 (h0 : ordered_comm_monoid (has_Inf (has_add (has_to_string linarith.comp)))) : has_exists_mul_of_le (has_Inf (has_add (has_to_string linarith.comp))) := sorry --non-trivial
lemma new_lemma_109665 (h0 : functor.add_const (filter (ring linarith.comp)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_109666 (h0 : ordered_add_comm_monoid (as_linear_order (option unsigned))) : archimedean (as_linear_order (option unsigned)) := sorry --non-trivial
lemma new_lemma_109667 (h0 : functor.add_const (topological_space (has_Sup empty)) (semiring empty)) : @discrete_topology.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_109668 (h0 : ordered_add_comm_monoid (filter empty)) : archimedean (filter empty) := sorry --non-trivial
lemma new_lemma_109669 (h0 : not (uniform_space (linear_ordered_semiring congr_arg_kind) -> false)) : @separated_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (linear_ordered_semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_109670 (h0 : topological_space (generalized_boolean_algebra (sub_neg_monoid real))) : regular_space (generalized_boolean_algebra (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_109671 (h0 : complete_lattice (semiring (random_gen (has_top to_additive.value_type)))) : is_compactly_generated (semiring (random_gen (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_109672 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_109673 (h0 : topological_space (monoid_with_zero congr_arg_kind)) : t0_space (monoid_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_109674 (h0 : not (complete_lattice (semi_normed_ring linarith.comp_source) -> false)) : @is_compactly_generated.{0} (semi_normed_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semi_normed_ring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_109675 (h0 : prod (linear_ordered_comm_group (option ennreal)) (linear_ordered_comm_group (option ennreal))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_109676 (h0 : group (has_zero (add_comm_monoid Type))) : normalizer_condition (has_zero (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_109677 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (encodable fun_info)) := sorry --non-trivial
lemma new_lemma_109678 (h0 : functor.add_const (ordered_add_comm_monoid (has_Inf linarith.comp)) linarith.comp) : @archimedean.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_Inf.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_109679 (h0 : functor.add_const (group (has_Inf linarith.comp)) name) : @is_simple_group.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_Inf.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_109680 (h0 : add_group (linear_ordered_comm_group_with_zero std_gen)) : is_add_cyclic (linear_ordered_comm_group_with_zero std_gen) := sorry --non-trivial
lemma new_lemma_109681 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (normed_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_109682 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_109683 (h0 : uniform_space (has_zero (has_add (has_to_string (has_add (finset linarith.comp)))))) : separated_space (has_zero (has_add (has_to_string (has_add (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_109684 (h0 : function.extfun Type group) : @normalizer_condition.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_comm_ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_109685 (h0 : ring (measurable_space (has_top fun_info))) : rank_condition (measurable_space (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_109686 (h0 : group (canonically_ordered_monoid (comm_semigroup (sub_neg_monoid pos)))) : is_simple_group (canonically_ordered_monoid (comm_semigroup (sub_neg_monoid pos))) := sorry --non-trivial
lemma new_lemma_109687 (h0 : topological_space (comm_group (option (finset ennreal)))) : irreducible_space (comm_group (option (finset ennreal))) := sorry --non-trivial
lemma new_lemma_109688 (h0 : function.extfun nat fin) : @loc_path_connected_space.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (boolean_algebra.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_109689 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_109690 (h0 : semiring (has_nndist (has_well_founded (finset (finset (has_nndist pos)))))) : is_noetherian_ring (has_nndist (has_well_founded (finset (finset (has_nndist pos))))) := sorry --non-trivial
lemma new_lemma_109691 (h0 : complete_lattice (normed_group (has_top linarith.ineq))) : is_compactly_generated (normed_group (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_109692 (h0 : not (uniform_space (add_monoid linarith.ineq) -> false)) : @complete_space.{0} (add_monoid.{0} linarith.ineq) (@classical.by_contradiction'.{1} (uniform_space.{0} (add_monoid.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_109693 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (linear_order.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_109694 (h0 : list (canonically_ordered_monoid (has_Inf Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_109695 (h0 : topological_space (add_cancel_monoid (has_zero (has_neg pos)))) : totally_separated_space (add_cancel_monoid (has_zero (has_neg pos))) := sorry --non-trivial
lemma new_lemma_109696 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_109697 (h0 : group (linear_ordered_add_comm_group (has_inv linarith.comp_source))) : is_cyclic (linear_ordered_add_comm_group (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_109698 (h0 : uniform_space (ordered_cancel_add_comm_monoid num)) : complete_space (ordered_cancel_add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_109699 (h0 : function.extfun Type group) : @is_cyclic.{0} (group_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (group_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_109700 (h0 : topological_space (with_one (has_norm empty))) : path_connected_space (with_one (has_norm empty)) := sorry --non-trivial
lemma new_lemma_109701 (h0 : group (has_bot num)) : group.fg (has_bot num) := sorry --non-trivial
lemma new_lemma_109702 (h0 : functor.add_const (function.extfun Type topological_space) (finset (has_add (finset ennreal)))) : @locally_compact_space.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (finset.{0} (has_add.{0} (finset.{0} ennreal))) h0) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_109703 (h0 : has_lt (has_div fun_info)) : no_max_order (has_div fun_info) := sorry --non-trivial
lemma new_lemma_109704 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) name) : @normal_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_109705 (h0 : add_group (group_with_zero (option ennreal))) : is_add_cyclic (group_with_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_109706 (h0 : has_top (has_top (semiring congr_arg_kind)) -> has_top (has_top (semiring congr_arg_kind)) -> Prop) : is_strict_order (has_top (has_top (semiring congr_arg_kind))) h0 := sorry --non-trivial
lemma new_lemma_109707 (h0 : ring (has_one (has_zero empty))) : rank_condition (has_one (has_zero empty)) := sorry --non-trivial
lemma new_lemma_109708 (h0 : topological_space (measurable_space linarith.ineq)) : path_connected_space (measurable_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_109709 (h0 : fin has_zero.zero) : @is_cyclic.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (group.{1} (sub_neg_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_109710 (h0 : filter (group_with_zero (option (option unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_109711 (h0 : functor.add_const (group (add_cancel_monoid Type)) Type) : @is_cyclic.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (add_cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_109712 (h0 : group (simple_graph (has_add Type))) : is_cyclic (simple_graph (has_add Type)) := sorry --non-trivial
lemma new_lemma_109713 (h0 : list (monoid unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_109714 (h0 : topological_space (finset name)) : discrete_topology (finset name) := sorry --non-trivial
lemma new_lemma_109715 (h0 : ring (simple_graph (add_cancel_comm_monoid linarith.ineq))) : strong_rank_condition (simple_graph (add_cancel_comm_monoid linarith.ineq)) := sorry --non-trivial
lemma new_lemma_109716 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_109717 (h0 : topological_space (add_comm_semigroup char)) : path_connected_space (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_109718 (h0 : ring (has_zero (has_add (has_add (has_add pos))))) : is_domain (has_zero (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_109719 (h0 : topological_space (has_add (add_cancel_monoid (add_cancel_monoid unsigned)))) : regular_space (has_add (add_cancel_monoid (add_cancel_monoid unsigned))) := sorry --non-trivial
lemma new_lemma_109720 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_bot.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_bot.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_109721 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) Type) : @t1_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_109722 (h0 : topological_space (has_sub unsigned)) : path_connected_space (has_sub unsigned) := sorry --non-trivial
lemma new_lemma_109723 (h0 : functor.add_const (function.extfun Type topological_space) (has_add linarith.comp)) : @t0_space.{0} (has_add.{0} (ring.{0} linarith.comp)) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_add.{0} linarith.comp) h0) (has_add.{0} (ring.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_109724 (h0 : functor.add_const (topological_space (has_pos_part Type)) real) : @normal_space.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_pos_part.{1} Type)) real h0)  := sorry --non-trivial
lemma new_lemma_109725 (h0 : functor.add_const (topological_space (semigroup Type)) Type) : @preconnected_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (semigroup.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_109726 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_sub.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_sub.{0} empty))  := sorry --non-trivial
lemma new_lemma_109727 (h0 : prod (canonically_linear_ordered_monoid unsigned) (canonically_linear_ordered_monoid unsigned)) : set.diagonal (canonically_linear_ordered_monoid unsigned) h0 := sorry --non-trivial
lemma new_lemma_109728 (h0 : functor.add_const (ordered_add_comm_monoid (semigroup name)) (option name)) : @archimedean.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (semigroup.{0} name)) (option.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_109729 (h0 : function.extfun Type topological_space) : @t0_space.{0} (measure_theory.measure_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measure_theory.measure_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_109730 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc linarith.comp_source))) : @totally_disconnected_space.{0} (has_emptyc.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_109731 (h0 : uniform_space (has_add (finset Type))) : complete_space (has_add (finset Type)) := sorry --non-trivial
lemma new_lemma_109732 (h0 : topological_space (has_zero (has_to_string Type))) : t0_space (has_zero (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_109733 (h0 : ring (denumerable (has_ssubset linarith.comp_source))) : rank_condition (denumerable (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_109734 (h0 : functor.add_const (topological_space (normed_linear_ordered_group empty)) unsigned) (h1 : option (topological_space (normed_linear_ordered_group empty))) : @totally_disconnected_space.{0} (normed_linear_ordered_group.{0} empty) (@option.lhoare.{0} (topological_space.{0} (normed_linear_ordered_group.{0} empty)) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} empty)) unsigned h0) h1)  := sorry --non-trivial
lemma new_lemma_109735 (h0 : ordered_comm_monoid (comm_group (comm_group (has_to_string (comm_group Type))))) : has_exists_mul_of_le (comm_group (comm_group (has_to_string (comm_group Type)))) := sorry --non-trivial
lemma new_lemma_109736 (h0 : topological_space (has_nnnorm (random_gen (random_gen string_imp)))) : t0_space (has_nnnorm (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_109737 (h1 : group (encodable (random_gen string_imp))) : group.fg (encodable (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_109738 (h0 : list (semigroup (option ennreal))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_109739 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @normal_space.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_109740 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_109741 (h0 : functor.add_const (semiring (has_zero Type)) (finset name)) : @is_noetherian_ring.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (has_zero.{1} Type)) (finset.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_109742 (h0 : add_group (has_pos_part (has_Inf linarith.comp))) : is_add_cyclic (has_pos_part (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_109743 (h0 : functor.add_const (topological_space (finset Type)) linarith.comp) : @regular_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_109744 (h0 : topological_space (left_cancel_monoid (ordered_ring empty))) : discrete_topology (left_cancel_monoid (ordered_ring empty)) := sorry --non-trivial
lemma new_lemma_109745 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_add_cyclic.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 add_group.{1}) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_109746 (h0 : functor.add_const (filter (boolean_algebra unsigned)) environment.implicit_infer_kind) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_109747 (h0 : monoid (has_to_string (has_to_string environment.implicit_infer_kind))) : monoid.fg (has_to_string (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_109748 (h0 : topological_space (boolean_algebra (has_add (finset linarith.comp)))) : loc_path_connected_space (boolean_algebra (has_add (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_109749 (h0 : complete_lattice (has_sub (has_top (has_top empty)))) : is_compactly_generated (has_sub (has_top (has_top empty))) := sorry --non-trivial
lemma new_lemma_109750 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_109751 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (metric_space.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_109752 (h0 : functor.add_const (ring (has_zero unsigned)) environment.implicit_infer_kind) : @strong_rank_condition.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_109753 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (simple_graph.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (simple_graph.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_109754 (h0 : topological_space (uniform_space.core name)) : preconnected_space (uniform_space.core name) := sorry --non-trivial
lemma new_lemma_109755 (h0 : complete_lattice (distrib (has_nnnorm (has_nnnorm fun_info)))) : complete_lattice.is_Sup_finite_compact (distrib (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_109756 (h0 : uniform_space (simple_graph pos)) : separated_space (simple_graph pos) := sorry --non-trivial
lemma new_lemma_109757 (h1 : not (topological_space (add_left_cancel_monoid string_imp) -> false)) : @totally_disconnected_space.{0} (add_left_cancel_monoid.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (add_left_cancel_monoid.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_109758 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} h0 (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_109759 (h0 : function.extfun Type (functor.add_const (topological_space znum))) : @path_connected_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} znum)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_109760 (h1 : add_group (has_le string.iterator_imp)) : is_add_cyclic (has_le string.iterator_imp) := sorry --non-trivial
lemma new_lemma_109761 (h0 : not (list (semiring linarith.comp_source) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_109762 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_109763 (h0 : topological_space (has_neg empty)) : topological_space.separable_space (has_neg empty) := sorry --non-trivial
lemma new_lemma_109764 (h0 : group (has_zero (ring (ring (ring (finset linarith.comp)))))) : is_cyclic (has_zero (ring (ring (ring (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_109765 (h0 : ring (finset (normed_comm_ring environment.implicit_infer_kind))) : is_domain (finset (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_109766 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) Type) : @discrete_topology.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (boolean_algebra.core.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_109767 (h0 : functor.add_const (topological_space (ordered_comm_monoid linarith.comp)) Type) : @topological_space.separable_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_109768 (h2 : topological_space (has_nnnorm reducibility_hints)) : t0_space (has_nnnorm reducibility_hints) := sorry --non-trivial
lemma new_lemma_109769 (h0 : monoid (measurable_space.dynkin_system (option empty))) : monoid.fg (measurable_space.dynkin_system (option empty)) := sorry --non-trivial
lemma new_lemma_109770 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (partial_order congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_109771 (h0 : fin has_zero.zero) : @path_connected_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_109772 (h0 : not (topological_space (measurable_space (has_top linarith.comp_source)) -> false)) : @totally_separated_space.{0} (measurable_space.{0} (has_top.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} (has_top.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_109773 (h0 : topological_space (ordered_comm_monoid (has_neg (has_neg name)))) : preconnected_space (ordered_comm_monoid (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_109774 (h0 : functor.add_const (topological_space (mul_zero_class Type)) name) : @t1_space.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (mul_zero_class.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_109775 (h1 : ring (has_top (has_inv (random_gen (random_gen (random_gen (random_gen string_imp))))))) : rank_condition (has_top (has_inv (random_gen (random_gen (random_gen (random_gen string_imp)))))) := sorry --non-trivial
lemma new_lemma_109776 (h0 : has_mem.mem (has_emptyc (random_gen linarith.comp_source)) has_emptyc.emptyc) : @is_cyclic.{0} (has_emptyc.{0} (random_gen.{0} linarith.comp_source)) (@finset.pi.empty.{1 0} Type group.{0} (has_emptyc.{0} (random_gen.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_109777 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (normed_comm_ring.{0} (option.{0} (option.{0} ennreal))) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (normed_comm_ring.{0} (option.{0} (option.{0} ennreal))))  := sorry --non-trivial
lemma new_lemma_109778 (h0 : ring (add_cancel_monoid (has_add (has_add pos)))) : rank_condition (add_cancel_monoid (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_109779 (h0 : complete_lattice (finset (mul_zero_class Type))) : is_compactly_generated (finset (mul_zero_class Type)) := sorry --non-trivial
lemma new_lemma_109780 (h0 : not (uniform_space (add_group num) -> false)) : @separated_space.{0} (add_group.{0} num) (@classical.by_contradiction'.{1} (uniform_space.{0} (add_group.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_109781 (h0 : function.extfun linarith.comp_source (fun (x : linarith.comp_source), Prop)) : zzz_forall (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_109782 (h0 : filter (has_nndist (has_add (has_nndist name)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_109783 (h0 : ordered_add_comm_monoid (has_pos_part (has_add (ordered_comm_monoid Type)))) : archimedean (has_pos_part (has_add (ordered_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_109784 (h0 : ring (non_unital_non_assoc_semiring (mul_one_class (mul_one_class linarith.comp_source)))) : rank_condition (non_unital_non_assoc_semiring (mul_one_class (mul_one_class linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_109785 (h0 : functor.add_const (complete_lattice (omega_complete_partial_order unsigned)) unsigned) : @is_atomistic.{0} (omega_complete_partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (omega_complete_partial_order.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_109786 (h0 : fin has_zero.zero) : @preconnected_space.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_ring.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_109787 (h0 : topological_space (with_zero linarith.comp_source)) (h1 : not (preorder (with_zero linarith.comp_source) -> false)) : @order_topology.{0} (with_zero.{0} linarith.comp_source) h0 (@classical.by_contradiction'.{1} (preorder.{0} (with_zero.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_109788 (h0 : function.extfun Type ring) : @rank_condition.{0} (encodable.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} h0 (encodable.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_109789 (h0 : function.extfun Type group) : @is_cyclic.{0} (@id.{2} Type linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (@id.{2} Type linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_109790 (h0 : ring (with_bot (random_gen (random_gen fun_info)))) : strong_rank_condition (with_bot (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_109791 (h0 : function.extfun Type group) : @group.fg.{0} (pseudo_metric_space.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (pseudo_metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_109792 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_109793 (h0 : topological_space (has_zero unsigned)) : totally_separated_space (has_zero unsigned) := sorry --non-trivial
lemma new_lemma_109794 (h0 : topological_space (has_sub (semiring (semiring congr_arg_kind)))) : preirreducible_space (has_sub (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_109795 (h0 : group (has_to_string (has_neg (has_neg (has_neg name))))) : normalizer_condition (has_to_string (has_neg (has_neg (has_neg name)))) := sorry --non-trivial
lemma new_lemma_109796 (h0 : functor.add_const (topological_space (has_neg_part Type)) Type) : @normal_space.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_neg_part.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_109797 (h0 : topological_space (cancel_monoid (option (option empty)))) : path_connected_space (cancel_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_109798 (h0 : functor.add_const (ring (boolean_algebra linarith.comp)) (ring linarith.comp)) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} linarith.comp)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_109799 (h0 : functor.add_const (topological_space (finset pos)) Type) : @t1_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_109800 (h0 : semiring (with_bot (semiring num))) : is_noetherian_ring (with_bot (semiring num)) := sorry --non-trivial
lemma new_lemma_109801 (h0 : function.extfun Type (functor.add_const (list Prop))) : list.head (functor.add_const.run (function.extfun_app h0 environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_109802 (h2 : topological_space (mul_one_class char)) : path_connected_space (mul_one_class char) := sorry --non-trivial
lemma new_lemma_109803 (h0 : not (topological_space (measure_theory.measure_space congr_arg_kind) -> false)) : @preirreducible_space.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (measure_theory.measure_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_109804 (h0 : topological_space (semigroup (finset environment.implicit_infer_kind))) : discrete_topology (semigroup (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_109805 (h0 : has_lt (nondiscrete_normed_field (mul_one_class environment.projection_info))) : no_max_order (nondiscrete_normed_field (mul_one_class environment.projection_info)) := sorry --non-trivial
lemma new_lemma_109806 (h0 : topological_space (ordered_comm_group empty)) : irreducible_space (ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_109807 (h0 : topological_space (has_neg (finset (finset (has_add (finset (has_to_string name))))))) : normal_space (has_neg (finset (finset (has_add (finset (has_to_string name)))))) := sorry --non-trivial
lemma new_lemma_109808 (h0 : uniform_space (normed_group (semiring real.angle))) : complete_space (normed_group (semiring real.angle)) := sorry --non-trivial
lemma new_lemma_109809 (h0 : topological_space (has_div (mul_one_class (mul_one_class to_additive.value_type)))) (h1 : preorder (has_div (mul_one_class (mul_one_class to_additive.value_type)))) : order_topology (has_div (mul_one_class (mul_one_class to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_109810 (h0 : functor.add_const (topological_space (cancel_monoid unsigned)) empty) : @discrete_topology.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_109811 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (@id.{2} Type linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (@id.{2} Type linarith.ineq))  := sorry --non-trivial
lemma new_lemma_109812 (h0 : topological_space (measurable_space.dynkin_system (semilattice_inf unsigned))) : path_connected_space (measurable_space.dynkin_system (semilattice_inf unsigned)) := sorry --non-trivial
lemma new_lemma_109813 (h0 : has_mem.mem group has_emptyc.emptyc) : @normalizer_condition.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_109814 (h0 : ring (has_Inf (has_add (has_add (has_add pos))))) : is_domain (has_Inf (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_109815 (h0 : not (topological_space (semi_normed_ring (has_nnnorm linarith.comp_source)) -> false)) : @t0_space.{0} (semi_normed_ring.{0} (has_nnnorm.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_ring.{0} (has_nnnorm.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_109816 (h0 : prod (has_inner empty (option empty)) (has_inner empty (option empty))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_109817 (h0 : uniform_space (id (random_gen string_imp))) : complete_space (id (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_109818 (h0 : ordered_add_comm_monoid (comm_group (has_add unsigned))) : archimedean (comm_group (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_109819 (h0 : topological_space (linear_ordered_field name)) : preconnected_space (linear_ordered_field name) := sorry --non-trivial
lemma new_lemma_109820 (h0 : group (dlist (comm_ring to_additive.value_type))) : group.fg (dlist (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_109821 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_109822 (h0 : ring (has_compl linarith.ineq)) : strong_rank_condition (has_compl linarith.ineq) := sorry --non-trivial
lemma new_lemma_109823 (h0 : functor.add_const (add_monoid (semigroup unsigned)) unsigned) : @add_monoid.fg.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (semigroup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_109824 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_109825 (h0 : functor.add_const (add_monoid (has_add linarith.comp)) (has_neg Type)) : @add_monoid.fg.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_monoid.{0} (has_add.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_109826 (h0 : has_add char) (h1 : ring (has_append (add_con char))) : rank_condition (has_append (add_con char)) := sorry --non-trivial
lemma new_lemma_109827 (h1 : ring (distrib (has_lt (random_gen string_imp)))) : is_domain (distrib (has_lt (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_109828 (h0 : topological_space (omega_complete_partial_order (comm_group unsigned))) : irreducible_space (omega_complete_partial_order (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_109829 (h0 : functor.add_const (topological_space (has_neg_part ennreal)) pos) : @t0_space.{0} (has_neg_part.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_109830 (h0 : complete_lattice (normed_comm_ring (has_Inf linarith.comp))) : is_compactly_generated (normed_comm_ring (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_109831 (h0 : add_group (uniform_space char)) : is_add_cyclic (uniform_space char) := sorry --non-trivial
lemma new_lemma_109832 (h0 : topological_space (measurable_space (random_gen fun_info))) : discrete_topology (measurable_space (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_109833 (h0 : functor.add_const (ordered_comm_monoid (comm_group pos)) linarith.comp) : @has_exists_mul_of_le.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (comm_group.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_109834 (h0 : not (complete_lattice (normed_group (has_top (has_top fun_info))) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} (has_top.{0} (has_top.{0} fun_info))) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_group.{0} (has_top.{0} (has_top.{0} fun_info)))) h0)  := sorry --non-trivial
lemma new_lemma_109835 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_field.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_field.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_109836 (h0 : function.extfun Type topological_space) : @t1_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_109837 (h0 : complete_lattice (random_gen (with_bot linarith.comp_source))) : is_atomistic (random_gen (with_bot linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_109838 (h0 : topological_space (complete_semilattice_Sup empty)) : normal_space (complete_semilattice_Sup empty) := sorry --non-trivial
lemma new_lemma_109839 (h0 : ring (semi_normed_comm_ring linarith.ineq)) : is_domain (semi_normed_comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_109840 (h0 : topological_space (dlist (has_nnnorm to_additive.value_type))) : totally_disconnected_space (dlist (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_109841 (h0 : complete_lattice (has_top (semiring fun_info))) : is_compactly_generated (has_top (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_109842 (h0 : topological_space (cancel_monoid (has_add (has_add Type)))) : totally_disconnected_space (cancel_monoid (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_109843 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) (ring environment.implicit_infer_kind)) : @topological_space.separable_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_109844 (h0 : topological_space (semigroup (complete_distrib_lattice (ordered_comm_ring (has_add (ring pos)))))) : irreducible_space (semigroup (complete_distrib_lattice (ordered_comm_ring (has_add (ring pos))))) := sorry --non-trivial
lemma new_lemma_109845 (h0 : complete_lattice (has_top to_additive.value_type)) : is_compactly_generated (has_top to_additive.value_type) := sorry --non-trivial
lemma new_lemma_109846 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) environment.implicit_infer_kind) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_109847 (h0 : uniform_space (topological_space (random_gen (random_gen string_imp)))) : complete_space (topological_space (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_109848 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_semiring empty))) : @rank_condition.{0} (linear_ordered_semiring.{0} empty) (@finset.pi.empty.{1 0} Type ring.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_109849 (h0 : topological_space (has_neg_part (has_add environment.implicit_infer_kind))) : discrete_topology (has_neg_part (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_109850 (h0 : complete_lattice (has_emptyc linarith.ineq)) : is_compactly_generated (has_emptyc linarith.ineq) := sorry --non-trivial
lemma new_lemma_109851 (h0 : complete_lattice (comm_group (normed_comm_ring unsigned))) : is_atomistic (comm_group (normed_comm_ring unsigned)) := sorry --non-trivial
lemma new_lemma_109852 (h0 : functor.add_const (monoid (has_Inf pos)) linarith.comp) : @monoid.fg.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (has_Inf.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_109853 (h0 : topological_space (has_union (semiring (semiring (semiring unsigned))))) : discrete_topology (has_union (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_109854 (h0 : functor.add_const (ordered_comm_monoid (normed_comm_ring environment.implicit_infer_kind)) linarith.comp) : @has_exists_mul_of_le.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_109855 (h0 : group (fintype (random_gen (random_gen to_additive.value_type)))) : is_cyclic (fintype (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_109856 (h0 : topological_space (with_bot (semiring (has_norm num)))) : t0_space (with_bot (semiring (has_norm num))) := sorry --non-trivial
lemma new_lemma_109857 (h0 : monoid (option (semiring (semiring num)))) : monoid.fg (option (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_109858 (h0 : ring (has_append fun_info)) : rank_condition (has_append fun_info) := sorry --non-trivial
lemma new_lemma_109859 (h0 : fin has_zero.zero) : @separated_space.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_109860 (h0 : filter (add_cancel_monoid (has_add (has_nndist (finset (ring (add_cancel_monoid linarith.comp))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_109861 (h0 : function.extfun nat fin) : @regular_space.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (normed_lattice_add_comm_group.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_109862 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_109863 (h0 : functor.add_const (add_monoid (has_neg unsigned)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_neg.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_109864 (h0 : list (complete_semilattice_Sup (random_gen (random_gen to_additive.value_type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_109865 (h0 : fin has_zero.zero) : totally_disconnected_space real := sorry --non-trivial
lemma new_lemma_109866 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system empty)) empty) : @topological_space.separable_space.{0} (measurable_space.dynkin_system.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_109867 (h0 : function.extfun (Type 1) topological_space) : @t0_space.{1} (plift.{1} num) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (plift.{1} num))  := sorry --non-trivial
lemma new_lemma_109868 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_emptyc.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_emptyc.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_109869 (h0 : has_mem.mem (with_one empty) has_emptyc.emptyc) : @totally_separated_space.{0} (with_one.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_109870 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (omega_complete_partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (omega_complete_partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_109871 (h0 : group (semi_normed_ring (has_nnnorm linarith.ineq))) : is_cyclic (semi_normed_ring (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_109872 (h0 : preorder (semigroup_with_zero (comm_monoid (comm_monoid (comm_monoid (comm_monoid unsigned)))))) (h1 : set (semigroup_with_zero (comm_monoid (comm_monoid (comm_monoid (comm_monoid unsigned)))))) : bdd_above h1 := sorry --non-trivial
lemma new_lemma_109873 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (linear_ordered_add_comm_group.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} h0 (linear_ordered_add_comm_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_109874 (h0 : not (complete_lattice (has_compl linarith.comp_source) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_compl.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_compl.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_109875 (h0 : monoid (linear_ordered_add_comm_group (has_norm linarith.comp_source))) : monoid.fg (linear_ordered_add_comm_group (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_109876 (h0 : ordered_add_comm_monoid (has_inter congr_arg_kind)) : archimedean (has_inter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_109877 (h0 : group (measurable_space (has_inv fun_info))) : normalizer_condition (measurable_space (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_109878 (h0 : topological_space (has_compl (has_inv linarith.comp_source))) : path_connected_space (has_compl (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_109879 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (ring empty)) := sorry --non-trivial
lemma new_lemma_109880 (h0 : topological_space (ordered_comm_monoid (has_neg name))) : preirreducible_space (ordered_comm_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_109881 (h0 : topological_space (has_Inf (normed_comm_ring Type))) : locally_compact_space (has_Inf (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_109882 (h2 : topological_space (dlist (has_nnnorm char))) : path_connected_space (dlist (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_109883 (h0 : ring (distrib_lattice (random_gen (random_gen char)))) : rank_condition (distrib_lattice (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_109884 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @topological_space.separable_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_109885 (h0 : functor.add_const (ring (has_to_string name)) Type) : @strong_rank_condition.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (has_to_string.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_109886 (h0 : functor.add_const (group (canonically_ordered_comm_semiring name)) unsigned) : @is_cyclic.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_comm_semiring.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_109887 (h0 : semiring char) (h3 : char) : even h3 := sorry --non-trivial
lemma new_lemma_109888 (h0 : topological_space (ordered_comm_ring (finset linarith.comp))) : t1_space (ordered_comm_ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_109889 (h0 : ring (comm_group environment.implicit_infer_kind)) : rank_condition (comm_group environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_109890 (h0 : topological_space (comm_ring (random_gen (random_gen char)))) : locally_compact_space (comm_ring (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_109891 (h0 : topological_space (random_gen (with_one linarith.comp))) : t0_space (random_gen (with_one linarith.comp)) := sorry --non-trivial
lemma new_lemma_109892 (h0 : not (complete_lattice (add_right_cancel_monoid congr_arg_kind) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (add_right_cancel_monoid.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_109893 (h1 : function.extfun Type ring) : @strong_rank_condition.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h1 (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_109894 (h0 : uniform_space (has_bot (finset linarith.comp))) : separated_space (has_bot (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_109895 (h0 : functor.add_const (list (cancel_monoid pos)) (option pos)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_109896 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (sub_neg_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_109897 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_109898 (h0 : topological_space (has_zero (has_to_string pos))) : normal_space (has_zero (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_109899 (h0 : topological_space (linear_ordered_semiring (has_top linarith.ineq))) : totally_separated_space (linear_ordered_semiring (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_109900 (h0 : ordered_comm_monoid (complete_distrib_lattice (has_bot pos))) : has_exists_mul_of_le (complete_distrib_lattice (has_bot pos)) := sorry --non-trivial
lemma new_lemma_109901 (h0 : topological_space (filter.countable_filter_basis string.iterator_imp)) : totally_disconnected_space (filter.countable_filter_basis string.iterator_imp) := sorry --non-trivial
lemma new_lemma_109902 (h0 : finset (sub_neg_monoid (finset pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_109903 (h0 : topological_space (canonically_ordered_monoid (has_neg Type))) : path_connected_space (canonically_ordered_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_109904 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_bot.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_109905 (h0 : ring (add_cancel_monoid congr_arg_kind)) : rank_condition (add_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_109906 (h0 : filter (linear_ordered_comm_group (option (option (option empty))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_109907 (h0 : topological_space (semiring (semiring (semiring congr_arg_kind)))) : locally_compact_space (semiring (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_109908 (h1 : topological_space (has_nnnorm fun_info)) (h2 : preorder (has_nnnorm fun_info)) : order_closed_topology (has_nnnorm fun_info) := sorry --non-trivial
lemma new_lemma_109909 (h0 : functor.add_const (group (add_cancel_monoid pos)) linarith.comp) : @normalizer_condition.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_109910 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_109911 (h0 : functor.add_const (topological_space (normed_linear_ordered_group empty)) num) : @totally_separated_space.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_109912 (h0 : function.extfun Type (functor.add_const (filter znum))) : filter.ne_bot (functor.add_const.run (function.extfun_app h0 num)) := sorry --non-trivial
lemma new_lemma_109913 (h0 : group (has_zero (has_add name))) : normalizer_condition (has_zero (has_add name)) := sorry --non-trivial
lemma new_lemma_109914 (h0 : finset (boolean_algebra.core (has_add name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_109915 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_109916 (h0 : topological_space (plift (semiring (semiring (semiring congr_arg_kind))))) : normal_space (plift (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_109917 (h1 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h1 (has_union congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_109918 (h0 : cancel_comm_monoid_with_zero (is_R_or_C (option (option empty)))) : unique_factorization_monoid (is_R_or_C (option (option empty))) := sorry --non-trivial
lemma new_lemma_109919 (h0 : semiring (has_Sup (semiring unsigned))) : is_noetherian_ring (has_Sup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_109920 (h0 : functor.add_const (topological_space (has_to_string Type)) Type) : @loc_path_connected_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_to_string.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_109921 (h0 : not (has_mem.mem (complete_semilattice_Sup linarith.comp_source) has_emptyc.emptyc -> false)) : @is_domain.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_109922 (h0 : function.extfun Type (functor.add_const (function.extfun Type topological_space))) : @sequential_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type topological_space.{0})) h0 linarith.comp)) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_109923 (h0 : functor.add_const (functor.add_const (monoid pos) linarith.comp) (has_add linarith.comp)) : @monoid.fg.{0} pos (@functor.add_const.run.{0 0} (monoid.{0} pos) linarith.comp (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (monoid.{0} pos) linarith.comp) (has_add.{0} linarith.comp) h0))  := sorry --non-trivial
lemma new_lemma_109924 (h1 : not (prod enat enat -> false) -> prod enat enat) (h2 : nonempty (prod enat enat)) : set.diagonal enat (classical.choice_of_by_contradiction' h1 h2) := sorry --non-trivial
lemma new_lemma_109925 (h0 : uniform_space (complete_distrib_lattice (has_neg linarith.comp))) : complete_space (complete_distrib_lattice (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_109926 (h0 : functor.add_const (topological_space (canonically_ordered_add_monoid unsigned)) unsigned) : @irreducible_space.{0} (canonically_ordered_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_add_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_109927 (h0 : functor.add_const (complete_lattice (add_right_cancel_monoid unsigned)) (semiring empty)) : @complete_lattice.is_Sup_finite_compact.{0} (add_right_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_right_cancel_monoid.{0} unsigned)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_109928 (h0 : functor.add_const (ring (has_add name)) pos) : @strong_rank_condition.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_109929 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_109930 (h0 : functor.comp topological_space add_cancel_monoid name) : @regular_space.{0} (add_cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_109931 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_109932 (h0 : has_mem.mem linarith.comp has_emptyc.emptyc) : @strong_rank_condition.{0} linarith.comp (@finset.pi.empty.{1 0} Type ring.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_109933 (h0 : group (distrib_lattice (random_gen (random_gen string_imp)))) : group.fg (distrib_lattice (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_109934 (h0 : topological_space (normed_comm_ring (has_to_string Type))) : totally_disconnected_space (normed_comm_ring (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_109935 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_109936 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_109937 (h0 : add_group (has_ssubset linarith.comp_source)) : is_add_cyclic (has_ssubset linarith.comp_source) := sorry --non-trivial
lemma new_lemma_109938 (h0 : functor.add_const (topological_space (non_unital_semiring unsigned)) empty) : @locally_compact_space.{0} (non_unital_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (non_unital_semiring.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_109939 (h0 : topological_space (add_right_cancel_monoid (semiring (semiring num)))) : path_connected_space (add_right_cancel_monoid (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_109940 (h0 : ring (uniform_space (has_compl char))) : is_domain (uniform_space (has_compl char)) := sorry --non-trivial
lemma new_lemma_109941 (h0 : ring (normed_comm_ring (finset (has_nndist pos)))) : rank_condition (normed_comm_ring (finset (has_nndist pos))) := sorry --non-trivial
lemma new_lemma_109942 (h1 : topological_space (has_emptyc (random_gen linarith.comp))) : locally_compact_space (has_emptyc (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_109943 (h0 : functor.add_const (ordered_add_comm_monoid (linear_ordered_comm_monoid_with_zero unsigned)) empty) : @archimedean.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_109944 (h0 : uniform_space (comm_ring (has_nnnorm linarith.comp_source))) : complete_space (comm_ring (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_109945 (h0 : add_monoid (has_add name)) : add_monoid.fg (has_add name) := sorry --non-trivial
lemma new_lemma_109946 (h1 : complete_lattice (has_ssubset char)) : complete_lattice.is_Sup_finite_compact (has_ssubset char) := sorry --non-trivial
lemma new_lemma_109947 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) environment.implicit_infer_kind) : @preirreducible_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_109948 (h0 : topological_space (add_right_cancel_monoid linarith.comp)) : preirreducible_space (add_right_cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_109949 (h0 : function.extfun Type ring) : @is_domain.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_109950 (h0 : uniform_space (canonically_ordered_comm_semiring unsigned)) : separated_space (canonically_ordered_comm_semiring unsigned) := sorry --non-trivial
lemma new_lemma_109951 (h0 : fin has_zero.zero) : @rank_condition.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_109952 (h0 : cancel_comm_monoid_with_zero (has_top num)) : unique_factorization_monoid (has_top num) := sorry --non-trivial
lemma new_lemma_109953 (h0 : ring (complete_distrib_lattice (has_add (finset name)))) : rank_condition (complete_distrib_lattice (has_add (finset name))) := sorry --non-trivial
lemma new_lemma_109954 (h0 : ring (has_neg (option (option (has_to_string pos))))) : strong_rank_condition (has_neg (option (option (has_to_string pos)))) := sorry --non-trivial
lemma new_lemma_109955 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} linarith.comp (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_109956 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @is_domain.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_109957 (h0 : topological_space (as_linear_order congr_arg_kind)) : locally_compact_space (as_linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_109958 (h0 : list (finset (ring Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_109959 (h0 : add_monoid (has_norm (measurable_space (has_norm congr_arg_kind)))) : add_monoid.fg (has_norm (measurable_space (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_109960 (h0 : function.extfun Type ring) : @rank_condition.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_109961 (h0 : ring (has_norm (has_top (has_top fun_info)))) : strong_rank_condition (has_norm (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_109962 (h0 : topological_space (finset (option (option (option (option pos)))))) : totally_separated_space (finset (option (option (option (option pos))))) := sorry --non-trivial
lemma new_lemma_109963 (h0 : functor.add_const (topological_space (has_zero Type)) (has_neg Type)) : @irreducible_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_zero.{1} Type)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_109964 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_109965 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @irreducible_space.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_109966 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_dist.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_dist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_109967 (h0 : group (has_to_string (has_add unsigned))) : normalizer_condition (has_to_string (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_109968 (h0 : function.extfun Type ring) : @is_domain.{0} (complete_semilattice_Sup.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_semilattice_Sup.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_109969 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (complete_semilattice_Sup.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (complete_semilattice_Sup.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_109970 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @strong_rank_condition.{0} num (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) num)  := sorry --non-trivial
lemma new_lemma_109971 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} h0 linarith.comp)  := sorry --non-trivial
lemma new_lemma_109972 (h0 : not (has_mem.mem (id num) has_emptyc.emptyc -> false)) : @rank_condition.{0} (@id.{2} Type num) (@finset.pi.empty.{1 0} Type ring.{0} (@id.{2} Type num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (@id.{2} Type num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_109973 (h0 : uniform_space (measure_theory.measure_space num)) : complete_space (measure_theory.measure_space num) := sorry --non-trivial
lemma new_lemma_109974 (h0 : uniform_space (add_left_cancel_semigroup (option empty))) : separated_space (add_left_cancel_semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_109975 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_109976 (h0 : monoid (has_one (semiring num))) : monoid.fg (has_one (semiring num)) := sorry --non-trivial
lemma new_lemma_109977 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_109978 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_109979 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_109980 (h0 : topological_space (measurable_space.dynkin_system (semiring congr_arg_kind))) : loc_path_connected_space (measurable_space.dynkin_system (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_109981 (h0 : topological_space (canonically_ordered_comm_semiring (ring Type))) : topological_space.separable_space (canonically_ordered_comm_semiring (ring Type)) := sorry --non-trivial
lemma new_lemma_109982 (h0 : functor.add_const (monoid (has_neg Type)) Type) : @monoid.fg.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 1} (monoid.{1} (has_neg.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_109983 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring linarith.comp)) Type) : @locally_compact_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_109984 (h0 : complete_lattice (ordered_comm_group congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_109985 (h0 : topological_space (comm_group (has_neg_part (has_neg_part (semigroup pos))))) : path_connected_space (comm_group (has_neg_part (has_neg_part (semigroup pos)))) := sorry --non-trivial
lemma new_lemma_109986 (h0 : measurable_space (generalized_boolean_algebra name)) (h1 : function.extfun Type has_div) : @has_measurable_div₂.{0} (generalized_boolean_algebra.{0} name) h0 (@function.extfun_app.{2 1} Type has_div.{0} h1 (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_109987 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_109988 (h0 : ring (has_to_string (has_neg Type))) : strong_rank_condition (has_to_string (has_neg Type)) := sorry --non-trivial
lemma new_lemma_109989 (h0 : add_group (boolean_algebra (add_comm_monoid name))) : is_add_cyclic (boolean_algebra (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_109990 (h0 : functor.add_const (function.extfun Type topological_space) (normed_comm_ring pos)) : @t1_space.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (normed_comm_ring.{0} pos) h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_109991 (h0 : ordered_add_comm_monoid (has_Inf (has_add (finset pos)))) : archimedean (has_Inf (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_109992 (h0 : topological_space (mul_one_class std_gen)) (h1 : set (mul_one_class std_gen)) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_109993 (h0 : ulower nat) : nat.perfect (ulower.up h0) := sorry --non-trivial
lemma new_lemma_109994 (h0 : functor.add_const (list (canonically_linear_ordered_monoid unsigned)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_109995 (h0 : topological_space (has_inf (mul_zero_class congr_arg_kind))) : t1_space (has_inf (mul_zero_class congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_109996 (h0 : topological_space (has_norm (random_gen linarith.comp_source))) : path_connected_space (has_norm (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_109997 (h1 : function.extfun Type group) : @normalizer_condition.{0} empty (@function.extfun_app.{2 1} Type group.{0} h1 empty)  := sorry --non-trivial
lemma new_lemma_109998 (h0 : function.extfun nat fin) : @preconnected_space.{0} (ordered_comm_monoid.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_109999 (h3 : topological_space (semi_normed_ring (mul_one_class linarith.ineq))) : t0_space (semi_normed_ring (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_110000 (h1 : set (normed_field enat)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_110001 (h0 : functor.add_const (complete_lattice (finset Type)) (finset (finset Type))) : @is_compactly_generated.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (finset.{1} Type)) (finset.{1} (finset.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_110002 (h0 : topological_space (has_compl (mul_one_class ereal))) : path_connected_space (has_compl (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_110003 (h0 : functor.add_const (topological_space (preorder num)) (semiring empty)) : @totally_disconnected_space.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} num)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_110004 (h0 : functor.add_const (topological_space (has_neg_part Type)) environment.implicit_infer_kind) : @totally_separated_space.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg_part.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_110005 (h1 : not (complete_lattice (random_gen linarith.comp_source) -> false)) : @is_compactly_generated.{0} (random_gen.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (random_gen.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_110006 (h0 : ring (complete_distrib_lattice (ring linarith.comp))) : is_principal_ideal_ring (complete_distrib_lattice (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_110007 (h0 : functor.add_const (uniform_space (add_comm_monoid environment.implicit_infer_kind)) name) : @complete_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_110008 (h0 : functor.add_const (complete_lattice (semiring num)) empty) : @is_compactly_generated.{0} (semiring.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semiring.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_110009 (h0 : topological_space (canonically_ordered_comm_semiring name)) : totally_separated_space (canonically_ordered_comm_semiring name) := sorry --non-trivial
lemma new_lemma_110010 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (add_cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_110011 (h1 : add_group (normed_group (has_inv string_imp))) : is_add_cyclic (normed_group (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_110012 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_110013 (h0 : monoid (complete_distrib_lattice real)) : monoid.fg (complete_distrib_lattice real) := sorry --non-trivial
lemma new_lemma_110014 (h0 : functor.add_const (complete_lattice (ring linarith.comp)) (has_zero (has_to_string Type))) : @complete_lattice.is_Sup_finite_compact.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (ring.{0} linarith.comp)) (has_zero.{1} (has_to_string.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_110015 (h0 : not (has_mem.mem (linear_ordered_semiring fun_info) has_emptyc.emptyc -> false)) : @discrete_topology.{0} (linear_ordered_semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} fun_info) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} fun_info) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_110016 (h0 : group (denumerable (conditionally_complete_linear_order fun_info))) : is_cyclic (denumerable (conditionally_complete_linear_order fun_info)) := sorry --non-trivial
lemma new_lemma_110017 (h2 : ring (normed_field (random_gen char))) : is_domain (normed_field (random_gen char)) := sorry --non-trivial
lemma new_lemma_110018 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (measurable_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 monoid.{0}) (measurable_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_110019 (h0 : ring (linear_ordered_semiring (random_gen fun_info))) : is_domain (linear_ordered_semiring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_110020 (h0 : function.extfun Type (functor.add_const (ring ennreal))) : @is_principal_ideal_ring.{0} ennreal (@functor.add_const.run.{0 0} (ring.{0} ennreal) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} ennreal)) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_110021 (h0 : monoid (with_bot (random_gen (has_inv linarith.comp_source)))) : monoid.fg (with_bot (random_gen (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_110022 (h3 : topological_space ereal) : t0_space ereal := sorry --non-trivial
lemma new_lemma_110023 (h0 : preorder (add_comm_semigroup (add_comm_semigroup enat))) (h1 : set (add_comm_semigroup (add_comm_semigroup enat))) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_110024 (h0 : ring (finset (option pos))) : strong_rank_condition (finset (option pos)) := sorry --non-trivial
lemma new_lemma_110025 (h0 : topological_space (linear_ordered_semiring empty)) : normal_space (linear_ordered_semiring empty) := sorry --non-trivial
lemma new_lemma_110026 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_110027 (h0 : not (ring (denumerable (has_ssubset linarith.ineq)) -> false)) : @rank_condition.{0} (denumerable.{0} (has_ssubset.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (ring.{0} (denumerable.{0} (has_ssubset.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_110028 (h0 : functor.add_const (topological_space (has_add linarith.comp)) (has_zero pos)) : @preirreducible_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) (has_zero.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_110029 (h0 : topological_space (monoid empty)) : t0_space (monoid empty) := sorry --non-trivial
lemma new_lemma_110030 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} real.angle (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) real.angle)  := sorry --non-trivial
lemma new_lemma_110031 (h1 : uniform_space ereal) : complete_space ereal := sorry --non-trivial
lemma new_lemma_110032 (h0 : add_monoid (has_neg_part (has_add (has_add environment.implicit_infer_kind)))) : add_monoid.fg (has_neg_part (has_add (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_110033 (h0 : functor.add_const (complete_lattice (bin_tree congr_arg_kind)) unsigned) : @is_atomistic.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (bin_tree.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_110034 (h0 : ordered_add_comm_monoid (measurable_space.dynkin_system empty)) : archimedean (measurable_space.dynkin_system empty) := sorry --non-trivial
lemma new_lemma_110035 (h0 : not (ring (with_zero linarith.comp_source) -> false)) : @is_domain.{0} (with_zero.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (with_zero.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_110036 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (linear_ordered_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_110037 (h0 : topological_space (id (has_norm empty))) : t0_space (id (has_norm empty)) := sorry --non-trivial
lemma new_lemma_110038 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_110039 (h0 : function.extfun nat fin) : @complete_space.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (uniform_space.{0} (comm_semigroup.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_110040 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (dlist.{0} string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (dlist.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_110041 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_110042 (h0 : function.extfun (Type 1) ring) : @strong_rank_condition.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_110043 (h0 : topological_space (has_neg (finset (finset pos)))) : loc_path_connected_space (has_neg (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_110044 (h1 : complete_lattice (simple_graph string.iterator_imp)) : is_compactly_generated (simple_graph string.iterator_imp) := sorry --non-trivial
lemma new_lemma_110045 (h0 : semiring (boolean_algebra (sub_neg_monoid (has_add (sub_neg_monoid real))))) : is_noetherian_ring (boolean_algebra (sub_neg_monoid (has_add (sub_neg_monoid real)))) := sorry --non-trivial
lemma new_lemma_110046 (h0 : group (has_pos_part (finset real))) : group.fg (has_pos_part (finset real)) := sorry --non-trivial
lemma new_lemma_110047 (h0 : add_group (comm_ring (has_nnnorm (comm_ring fun_info)))) : is_add_cyclic (comm_ring (has_nnnorm (comm_ring fun_info))) := sorry --non-trivial
lemma new_lemma_110048 (h0 : complete_lattice (has_union empty)) : is_compactly_generated (has_union empty) := sorry --non-trivial
lemma new_lemma_110049 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (bin_tree.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (bin_tree.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_110050 (h0 : has_mem.mem (complete_semilattice_Sup to_additive.value_type) has_emptyc.emptyc) : @locally_compact_space.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_110051 (h1 : list (has_top string_imp)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_110052 (h0 : functor.add_const (topological_space (linear_ordered_comm_monoid_with_zero empty)) empty) : @t0_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_110053 (h0 : group (encodable to_additive.value_type)) : group.fg (encodable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_110054 (h0 : not (topological_space (semiring (has_norm linarith.comp_source)) -> false)) : @totally_disconnected_space.{0} (semiring.{0} (has_norm.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} (has_norm.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_110055 (h0 : function.extfun (Type 1) ring) : @is_domain.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_110056 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_neg unsigned)) empty) : @unique_factorization_monoid.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_neg.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_110057 (h0 : topological_space (has_neg_part unsigned)) : regular_space (has_neg_part unsigned) := sorry --non-trivial
lemma new_lemma_110058 (h0 : functor.add_const (add_group (canonically_ordered_comm_semiring pos)) linarith.comp) : @is_add_cyclic.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (canonically_ordered_comm_semiring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_110059 (h0 : group (has_inv (random_gen to_additive.value_type))) : group.fg (has_inv (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_110060 (h1 : prod ereal ereal) : set.diagonal ereal h1 := sorry --non-trivial
lemma new_lemma_110061 (h0 : finset (has_add (mul_one_class Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_110062 (h0 : functor.add_const (uniform_space (ring linarith.comp)) Type) : @separated_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_110063 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_110064 (h0 : topological_space (normed_comm_ring (has_to_string unsigned))) : totally_disconnected_space (normed_comm_ring (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_110065 (h0 : finset (preorder unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_110066 (h0 h1 : rat) : rat.le h0 h1 := sorry --non-trivial
lemma new_lemma_110067 (h0 : add_monoid (semiring (has_zero empty))) : add_monoid.fg (semiring (has_zero empty)) := sorry --non-trivial
lemma new_lemma_110068 (h0 : fin has_zero.zero) : is_add_cyclic real := sorry --non-trivial
lemma new_lemma_110069 (h0 : ordered_comm_monoid (boolean_algebra (has_Inf (has_neg (has_neg name))))) : has_exists_mul_of_le (boolean_algebra (has_Inf (has_neg (has_neg name)))) := sorry --non-trivial
lemma new_lemma_110070 (h0 : filter (lattice unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_110071 (h0 : ring (semiring (has_top congr_arg_kind))) : rank_condition (semiring (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_110072 (h0 : topological_space (has_zero (boolean_algebra.core name))) : totally_separated_space (has_zero (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_110073 (h0 : ring (has_to_string (ring (finset name)))) : rank_condition (has_to_string (ring (finset name))) := sorry --non-trivial
lemma new_lemma_110074 (h0 : topological_space (has_top (has_top (random_gen (has_top linarith.ineq))))) : path_connected_space (has_top (has_top (random_gen (has_top linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_110075 (h0 : not (ring (has_sub unsigned) -> false)) : @is_principal_ideal_ring.{0} (has_sub.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (has_sub.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_110076 (h0 : topological_space (ordered_comm_ring (has_neg (has_neg linarith.comp)))) : irreducible_space (ordered_comm_ring (has_neg (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_110077 (h0 : group (has_one congr_arg_kind)) : normalizer_condition (has_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_110078 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @group.fg.{1} (has_to_string.{1} Type) (@matrix.vec_empty.{1} (group.{1} (has_to_string.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_110079 (h3 : ring (boolean_algebra.core ereal)) : strong_rank_condition (boolean_algebra.core ereal) := sorry --non-trivial
lemma new_lemma_110080 (h0 : add_group (has_Sup congr_arg_kind)) : is_add_cyclic (has_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_110081 (h0 : not (topological_space (conditionally_complete_linear_order empty) -> false)) : @totally_disconnected_space.{0} (conditionally_complete_linear_order.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (conditionally_complete_linear_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_110082 (h0 : topological_space (monoid unsigned)) : path_connected_space (monoid unsigned) := sorry --non-trivial
lemma new_lemma_110083 (h0 : topological_space (has_Inf (add_cancel_monoid (has_neg (has_neg name))))) : normal_space (has_Inf (add_cancel_monoid (has_neg (has_neg name)))) := sorry --non-trivial
lemma new_lemma_110084 (h0 : complete_lattice (random_gen (has_norm unsigned))) : is_compactly_generated (random_gen (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_110085 (h0 : ring (comm_group (comm_group (has_add (has_to_string (has_add (comm_group name))))))) : is_domain (comm_group (comm_group (has_add (has_to_string (has_add (comm_group name)))))) := sorry --non-trivial
lemma new_lemma_110086 (h0 : function.extfun nat fin) : @unique_factorization_monoid.{0} (canonically_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (canonically_ordered_monoid.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_110087 (h0 : functor.add_const (function.extfun Type list) pos) : palindrome (function.extfun_app (functor.add_const.run h0) (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_110088 (h0 : functor.comp topological_space has_neg linarith.comp) : @sequential_space.{0} (has_neg.{0} linarith.comp) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_110089 (h0 : functor.add_const (functor.add_const (topological_space linarith.comp) linarith.comp) linarith.comp) : @locally_compact_space.{0} linarith.comp (@functor.add_const.run.{0 0} (topological_space.{0} linarith.comp) linarith.comp (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} linarith.comp) linarith.comp) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_110090 (h0 : option linarith.comp_source) (h1 : complete_lattice (distrib to_additive.value_type)) (h2 : linarith.comp_source -> complete_lattice (distrib to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (distrib to_additive.value_type) := sorry --non-trivial
lemma new_lemma_110091 (h0 : normed_linear_ordered_group (option congr_arg_kind) -> Prop) : zzz_forall h0 := sorry --non-trivial
lemma new_lemma_110092 (h0 : multiset (topological_space (comm_ring to_additive.value_type))) : @locally_compact_space.{0} (comm_ring.{0} to_additive.value_type) (@multiset.inf.{0} (topological_space.{0} (comm_ring.{0} to_additive.value_type)) (@lattice.to_semilattice_inf.{0} (topological_space.{0} (comm_ring.{0} to_additive.value_type)) (@conditionally_complete_lattice.to_lattice.{0} (topological_space.{0} (comm_ring.{0} to_additive.value_type)) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} (comm_ring.{0} to_additive.value_type)) (@topological_space.complete_lattice.{0} (comm_ring.{0} to_additive.value_type))))) (@bounded_order.to_order_top.{0} (topological_space.{0} (comm_ring.{0} to_additive.value_type)) (@preorder.to_has_le.{0} (topological_space.{0} (comm_ring.{0} to_additive.value_type)) (@partial_order.to_preorder.{0} (topological_space.{0} (comm_ring.{0} to_additive.value_type)) (@semilattice_inf.to_partial_order.{0} (topological_space.{0} (comm_ring.{0} to_additive.value_type)) (@lattice.to_semilattice_inf.{0} (topological_space.{0} (comm_ring.{0} to_additive.value_type)) (@conditionally_complete_lattice.to_lattice.{0} (topological_space.{0} (comm_ring.{0} to_additive.value_type)) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} (comm_ring.{0} to_additive.value_type)) (@topological_space.complete_lattice.{0} (comm_ring.{0} to_additive.value_type)))))))) (@complete_lattice.to_bounded_order.{0} (topological_space.{0} (comm_ring.{0} to_additive.value_type)) (@topological_space.complete_lattice.{0} (comm_ring.{0} to_additive.value_type)))) h0)  := sorry --non-trivial
lemma new_lemma_110093 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_110094 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) linarith.comp) : @preirreducible_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_110095 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (canonically_ordered_comm_semiring unsigned)) := sorry --non-trivial
lemma new_lemma_110096 (h0 : not (group (measurable_space fun_info) -> false)) : @is_cyclic.{0} (measurable_space.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (measurable_space.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_110097 (h0 : not (group (has_norm linarith.ineq) -> false)) : @is_cyclic.{0} (has_norm.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (has_norm.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_110098 (h0 : topological_space (conditionally_complete_linear_order linarith.comp_source)) : irreducible_space (conditionally_complete_linear_order linarith.comp_source) := sorry --non-trivial
lemma new_lemma_110099 (h0 : functor.add_const (ordered_comm_monoid (add_comm_monoid linarith.comp)) pos) : @has_exists_mul_of_le.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (add_comm_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_110100 (h0 : prod (boolean_algebra.core pos) (boolean_algebra.core pos)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_110101 (h0 : measurable_space (nondiscrete_normed_field (add_comm_semigroup enat))) (h1 : measure_theory.measure (nondiscrete_normed_field (add_comm_semigroup enat))) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_110102 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_110103 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) pos) : @loc_path_connected_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_110104 (h1 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_110105 (h0 : with_bot (fin has_zero.zero)) (h1 : ne h0 has_bot.bot) : matrix.vec_empty (with_bot.unbot h0 h1) := sorry --non-trivial
lemma new_lemma_110106 (h0 : group (has_Sup (option unsigned))) : normalizer_condition (has_Sup (option unsigned)) := sorry --non-trivial
lemma new_lemma_110107 (h0 : not (ring (random_gen (has_nnnorm linarith.ineq)) -> false)) : @is_domain.{0} (random_gen.{0} (has_nnnorm.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} (has_nnnorm.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_110108 (h0 : monoid (left_cancel_monoid (semiring (semiring (semiring empty))))) : monoid.fg (left_cancel_monoid (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_110109 (h0 : functor.add_const (group (preorder empty)) num) : @normalizer_condition.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (preorder.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_110110 (h0 : complete_semilattice_Sup num -> complete_semilattice_Sup num -> Prop) : is_trans (complete_semilattice_Sup num) h0 := sorry --non-trivial
lemma new_lemma_110111 (h0 : topological_space (has_nndist (semigroup name))) : preconnected_space (has_nndist (semigroup name)) := sorry --non-trivial
lemma new_lemma_110112 (h0 : complete_lattice (has_nndist (comm_group pos))) : complete_lattice.is_Sup_finite_compact (has_nndist (comm_group pos)) := sorry --non-trivial
lemma new_lemma_110113 (h1 : function.extfun Type uniform_space) : @complete_space.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} h1 (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_110114 (h0 : functor.add_const (monoid (has_bot empty)) (option (option empty))) : @monoid.fg.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (has_bot.{0} empty)) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_110115 (h0 : topological_space (ordered_comm_monoid (finset (has_pos_part (finset linarith.comp))))) : discrete_topology (ordered_comm_monoid (finset (has_pos_part (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_110116 (h0 : complete_lattice (normed_field (has_lt (has_lt string_imp)))) : is_compactly_generated (normed_field (has_lt (has_lt string_imp))) := sorry --non-trivial
lemma new_lemma_110117 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @path_connected_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_110118 (h0 : topological_space (boolean_algebra unsigned)) : preconnected_space (boolean_algebra unsigned) := sorry --non-trivial
lemma new_lemma_110119 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (canonically_ordered_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (canonically_ordered_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_110120 (h1 : complete_lattice (denumerable char)) : complete_lattice.is_Sup_finite_compact (denumerable char) := sorry --non-trivial
lemma new_lemma_110121 (h0 : group (topological_space (random_gen (random_gen (random_gen (random_gen char)))))) : group.fg (topological_space (random_gen (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_110122 (h0 : fin has_zero.zero) : @complete_space.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (normed_lattice_add_comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_110123 (h0 : uniform_space (semiring linarith.ineq)) : complete_space (semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_110124 (h0 : measurable_space (add_comm_semigroup char)) (h1 : measure_theory.measure (add_comm_semigroup char)) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_110125 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_110126 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_110127 (h0 : functor.add_const (topological_space (has_star unsigned)) unsigned) : @t1_space.{0} (has_star.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_110128 (h0 : complete_lattice (comm_group pos)) : is_atomistic (comm_group pos) := sorry --non-trivial
lemma new_lemma_110129 (h0 : set (has_compl (has_nnnorm string.iterator_imp))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_110130 (h0 : topological_space (denumerable string_imp)) : t0_space (denumerable string_imp) := sorry --non-trivial
lemma new_lemma_110131 (h0 : group (has_ssubset (has_nnnorm (has_top linarith.comp_source)))) : group.fg (has_ssubset (has_nnnorm (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_110132 (h0 : functor.comp topological_space add_cancel_monoid name) : @locally_compact_space.{0} (add_cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_110133 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_110134 (h0 : functor.add_const (filter (semigroup name)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_110135 (h0 : functor.add_const (ordered_add_comm_monoid (ordered_comm_monoid linarith.comp)) linarith.comp) : @archimedean.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ordered_comm_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_110136 (h0 : group (ring (has_neg pos))) : normalizer_condition (ring (has_neg pos)) := sorry --non-trivial
lemma new_lemma_110137 (h0 : functor.comp list pseudo_metric_space (finset name)) : palindrome (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_110138 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (normed_lattice_add_comm_group.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_110139 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring Type)) ennreal) : @totally_separated_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (canonically_ordered_comm_semiring.{1} Type)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_110140 (h0 : functor.add_const (filter (semigroup Type)) (has_neg_part pos)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_110141 (h0 : ring (add_cancel_comm_monoid char)) : strong_rank_condition (add_cancel_comm_monoid char) := sorry --non-trivial
lemma new_lemma_110142 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (free_add_monoid.{0} (option.{0} (option.{0} (option.{0} unsigned)))) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (free_add_monoid.{0} (option.{0} (option.{0} (option.{0} unsigned)))))  := sorry --non-trivial
lemma new_lemma_110143 (h0 : topological_space (has_top (metric_space (metric_space linarith.comp)))) : t0_space (has_top (metric_space (metric_space linarith.comp))) := sorry --non-trivial
lemma new_lemma_110144 (h0 : filter (measure_theory.measure_space (semiring (semiring (semiring (semiring (semiring unsigned))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_110145 (h2 : set (mul_one_class enat -> enat)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_110146 (h0 : prod num num) : set.diagonal num h0 := sorry --non-trivial
lemma new_lemma_110147 (h0 : monoid (has_sub num)) : monoid.fg (has_sub num) := sorry --non-trivial
lemma new_lemma_110148 (h0 : topological_space (metric_space (semiring (semiring num)))) : totally_separated_space (metric_space (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_110149 (h0 : functor.add_const (finset (has_Inf pos)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_110150 (h0 : fin has_zero.zero) : @irreducible_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) (@matrix.vec_empty.{2} (function.extfun.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1))) h0) topological_space.{1}) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_110151 (h0 : functor.add_const (ring (ordered_comm_group unsigned)) empty) : @is_domain.{0} (ordered_comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_group.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_110152 (h0 : functor.add_const (topological_space (complete_distrib_lattice unsigned)) linarith.comp) : @preconnected_space.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_110153 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (ring.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_110154 (h0 : ordered_add_comm_monoid (linear_ordered_field (option (option (option (option (option unsigned))))))) : archimedean (linear_ordered_field (option (option (option (option (option unsigned)))))) := sorry --non-trivial
lemma new_lemma_110155 (h0 : topological_space (add_group (has_norm num))) : path_connected_space (add_group (has_norm num)) := sorry --non-trivial
lemma new_lemma_110156 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (option.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (option.{0} empty))  := sorry --non-trivial
lemma new_lemma_110157 (h0 : has_neg (linear_ordered_comm_group_with_zero linarith.comp_source)) (h1 : measurable_space (linear_ordered_comm_group_with_zero linarith.comp_source)) : has_measurable_neg (linear_ordered_comm_group_with_zero linarith.comp_source) := sorry --non-trivial
lemma new_lemma_110158 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) Type) : @t0_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_110159 (h0 : not (has_mem.mem (normed_group linarith.comp_source) has_emptyc.emptyc -> false)) : @totally_separated_space.{0} (normed_group.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_110160 (h0 : functor.add_const (topological_space (has_add pos)) pos) : @topological_space.separable_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_110161 (h0 : cancel_comm_monoid_with_zero (has_neg_part pos)) : unique_factorization_monoid (has_neg_part pos) := sorry --non-trivial
lemma new_lemma_110162 (h0 : functor.add_const (semiring (finset environment.implicit_infer_kind)) pos) : @is_noetherian_ring.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (semiring.{0} (finset.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_110163 (h0 : fin has_zero.zero) : @t0_space.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_110164 (h0 : group (cancel_monoid ennreal)) : is_cyclic (cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_110165 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @preconnected_space.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_110166 (h0 : functor.add_const (function.extfun Type topological_space) (has_nndist name)) : @t1_space.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_nndist.{0} name) h0) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_110167 (h0 : topological_space (has_Inf (has_neg (ring pos)))) : irreducible_space (has_Inf (has_neg (ring pos))) := sorry --non-trivial
lemma new_lemma_110168 (h0 : topological_space (measurable_space (has_top fun_info))) : totally_separated_space (measurable_space (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_110169 (h0 : uniform_space (canonically_ordered_monoid name)) : separated_space (canonically_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_110170 (h0 : topological_space (has_bot (has_Inf Type))) : normal_space (has_bot (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_110171 (h0 : not (topological_space (has_one empty) -> false)) : @t0_space.{0} (has_one.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_one.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_110172 (h0 : functor.add_const (functor.add_const (list Type) Type) linarith.comp) : palindrome (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_110173 (h0 : semiring (pseudo_metric_space (option (option (option unsigned))))) : is_noetherian_ring (pseudo_metric_space (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_110174 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (canonically_ordered_comm_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (canonically_ordered_comm_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_110175 (h0 : functor.add_const (uniform_space (linear_ordered_comm_monoid_with_zero empty)) empty) : @separated_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_110176 (h0 : topological_space (ring name)) : totally_disconnected_space (ring name) := sorry --non-trivial
lemma new_lemma_110177 (h0 : string_imp -> string_imp -> Prop) : is_trans string_imp h0 := sorry --non-trivial
lemma new_lemma_110178 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) linarith.comp) : @normal_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_110179 (h0 : functor.add_const (ring (comm_monoid empty)) empty) : @strong_rank_condition.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_110180 (h0 : functor.add_const (ring (ring environment.implicit_infer_kind)) pos) : @strong_rank_condition.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_110181 (h0 : list (group_with_zero ennreal)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_110182 (h0 : topological_space (has_neg_part (has_to_string (option (option ennreal))))) : normal_space (has_neg_part (has_to_string (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_110183 (h0 : functor.add_const (function.extfun (Type 1) semiring) linarith.comp) : @is_noetherian_ring.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) semiring.{1}) linarith.comp h0) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_110184 (h0 : function.extfun (Type 1) topological_space) : @regular_space.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_110185 (h0 : not (complete_lattice (distrib to_additive.value_type) -> false)) : @is_compactly_generated.{0} (distrib.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (distrib.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_110186 (h0 : not (functor.add_const Prop empty -> false)) : functor.add_const.run (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_110187 (h2 : ring (uniform_space string_imp)) : rank_condition (uniform_space string_imp) := sorry --non-trivial
lemma new_lemma_110188 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_sub.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_sub.{0} num))  := sorry --non-trivial
lemma new_lemma_110189 (h0 : list (has_neg (boolean_algebra Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_110190 (h0 : functor.add_const (topological_space linarith.comp) linarith.comp) : @loc_path_connected_space.{0} linarith.comp (@functor.add_const.run.{0 0} (topological_space.{0} linarith.comp) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_110191 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) name) : @t1_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_110192 (h0 : functor.add_const (topological_space (boolean_algebra.core environment.implicit_infer_kind)) name) : @t1_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_110193 (h0 : add_group (has_append (has_nnnorm (has_nnnorm char)))) : is_add_cyclic (has_append (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_110194 (h0 : functor.add_const (monoid (boolean_algebra.core Type)) Type) : @monoid.fg.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 1} (monoid.{1} (boolean_algebra.core.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_110195 (h0 : functor.add_const (group (complete_distrib_lattice pos)) (ring environment.implicit_infer_kind)) : @is_cyclic.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} pos)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_110196 (h0 : topological_space (has_neg_part unsigned)) : preconnected_space (has_neg_part unsigned) := sorry --non-trivial
lemma new_lemma_110197 (h0 : function.extfun Type (functor.add_const (topological_space Type))) : @totally_separated_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) environment.implicit_infer_kind (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (topological_space.{1} Type)) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_110198 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_to_string.{0} (has_add.{0} name)) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_to_string.{0} (has_add.{0} name)))  := sorry --non-trivial
lemma new_lemma_110199 (h0 : functor.add_const (add_monoid (linear_ordered_comm_ring unsigned)) unsigned) : @add_monoid.fg.{0} (linear_ordered_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (linear_ordered_comm_ring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_110200 (h0 : topological_space (linear_ordered_comm_group (option (option ennreal)))) : path_connected_space (linear_ordered_comm_group (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_110201 (h0 : complete_lattice (complete_distrib_lattice (option (option empty)))) : is_atomistic (complete_distrib_lattice (option (option empty))) := sorry --non-trivial
lemma new_lemma_110202 (h0 : ring (canonically_ordered_comm_semiring (has_add (has_add linarith.comp)))) : is_domain (canonically_ordered_comm_semiring (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_110203 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_110204 (h0 : cancel_comm_monoid_with_zero (has_nndist (has_add linarith.comp))) : unique_factorization_monoid (has_nndist (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_110205 (h1 : not (complete_lattice (comm_ring linarith.comp_source) -> false)) : @is_compactly_generated.{0} (comm_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (comm_ring.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_110206 (h0 : function.extfun Type group) : @group.fg.{0} (complete_linear_order.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_110207 (h0 : topological_space (measurable_space (random_gen linarith.ineq))) : totally_disconnected_space (measurable_space (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_110208 (h0 : function.extfun nat fin) : is_add_cyclic real := sorry --non-trivial
lemma new_lemma_110209 (h0 : functor.add_const (add_monoid (has_Inf Type)) linarith.comp) : @add_monoid.fg.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (has_Inf.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_110210 (h0 : ring (has_add (finset linarith.comp))) : strong_rank_condition (has_add (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_110211 (h0 : function.extfun Type (functor.add_const (complete_lattice auto.case_option))) : @complete_lattice.is_Sup_finite_compact.{0} auto.case_option (@functor.add_const.run.{0 0} (complete_lattice.{0} auto.case_option) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} auto.case_option)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_110212 (h0 : fin has_zero.zero) : @regular_space.{0} (finset.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (finset.{0} real)) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_110213 (h0 : list (semigroup (ring Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_110214 (h0 : ring (with_one (semiring (semiring (semiring congr_arg_kind))))) : is_domain (with_one (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_110215 (h0 : add_group (has_bot (has_Inf (finset (has_Inf linarith.comp))))) : is_add_cyclic (has_bot (has_Inf (finset (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_110216 (h0 : uniform_space (has_norm unsigned)) : separated_space (has_norm unsigned) := sorry --non-trivial
lemma new_lemma_110217 (h0 : ring (canonically_linear_ordered_monoid (option (option num)))) : is_domain (canonically_linear_ordered_monoid (option (option num))) := sorry --non-trivial
lemma new_lemma_110218 (h0 : complete_lattice (add_cancel_monoid (finset (has_Inf linarith.comp)))) : is_compactly_generated (add_cancel_monoid (finset (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_110219 (h0 : topological_space (left_cancel_monoid (semiring empty))) : normal_space (left_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_110220 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_to_string Type)) (boolean_algebra (has_neg_part unsigned))) : @unique_factorization_monoid.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (has_to_string.{1} Type)) (boolean_algebra.{0} (has_neg_part.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_110221 (h0 : topological_space (add_cancel_monoid (option (complete_distrib_lattice pos)))) : locally_compact_space (add_cancel_monoid (option (complete_distrib_lattice pos))) := sorry --non-trivial
lemma new_lemma_110222 (h1 : ring (random_gen reducibility_hints)) : rank_condition (random_gen reducibility_hints) := sorry --non-trivial
lemma new_lemma_110223 (h0 : filter (boolean_algebra (has_neg Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_110224 (h0 : not (topological_space (uniform_space (has_nnnorm enat)) -> false)) : @t0_space.{0} (uniform_space.{0} (has_nnnorm.{0} enat)) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} (has_nnnorm.{0} enat))) h0)  := sorry --non-trivial
lemma new_lemma_110225 (h0 : topological_space (complete_semilattice_Sup (has_inv string_imp))) : t0_space (complete_semilattice_Sup (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_110226 (h0 : ring (has_inner unsigned unsigned)) : strong_rank_condition (has_inner unsigned unsigned) := sorry --non-trivial
lemma new_lemma_110227 (h0 : uniform_space (boolean_algebra (has_add (finset pos)))) : separated_space (boolean_algebra (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_110228 (h0 : ordered_comm_monoid (has_neg name)) : has_exists_mul_of_le (has_neg name) := sorry --non-trivial
lemma new_lemma_110229 (h0 : function.extfun (Type 1) group) : @is_simple_group.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_110230 (h0 : function.extfun Type (functor.add_const (group (has_neg pos)))) : @normalizer_condition.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} pos)) (finset.{0} (ring.{0} linarith.comp)) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} (has_neg.{0} pos))) h0 (finset.{0} (ring.{0} linarith.comp))))  := sorry --non-trivial
lemma new_lemma_110231 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_110232 (h0 : linear_ordered_field (ring num) -> linear_ordered_field (ring num) -> Prop) : is_symm (linear_ordered_field (ring num)) h0 := sorry --non-trivial
lemma new_lemma_110233 (h0 : functor.add_const (ring (add_cancel_monoid Type)) environment.implicit_infer_kind) : @strong_rank_condition.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (add_cancel_monoid.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_110234 (h0 : ring (semigroup (comm_group pos))) : rank_condition (semigroup (comm_group pos)) := sorry --non-trivial
lemma new_lemma_110235 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @add_monoid.fg.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 add_monoid.{1}) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_110236 (h0 : group (comm_semigroup (has_pos_part (ordered_comm_monoid pos)))) : normalizer_condition (comm_semigroup (has_pos_part (ordered_comm_monoid pos))) := sorry --non-trivial
lemma new_lemma_110237 (h0 : topological_space (has_neg (has_add (has_neg Type)))) : path_connected_space (has_neg (has_add (has_neg Type))) := sorry --non-trivial
lemma new_lemma_110238 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_zero.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_110239 (h0 : topological_space (add_cancel_monoid (semigroup environment.implicit_infer_kind))) : totally_disconnected_space (add_cancel_monoid (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_110240 (h0 : functor.comp ring has_zero pos) : @rank_condition.{0} (has_zero.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} has_zero.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_110241 (h0 : add_group (add_comm_monoid Type)) : is_add_cyclic (add_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_110242 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_lattice_add_comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_110243 (h0 : topological_space (dlist (random_gen string_imp))) : path_connected_space (dlist (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_110244 (h0 : ring (distrib (random_gen (random_gen linarith.ineq)))) : rank_condition (distrib (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_110245 (h0 : not (ring (linear_ordered_comm_group_with_zero (random_gen linarith.ineq)) -> false)) : @strong_rank_condition.{0} (linear_ordered_comm_group_with_zero.{0} (random_gen.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_comm_group_with_zero.{0} (random_gen.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_110246 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_110247 (h0 : functor.add_const (topological_space name) (semiring empty)) : @preirreducible_space.{0} name (@functor.add_const.run.{0 0} (topological_space.{0} name) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_110248 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @irreducible_space.{0} (metric_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_110249 (h0 : ring (finset (option ennreal))) : is_principal_ideal_ring (finset (option ennreal)) := sorry --non-trivial
lemma new_lemma_110250 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (ordered_comm_monoid.{1} (ordered_comm_ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_110251 (h0 : group (ordered_comm_ring pos)) : group.fg (ordered_comm_ring pos) := sorry --non-trivial
lemma new_lemma_110252 (h0 : functor.add_const (ordered_add_comm_monoid (add_cancel_comm_monoid empty)) empty) : @archimedean.{0} (add_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (add_cancel_comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_110253 (h0 : functor.add_const (topological_space (partial_order num)) empty) : @locally_compact_space.{0} (partial_order.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_110254 (h0 : functor.add_const (filter (add_cancel_monoid ennreal)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_110255 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_110256 (h0 : topological_space (option ennreal)) : totally_disconnected_space (option ennreal) := sorry --non-trivial
lemma new_lemma_110257 (h0 : group (complete_semilattice_Sup (semiring (semiring unsigned)))) : normalizer_condition (complete_semilattice_Sup (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_110258 (h0 : uniform_space (has_top (has_top (random_gen fun_info)))) : complete_space (has_top (has_top (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_110259 (h0 : functor.add_const (function.extfun (Type 1) group) name) : @group.fg.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) name h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_110260 (h0 : not (function.extfun Type complete_lattice -> false)) : complete_lattice.is_Sup_finite_compact (measurable_space fun_info) := sorry --non-trivial
lemma new_lemma_110261 (h1 : ring (linear_ordered_add_comm_group (has_top to_additive.value_type))) : rank_condition (linear_ordered_add_comm_group (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_110262 (h0 : functor.add_const (topological_space (cancel_monoid empty)) unsigned) : @t0_space.{0} (cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_110263 (h1 : topological_space (linear_ordered_add_comm_group char)) : path_connected_space (linear_ordered_add_comm_group char) := sorry --non-trivial
lemma new_lemma_110264 (h0 : monoid (add_comm_monoid (option (option (option (option (option unsigned))))))) : monoid.fg (add_comm_monoid (option (option (option (option (option unsigned)))))) := sorry --non-trivial
lemma new_lemma_110265 (h0 : topological_space (semigroup name)) : discrete_topology (semigroup name) := sorry --non-trivial
lemma new_lemma_110266 (h0 : add_monoid (ring (finset linarith.comp))) : add_monoid.fg (ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_110267 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring name)) unsigned) : @locally_compact_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_110268 (h0 : functor.add_const (complete_lattice (boolean_algebra.core unsigned)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_110269 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) (has_neg pos)) : @loc_path_connected_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_110270 (h0 : not (topological_space (denumerable char) -> false)) : @path_connected_space.{0} (denumerable.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (denumerable.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_110271 (h0 : functor.add_const (function.extfun (Type 1) semiring) (has_add linarith.comp)) : @is_noetherian_ring.{1} Type (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) semiring.{1}) (has_add.{0} linarith.comp) h0) Type)  := sorry --non-trivial
lemma new_lemma_110272 (h0 : not (topological_space (add_cancel_comm_monoid string.iterator_imp) -> false)) : @t0_space.{0} (add_cancel_comm_monoid.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (add_cancel_comm_monoid.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_110273 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) name) : @preirreducible_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_110274 (h0 : function.extfun nat fin) : @sequential_space.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_110275 (h0 : finset (has_pos_part (has_add Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_110276 (h0 : ordered_comm_monoid (complete_distrib_lattice (has_add pos))) : has_exists_mul_of_le (complete_distrib_lattice (has_add pos)) := sorry --non-trivial
lemma new_lemma_110277 (h0 : functor.add_const (topological_space (id empty)) empty) : @preirreducible_space.{0} (@id.{2} Type empty) (@functor.add_const.run.{0 0} (topological_space.{0} (@id.{2} Type empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_110278 (h0 : complete_lattice (normed_lattice_add_comm_group Type)) : is_compactly_generated (normed_lattice_add_comm_group Type) := sorry --non-trivial
lemma new_lemma_110279 (h0 : functor.add_const (ring (left_cancel_monoid unsigned)) unsigned) : @rank_condition.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_110280 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @regular_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_110281 (h0 : function.extfun nat fin) : preirreducible_space real := sorry --non-trivial
lemma new_lemma_110282 (h0 : add_monoid (boolean_algebra (comm_group (comm_group pos)))) : add_monoid.fg (boolean_algebra (comm_group (comm_group pos))) := sorry --non-trivial
lemma new_lemma_110283 (h0 : topological_space (comm_group (has_to_string pos))) : locally_compact_space (comm_group (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_110284 (h0 : ring (has_Sup (has_ssubset to_additive.value_type))) : strong_rank_condition (has_Sup (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_110285 (h0 : topological_space (has_one (semiring (has_emptyc linarith.comp)))) : totally_separated_space (has_one (semiring (has_emptyc linarith.comp))) := sorry --non-trivial
lemma new_lemma_110286 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_to_string.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_to_string.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_110287 (h0 : ring (linear_ordered_comm_group_with_zero to_additive.value_type)) : strong_rank_condition (linear_ordered_comm_group_with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_110288 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_110289 (h1 : uniform_space (distrib_lattice (with_bot linarith.comp_source))) : complete_space (distrib_lattice (with_bot linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_110290 (h0 : function.extfun (Type 1) uniform_space) : @separated_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_110291 (h0 : function.extfun (finset Type) (has_mem.mem linarith.comp)) : @separated_space.{0} linarith.comp (@finset.pi.empty.{1 0} Type uniform_space.{0} linarith.comp (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_110292 (h0 : ring (comm_semigroup (ordered_comm_monoid real))) : rank_condition (comm_semigroup (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_110293 (h0 : list (cancel_monoid (has_neg pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_110294 (h1 : topological_space (has_norm (has_norm (has_top (has_top fun_info))))) : path_connected_space (has_norm (has_norm (has_top (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_110295 (h0 : ring (has_neg_part (has_to_string (has_neg_part unsigned)))) : is_principal_ideal_ring (has_neg_part (has_to_string (has_neg_part unsigned))) := sorry --non-trivial
lemma new_lemma_110296 (h0 : with_bot (add_group (has_edist (option empty)))) (h1 : ne h0 has_bot.bot) : @is_add_cyclic.{0} (has_edist.{0} (option.{0} empty)) (@with_bot.unbot.{0} (add_group.{0} (has_edist.{0} (option.{0} empty))) h0 h1)  := sorry --non-trivial
lemma new_lemma_110297 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_110298 (h0 : complete_lattice (topological_space string_imp)) : complete_lattice.is_Sup_finite_compact (topological_space string_imp) := sorry --non-trivial
lemma new_lemma_110299 (h0 : topological_space (option congr_arg_kind)) : irreducible_space (option congr_arg_kind) := sorry --non-trivial
lemma new_lemma_110300 (h0 : complete_lattice (denumerable (comm_ring to_additive.value_type))) : is_compactly_generated (denumerable (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_110301 (h0 : nat) (h1 : topological_space (ordered_comm_semiring (nat.partition h0))) : path_connected_space (ordered_comm_semiring (nat.partition h0)) := sorry --non-trivial
lemma new_lemma_110302 (h0 : add_group (complete_semilattice_Sup (has_norm (has_norm fun_info)))) : is_add_cyclic (complete_semilattice_Sup (has_norm (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_110303 (h1 : Prop) : set.finite (id (fun (h0 : string.iterator_imp), h1)) := sorry --non-trivial
lemma new_lemma_110304 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (has_ssubset.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_ssubset.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_110305 (h0 : functor.add_const (add_monoid (has_zero (ring (ring Type)))) (ring (ring Type))) : @add_monoid.fg.{1} (has_zero.{1} (ring.{1} (ring.{1} Type))) (@functor.add_const.run.{1 1} (add_monoid.{1} (has_zero.{1} (ring.{1} (ring.{1} Type)))) (ring.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_110306 (h0 : functor.add_const (list (has_Sup unsigned)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_110307 (h0 : uniform_space (add_cancel_monoid (has_neg (ring Type)))) : complete_space (add_cancel_monoid (has_neg (ring Type))) := sorry --non-trivial
lemma new_lemma_110308 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_110309 (h3 h4 : multiset (nondiscrete_normed_field linarith.ineq)) : multiset.subset h3 h4 := sorry --non-trivial
lemma new_lemma_110310 (h0 : topological_space (has_norm (has_norm linarith.ineq))) : t0_space (has_norm (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_110311 (h0 : functor.add_const (functor.add_const (complete_lattice unsigned) Type) name) : @is_compactly_generated.{0} unsigned (@functor.add_const.run.{0 1} (complete_lattice.{0} unsigned) Type (@functor.add_const.run.{0 0} (functor.add_const.{0 1} (complete_lattice.{0} unsigned) Type) name h0))  := sorry --non-trivial
lemma new_lemma_110312 (h0 : functor.add_const (ordered_add_comm_monoid (complete_distrib_lattice num)) num) : @archimedean.{0} (complete_distrib_lattice.{0} num) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (complete_distrib_lattice.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_110313 (h0 : ring (topological_space to_additive.value_type)) : rank_condition (topological_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_110314 (h0 : functor.add_const (uniform_space (has_to_string Type)) linarith.comp) : @separated_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_to_string.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_110315 (h0 : complete_lattice (normed_field (mul_one_class linarith.ineq))) : complete_lattice.is_Sup_finite_compact (normed_field (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_110316 (h0 : functor.add_const (ring (has_neg_part Type)) linarith.comp) : @strong_rank_condition.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_neg_part.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_110317 (h0 : functor.add_const (topological_space (boolean_algebra pos)) linarith.comp) : @sequential_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_110318 (h0 : function.extfun Type (prod (comm_group ennreal))) : id_rel (function.extfun_app h0 (comm_group ennreal)) := sorry --non-trivial
lemma new_lemma_110319 (h0 : functor.add_const (function.extfun Type complete_lattice) (has_Inf linarith.comp)) : @complete_lattice.is_Sup_finite_compact.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) (has_Inf.{0} linarith.comp) h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_110320 (h0 : functor.add_const (complete_lattice (semigroup name)) (comm_group Type)) : @complete_lattice.is_Sup_finite_compact.{0} (semigroup.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (semigroup.{0} name)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_110321 (h0 : ring (normed_field (mul_one_class fun_info))) : strong_rank_condition (normed_field (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_110322 (h0 : functor.add_const (ring (ring pos)) (ring (ring Type))) : @rank_condition.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (ring.{0} pos)) (ring.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_110323 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (has_bot.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_110324 (h0 : functor.add_const (ordered_add_comm_monoid (has_add name)) pos) : @archimedean.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_add.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_110325 (h0 : function.extfun Type (functor.comp uniform_space has_nndist)) : @complete_space.{0} (has_nndist.{0} ennreal) (@functor.comp.run.{0 0 0} uniform_space.{0} has_nndist.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} uniform_space.{0} has_nndist.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_110326 (h0 : has_neg (semi_normed_comm_ring (normed_field reducibility_hints))) (h1 : measurable_space (semi_normed_comm_ring (normed_field reducibility_hints))) : has_measurable_neg (semi_normed_comm_ring (normed_field reducibility_hints)) := sorry --non-trivial
lemma new_lemma_110327 (h0 : not (semiring (add_group empty) -> false)) : @is_noetherian_ring.{0} (add_group.{0} empty) (@classical.by_contradiction'.{1} (semiring.{0} (add_group.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_110328 (h0 : not (group (linear_ordered_add_comm_group char) -> false)) : @group.fg.{0} (linear_ordered_add_comm_group.{0} char) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_add_comm_group.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_110329 (h0 : list (linear_ordered_comm_monoid_with_zero (option (option unsigned)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_110330 (h0 : set (nondiscrete_normed_field (add_comm_semigroup linarith.ineq) -> std_gen)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_110331 (h0 : topological_space (has_neg num)) : discrete_topology (has_neg num) := sorry --non-trivial
lemma new_lemma_110332 (h0 : uniform_space (has_neg (finset name))) : separated_space (has_neg (finset name)) := sorry --non-trivial
lemma new_lemma_110333 (h0 : ring (semigroup (ring (has_add ennreal)))) : strong_rank_condition (semigroup (ring (has_add ennreal))) := sorry --non-trivial
lemma new_lemma_110334 (h0 : list (id linarith.ineq)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_110335 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} string_imp (@function.extfun_app.{2 1} Type topological_space.{0} h0 string_imp)  := sorry --non-trivial
lemma new_lemma_110336 (h0 : functor.comp add_monoid ring pos) : @add_monoid.fg.{0} (ring.{0} pos) (@functor.comp.run.{0 0 0} add_monoid.{0} ring.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_110337 (h0 : set (has_nnnorm std_gen)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_110338 (h0 : measurable_space (comm_ring linarith.comp_source)) (h1 : has_sub (comm_ring linarith.comp_source)) : has_measurable_sub₂ (comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_110339 (h0 : ring (has_neg_part (finset (has_nndist pos)))) : rank_condition (has_neg_part (finset (has_nndist pos))) := sorry --non-trivial
lemma new_lemma_110340 (h0 : ring (has_pos_part (sub_neg_monoid pos))) : rank_condition (has_pos_part (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_110341 (h0 : not (add_group (has_nnnorm char) -> false)) : @is_add_cyclic.{0} (has_nnnorm.{0} char) (@classical.by_contradiction'.{1} (add_group.{0} (has_nnnorm.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_110342 (h0 : not (prod (linear_ordered_comm_ring empty) (linear_ordered_comm_ring empty) -> false)) : id_rel (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_110343 (h0 : ring (monoid (option (option (option (option ennreal)))))) : is_domain (monoid (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_110344 (h0 : monoid (has_nndist (has_to_string (finset pos)))) : monoid.fg (has_nndist (has_to_string (finset pos))) := sorry --non-trivial
lemma new_lemma_110345 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_110346 (h0 : list (linear_ordered_semiring congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_110347 (h0 : complete_lattice (random_gen (random_gen (uniform_space string.iterator_imp)))) : is_compactly_generated (random_gen (random_gen (uniform_space string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_110348 (h0 : monoid (ordered_comm_monoid (has_add real))) : monoid.fg (ordered_comm_monoid (has_add real)) := sorry --non-trivial
lemma new_lemma_110349 (h0 : topological_space (has_zero (boolean_algebra pos))) : normal_space (has_zero (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_110350 (h0 : functor.add_const (topological_space (has_Inf Type)) (finset pos)) : @preirreducible_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_Inf.{1} Type)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_110351 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (has_sub.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_sub.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_110352 (h0 : set string.iterator) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_110353 (h0 : topological_space (ring linarith.comp)) : t0_space (ring linarith.comp) := sorry --non-trivial
lemma new_lemma_110354 (h0 : functor.add_const (topological_space (finset pos)) (has_Inf linarith.comp)) : @locally_compact_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_110355 (h0 : group (canonically_ordered_comm_semiring (has_add (has_add (has_add Type))))) : is_simple_group (canonically_ordered_comm_semiring (has_add (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_110356 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_inter.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_110357 (h0 : group (ordered_ring unsigned)) : group.fg (ordered_ring unsigned) := sorry --non-trivial
lemma new_lemma_110358 (h0 : ring (has_to_string (monoid_with_zero linarith.comp))) : strong_rank_condition (has_to_string (monoid_with_zero linarith.comp)) := sorry --non-trivial
lemma new_lemma_110359 (h0 : functor.add_const (ordered_add_comm_monoid (is_R_or_C empty)) unsigned) : @archimedean.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (is_R_or_C.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_110360 (h0 : topological_space (semigroup (has_to_string (has_to_string pos)))) : preirreducible_space (semigroup (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_110361 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (pseudo_metric_space unsigned)) := sorry --non-trivial
lemma new_lemma_110362 (h0 : group (semigroup (finset linarith.comp))) : normalizer_condition (semigroup (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_110363 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_110364 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_110365 (h1 : topological_space (has_emptyc congr_arg_kind)) : irreducible_space (has_emptyc congr_arg_kind) := sorry --non-trivial
lemma new_lemma_110366 (h0 : topological_space (normed_linear_ordered_group (semiring (semiring (semiring (semiring empty)))))) : preirreducible_space (normed_linear_ordered_group (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_110367 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (omega_complete_partial_order.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (omega_complete_partial_order.{0} num))  := sorry --non-trivial
lemma new_lemma_110368 (h0 : list (measurable_space.dynkin_system (semiring (semiring empty)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_110369 (h0 : topological_space (normed_group (has_norm linarith.comp))) : irreducible_space (normed_group (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_110370 (h0 : Prop -> fun_info) (h2 : coe_sort (set.range h0)) : set.range_splitting h0 h2 := sorry --non-trivial
lemma new_lemma_110371 (h0 : functor.comp topological_space ring Type) : @irreducible_space.{1} (ring.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} ring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_110372 (h0 : monoid (partial_order (semiring (semiring congr_arg_kind)))) : monoid.fg (partial_order (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_110373 (h0 : topological_space (boolean_algebra (boolean_algebra.core pos))) : t1_space (boolean_algebra (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_110374 (h0 : uniform_space (distrib (denumerable reducibility_hints))) : complete_space (distrib (denumerable reducibility_hints)) := sorry --non-trivial
lemma new_lemma_110375 (h0 : complete_lattice (has_le linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (has_le linarith.comp_source) := sorry --non-trivial
lemma new_lemma_110376 (h0 : ring (has_bot (has_Inf pos))) : rank_condition (has_bot (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_110377 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group congr_arg_kind))) : @monoid.fg.{0} (normed_group.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type monoid.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_110378 (h0 : topological_space (omega_complete_partial_order congr_arg_kind)) : discrete_topology (omega_complete_partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_110379 (h0 : uniform_space (comm_group environment.implicit_infer_kind)) : separated_space (comm_group environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_110380 (h0 : list (comm_ring (random_gen (has_ssubset to_additive.value_type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_110381 (h1 : filter (random_gen fun_info)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_110382 (h0 : functor.add_const (topological_space (complete_distrib_lattice empty)) empty) : @t0_space.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_110383 (h0 : function.extfun Type (functor.add_const (topological_space pos))) : @t0_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) ennreal (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} pos)) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_110384 (h0 : topological_space (ordered_comm_ring (has_add (has_add (has_add real))))) : t1_space (ordered_comm_ring (has_add (has_add (has_add real)))) := sorry --non-trivial
lemma new_lemma_110385 (h0 : topological_space (ring (finset (ring (boolean_algebra linarith.comp))))) : totally_separated_space (ring (finset (ring (boolean_algebra linarith.comp)))) := sorry --non-trivial
lemma new_lemma_110386 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_edist empty)) := sorry --non-trivial
lemma new_lemma_110387 (h0 : prod (option (semiring empty)) (option (semiring empty))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_110388 (h0 : topological_space (has_add (ring (ring Type)))) : preconnected_space (has_add (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_110389 (h0 : ring (simple_graph string_imp)) : is_domain (simple_graph string_imp) := sorry --non-trivial
lemma new_lemma_110390 (h0 : functor.add_const (list (boolean_algebra name)) environment.implicit_infer_kind) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_110391 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (linear_ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_110392 (h0 : filter (has_emptyc (has_inv to_additive.value_type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_110393 (h0 h1 : multiset (mul_one_class string_imp)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_110394 (h0 : ring (has_to_string (ring (ring (has_inter linarith.comp))))) : is_principal_ideal_ring (has_to_string (ring (ring (has_inter linarith.comp)))) := sorry --non-trivial
lemma new_lemma_110395 (h1 : topological_space (metric_space (random_gen to_additive.value_type))) : locally_compact_space (metric_space (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_110396 (h1 : topological_space (id (random_gen string_imp))) : totally_disconnected_space (id (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_110397 (h1 : topological_space (topological_space (has_nnnorm reducibility_hints))) : totally_disconnected_space (topological_space (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_110398 (h0 : topological_space (finset (mul_one_class Type))) : preirreducible_space (finset (mul_one_class Type)) := sorry --non-trivial
lemma new_lemma_110399 (h0 : functor.add_const (filter (option num)) empty) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_110400 (h0 : topological_space (semigroup num)) : preirreducible_space (semigroup num) := sorry --non-trivial
lemma new_lemma_110401 (h0 : functor.add_const (topological_space (has_Inf Type)) Type) : @totally_disconnected_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_Inf.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_110402 (h0 : fin has_zero.zero) : @regular_space.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (simple_graph.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_110403 (h0 : functor.add_const (group (complete_distrib_lattice empty)) empty) : @group.fg.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_110404 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (bin_tree.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (bin_tree.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_110405 (h0 : filter (ordered_cancel_add_comm_monoid congr_arg_kind)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_110406 (h0 : not (function.extfun Type topological_space -> false)) : irreducible_space real := sorry --non-trivial
lemma new_lemma_110407 (h0 : functor.add_const (finset (finset environment.implicit_infer_kind)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_110408 (h0 : group (boolean_algebra.core (has_add pos))) : is_simple_group (boolean_algebra.core (has_add pos)) := sorry --non-trivial
lemma new_lemma_110409 (h0 : topological_space (complete_semilattice_Sup to_additive.value_type)) : irreducible_space (complete_semilattice_Sup to_additive.value_type) := sorry --non-trivial
lemma new_lemma_110410 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (measure_theory.measure_space.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (measure_theory.measure_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_110411 (h0 : list (finset (has_neg ennreal))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_110412 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_110413 (h0 : topological_space (mul_zero_class unsigned)) : path_connected_space (mul_zero_class unsigned) := sorry --non-trivial
lemma new_lemma_110414 (h0 : complete_lattice (boolean_algebra (boolean_algebra.core environment.implicit_infer_kind))) : is_compactly_generated (boolean_algebra (boolean_algebra.core environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_110415 (h0 : topological_space (ring (finset unsigned))) : locally_compact_space (ring (finset unsigned)) := sorry --non-trivial
lemma new_lemma_110416 (h0 : ring (has_ssubset (add_comm_semigroup (mul_one_class fun_info)))) : is_domain (has_ssubset (add_comm_semigroup (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_110417 (h0 : has_lt (simple_graph linarith.ineq)) : no_max_order (simple_graph linarith.ineq) := sorry --non-trivial
lemma new_lemma_110418 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) (option pos)) : @sequential_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} pos)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_110419 (h0 : uniform_space (comm_group (finset linarith.comp))) : complete_space (comm_group (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_110420 (h0 : function.extfun Type topological_space) : @t0_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_110421 (h0 : functor.add_const (group (has_add name)) linarith.comp) : @is_simple_group.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_110422 (h0 : functor.add_const (topological_space (has_pos_part Type)) name) : @totally_separated_space.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_pos_part.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_110423 (h0 : function.extfun Type ring) : @is_domain.{0} (normed_lattice_add_comm_group.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_lattice_add_comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_110424 (h0 : uniform_space (measurable_space (semiring congr_arg_kind))) : separated_space (measurable_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_110425 (h0 : monoid (with_bot (has_top linarith.comp_source))) : monoid.fg (with_bot (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_110426 (h0 : semiring num -> semiring num -> Prop) : is_strict_order (semiring num) h0 := sorry --non-trivial
lemma new_lemma_110427 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) pos) : @totally_separated_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_110428 (h3 : topological_space (linear_ordered_comm_group_with_zero to_additive.value_type)) : totally_disconnected_space (linear_ordered_comm_group_with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_110429 (h0 : functor.add_const (group (boolean_algebra environment.implicit_infer_kind)) linarith.comp) : @is_cyclic.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_110430 (h0 : functor.add_const (topological_space (measure_theory.measure_space num)) empty) : @discrete_topology.{0} (measure_theory.measure_space.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (measure_theory.measure_space.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_110431 (h0 : set (has_compl (mul_one_class (mul_one_class ereal)))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_110432 (h0 : list (semigroup pos)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_110433 (h0 : function.extfun Type group) : @normalizer_condition.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_110434 (h0 : functor.comp topological_space boolean_algebra.core pos) : @t0_space.{0} (boolean_algebra.core.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.core.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_110435 (h0 : ring (comm_semigroup (has_add (has_Inf (sub_neg_monoid real))))) : is_principal_ideal_ring (comm_semigroup (has_add (has_Inf (sub_neg_monoid real)))) := sorry --non-trivial
lemma new_lemma_110436 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @preirreducible_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_110437 (h0 : functor.add_const (ring (finset ennreal)) name) : @strong_rank_condition.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_110438 (h0 : function.extfun Type (functor.comp group mul_zero_class)) : @group.fg.{0} (mul_zero_class.{0} unsigned) (@functor.comp.run.{0 0 0} group.{0} mul_zero_class.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} group.{0} mul_zero_class.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_110439 (h0 : monoid (complete_semilattice_Sup (semiring (semiring num)))) : monoid.fg (complete_semilattice_Sup (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_110440 (h0 : complete_lattice (has_neg_part (comm_group unsigned))) : is_atomistic (has_neg_part (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_110441 (h0 : topological_space (with_bot (has_top linarith.ineq))) : t0_space (with_bot (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_110442 (h0 : complete_lattice (ring pos)) : complete_lattice.is_Sup_finite_compact (ring pos) := sorry --non-trivial
lemma new_lemma_110443 (h0 : functor.add_const (topological_space (has_to_string name)) (ring environment.implicit_infer_kind)) : @totally_disconnected_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_110444 (h0 : finset (left_cancel_semigroup (semiring (semiring (semiring empty))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_110445 (h0 : topological_space (random_gen (random_gen (random_gen (random_gen linarith.comp_source))))) : totally_disconnected_space (random_gen (random_gen (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_110446 (h0 : functor.add_const (ordered_comm_monoid (has_nndist pos)) (ring Type)) : @has_exists_mul_of_le.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (has_nndist.{0} pos)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_110447 (h0 : cancel_comm_monoid_with_zero (semigroup (option (option name)))) : unique_factorization_monoid (semigroup (option (option name))) := sorry --non-trivial
lemma new_lemma_110448 (h0 : functor.add_const (cancel_comm_monoid_with_zero (generalized_boolean_algebra Type)) (has_pos_part linarith.comp)) : @unique_factorization_monoid.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (generalized_boolean_algebra.{1} Type)) (has_pos_part.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_110449 (h0 : topological_space (canonically_ordered_monoid (has_Inf Type))) : locally_compact_space (canonically_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_110450 (h0 : functor.add_const (ring pos) pos) : @is_domain.{0} pos (@functor.add_const.run.{0 0} (ring.{0} pos) pos h0)  := sorry --non-trivial
lemma new_lemma_110451 (h0 : functor.add_const (topological_space (linear_ordered_comm_monoid_with_zero empty)) num) : @totally_separated_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_110452 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) linarith.comp) : @sequential_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_110453 (h0 : group (has_nndist (has_add linarith.comp))) : normalizer_condition (has_nndist (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_110454 (h0 : group (add_comm_monoid (has_to_string (comm_group unsigned)))) : group.fg (add_comm_monoid (has_to_string (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_110455 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : complete_lattice.is_Sup_finite_compact (measurable_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_110456 (h0 : topological_space (has_emptyc (random_gen (random_gen (random_gen to_additive.value_type))))) : t0_space (has_emptyc (random_gen (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_110457 (h0 : group (has_inv linarith.ineq)) : is_cyclic (has_inv linarith.ineq) := sorry --non-trivial
lemma new_lemma_110458 (h2 : set (has_div linarith.comp_source)) : set.subsingleton h2 := sorry --non-trivial
lemma new_lemma_110459 (h0 : uniform_space (comm_group ennreal)) : separated_space (comm_group ennreal) := sorry --non-trivial
lemma new_lemma_110460 (h0 : topological_space (has_nnnorm (has_nnnorm (random_gen (random_gen char))))) : totally_disconnected_space (has_nnnorm (has_nnnorm (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_110461 (h0 : set (string.iterator_imp -> add_comm_semigroup linarith.ineq)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_110462 (h0 : ring (boolean_algebra (comm_group pos))) : strong_rank_condition (boolean_algebra (comm_group pos)) := sorry --non-trivial
lemma new_lemma_110463 (h0 : functor.add_const (ring (has_nndist Type)) Type) : @is_principal_ideal_ring.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (has_nndist.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_110464 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (add_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (add_group.{0} num))  := sorry --non-trivial
lemma new_lemma_110465 (h0 : finset (linear_ordered_comm_group (semiring empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_110466 (h0 : functor.add_const (functor.add_const (topological_space Type) linarith.comp) linarith.comp) : @sequential_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) linarith.comp (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (topological_space.{1} Type) linarith.comp) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_110467 (h0 : topological_space (comm_group (comm_group unsigned))) : loc_path_connected_space (comm_group (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_110468 (h0 : topological_space (has_nndist (has_neg_part (finset environment.implicit_infer_kind)))) : irreducible_space (has_nndist (has_neg_part (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_110469 (h0 : ring (boolean_algebra.core (mul_one_class linarith.ineq))) : is_domain (boolean_algebra.core (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_110470 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_noetherian_ring.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) semiring.{0}) (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_110471 (h1 : add_group (fintype fun_info)) : is_add_cyclic (fintype fun_info) := sorry --non-trivial
lemma new_lemma_110472 (h0 : functor.add_const (filter (semigroup ennreal)) ennreal) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_110473 (h0 : uniform_space (has_neg pos)) : separated_space (has_neg pos) := sorry --non-trivial
lemma new_lemma_110474 (h0 : ring (random_gen (has_norm empty))) : rank_condition (random_gen (has_norm empty)) := sorry --non-trivial
lemma new_lemma_110475 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (ring.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_110476 (h0 : function.extfun nat fin) : @is_add_cyclic.{0} (add_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (add_group.{0} (add_comm_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_110477 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_110478 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_110479 (h0 : uniform_space (ring (has_Inf linarith.comp))) : complete_space (ring (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_110480 (h0 : function.extfun Type group) : @is_cyclic.{0} linarith.comp_source (@function.extfun_app.{2 1} Type group.{0} h0 linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_110481 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_110482 (h0 : topological_space (linear_ordered_add_comm_group (has_top (random_gen (has_top linarith.ineq))))) : irreducible_space (linear_ordered_add_comm_group (has_top (random_gen (has_top linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_110483 (h2 : not (topological_space (denumerable to_additive.value_type) -> false)) : @t0_space.{0} (denumerable.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (denumerable.{0} to_additive.value_type)) h2)  := sorry --non-trivial
lemma new_lemma_110484 (h0 : group (random_gen (semiring linarith.comp))) : group.fg (random_gen (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_110485 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (boolean_algebra.core.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (boolean_algebra.core.{0} empty))  := sorry --non-trivial
lemma new_lemma_110486 (h0 : functor.add_const (function.extfun Type topological_space) (has_add name)) : @locally_compact_space.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_add.{0} name) h0) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_110487 (h1 : topological_space (add_comm_semigroup string.iterator_imp)) (h2 : add_group (add_comm_semigroup string.iterator_imp)) : topological_add_group (add_comm_semigroup string.iterator_imp) := sorry --non-trivial
lemma new_lemma_110488 (h0 : functor.add_const (topological_space (option empty)) empty) : @normal_space.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_110489 (h0 : topological_space (ring (ordered_ring (ring name)))) : locally_compact_space (ring (ordered_ring (ring name))) := sorry --non-trivial
lemma new_lemma_110490 (h0 : measurable_space ereal) (h1 : measure_theory.measure ereal) : measure_theory.sigma_finite h1 := sorry --non-trivial
lemma new_lemma_110491 (h0 : not (topological_space (normed_group linarith.comp) -> false)) : @irreducible_space.{0} (normed_group.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_110492 (h0 : topological_space (is_R_or_C linarith.ineq)) : t0_space (is_R_or_C linarith.ineq) := sorry --non-trivial
lemma new_lemma_110493 (h0 : functor.add_const (cancel_comm_monoid_with_zero (finset linarith.comp)) (has_neg linarith.comp)) : @unique_factorization_monoid.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (finset.{0} linarith.comp)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_110494 (h0 : topological_space (add_comm_monoid (ring pos))) : normal_space (add_comm_monoid (ring pos)) := sorry --non-trivial
lemma new_lemma_110495 (h1 : ring (order_dual char)) : is_domain (order_dual char) := sorry --non-trivial
lemma new_lemma_110496 (h0 : topological_space (random_gen (random_gen (comm_ring fun_info)))) : t0_space (random_gen (random_gen (comm_ring fun_info))) := sorry --non-trivial
lemma new_lemma_110497 (h0 : functor.add_const (ring (canonically_linear_ordered_monoid pos)) ennreal) : @is_principal_ideal_ring.{0} (canonically_linear_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (canonically_linear_ordered_monoid.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_110498 (h0 : filter (cancel_monoid (has_to_string (has_to_string ennreal)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_110499 (h0 : ring (add_comm_semigroup (has_le char))) : is_domain (add_comm_semigroup (has_le char)) := sorry --non-trivial
lemma new_lemma_110500 (h0 : topological_space (complete_semilattice_Sup (has_norm linarith.comp))) : t0_space (complete_semilattice_Sup (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_110501 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @add_monoid.fg.{1} Type (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 add_monoid.{1}) Type)  := sorry --non-trivial
lemma new_lemma_110502 (h0 : functor.add_const (group (normed_comm_ring name)) linarith.comp) : @group.fg.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_110503 (h1 : add_group char) : is_add_cyclic char := sorry --non-trivial
lemma new_lemma_110504 (h0 : topological_space (has_to_string (option empty))) : t0_space (has_to_string (option empty)) := sorry --non-trivial
lemma new_lemma_110505 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (free_add_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (free_add_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_110506 (h0 : functor.add_const (ring (has_neg_part Type)) name) : @strong_rank_condition.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_neg_part.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_110507 (h0 : not (ring (random_gen enat) -> false)) : @rank_condition.{0} (random_gen.{0} enat) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} enat)) h0)  := sorry --non-trivial
lemma new_lemma_110508 (h0 : uniform_space (simple_graph (has_add name))) : separated_space (simple_graph (has_add name)) := sorry --non-trivial
lemma new_lemma_110509 (h0 : functor.comp topological_space canonically_ordered_comm_semiring Type) : @irreducible_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} canonically_ordered_comm_semiring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_110510 (h0 : functor.add_const (group (comm_group pos)) pos) : @is_simple_group.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_110511 (h0 : ring (complete_semilattice_Sup (semiring empty))) : is_domain (complete_semilattice_Sup (semiring empty)) := sorry --non-trivial
lemma new_lemma_110512 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) linarith.comp) : @path_connected_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (normed_comm_ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_110513 (h0 : functor.add_const (ring (ring linarith.comp)) linarith.comp) : @strong_rank_condition.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_110514 (h0 : uniform_space (linear_ordered_comm_ring unsigned)) : complete_space (linear_ordered_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_110515 (h0 : topological_space (distrib (random_gen (semi_normed_ring linarith.comp_source)))) : t0_space (distrib (random_gen (semi_normed_ring linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_110516 (h0 : topological_space (has_inner unsigned (option unsigned))) : path_connected_space (has_inner unsigned (option unsigned)) := sorry --non-trivial
lemma new_lemma_110517 (h0 : functor.add_const (list (semigroup Type)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_110518 (h0 : topological_space (add_group (semiring (has_norm linarith.comp)))) : normal_space (add_group (semiring (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_110519 (h0 : uniform_space (boolean_algebra.core (has_neg_part linarith.comp))) : separated_space (boolean_algebra.core (has_neg_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_110520 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_110521 (h0 : add_monoid (has_zero (option pos))) : add_monoid.fg (has_zero (option pos)) := sorry --non-trivial
lemma new_lemma_110522 (h0 : group (with_one (random_gen (random_gen to_additive.value_type)))) : normalizer_condition (with_one (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_110523 (h0 : topological_space (boolean_algebra (has_add (add_comm_monoid pos)))) : preirreducible_space (boolean_algebra (has_add (add_comm_monoid pos))) := sorry --non-trivial
lemma new_lemma_110524 (h0 : topological_space (plift (add_group num))) : totally_separated_space (plift (add_group num)) := sorry --non-trivial
lemma new_lemma_110525 (h0 : not (ring (random_gen string.iterator_imp) -> false)) : @is_domain.{0} (random_gen.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_110526 (h0 : uniform_space (monoid_with_zero pos)) : complete_space (monoid_with_zero pos) := sorry --non-trivial
lemma new_lemma_110527 (h0 : functor.add_const (topological_space (boolean_algebra Type)) (finset pos)) : @preconnected_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_110528 (h0 : functor.add_const (topological_space pos) name) : @normal_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) name h0)  := sorry --non-trivial
lemma new_lemma_110529 (h0 : ring (has_dist (option ennreal))) : strong_rank_condition (has_dist (option ennreal)) := sorry --non-trivial
lemma new_lemma_110530 (h0 : functor.add_const (function.extfun (Type 1) ring) linarith.comp) : @strong_rank_condition.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) linarith.comp h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_110531 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) pos) : @preconnected_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_110532 (h0 : filter (has_nnnorm linarith.comp_source)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_110533 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_110534 (h0 : topological_space (sub_neg_monoid real)) : topological_space.separable_space (sub_neg_monoid real) := sorry --non-trivial
lemma new_lemma_110535 (h1 : topological_space (add_comm_semigroup environment.projection_info)) (h2 : add_group (add_comm_semigroup environment.projection_info)) : topological_add_group (add_comm_semigroup environment.projection_info) := sorry --non-trivial
lemma new_lemma_110536 (h0 : complete_lattice (omega_complete_partial_order empty)) : complete_lattice.is_Sup_finite_compact (omega_complete_partial_order empty) := sorry --non-trivial
lemma new_lemma_110537 (h0 : functor.add_const (filter (has_add pos)) (has_add (ring (mul_one_class Type)))) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_110538 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_110539 (h0 : functor.add_const (topological_space (has_neg pos)) (ring Type)) : @locally_compact_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} pos)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_110540 (h0 : add_group (normed_field (normed_field char))) : is_add_cyclic (normed_field (normed_field char)) := sorry --non-trivial
lemma new_lemma_110541 (h0 : not (ring (encodable linarith.comp_source) -> false)) : @strong_rank_condition.{0} (encodable.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (encodable.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_110542 (h0 : topological_space (finset (ring linarith.comp))) : path_connected_space (finset (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_110543 (h0 : not (group (has_union linarith.comp) -> false)) : @normalizer_condition.{0} (has_union.{0} linarith.comp) (@classical.by_contradiction'.{1} (group.{0} (has_union.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_110544 (h0 : complete_lattice (random_gen (has_norm fun_info))) : is_atomistic (random_gen (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_110545 (h0 : function.extfun Type ring) : @is_domain.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_110546 (h0 : fin has_zero.zero) : matrix.vec_empty (id (id h0)) := sorry --non-trivial
lemma new_lemma_110547 (h0 : topological_space (ordered_cancel_add_comm_monoid empty)) : locally_compact_space (ordered_cancel_add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_110548 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_110549 (h0 : topological_space (normed_comm_ring (add_comm_monoid Type))) : totally_separated_space (normed_comm_ring (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_110550 (h0 : topological_space (measurable_space unsigned)) : normal_space (measurable_space unsigned) := sorry --non-trivial
lemma new_lemma_110551 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) linarith.comp) : @totally_disconnected_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_110552 (h1 : not (filter (linear_ordered_add_comm_group fun_info) -> false)) : filter.ne_bot (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_110553 (h0 : monoid (random_gen string_imp)) (h1 : topological_space (topological_space (associates (random_gen string_imp)))) : path_connected_space (topological_space (associates (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_110554 (h0 : prod (pseudo_metric_space (option ennreal)) (pseudo_metric_space (option ennreal))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_110555 (h0 : ring (measurable_space (has_union (has_union linarith.comp)))) : strong_rank_condition (measurable_space (has_union (has_union linarith.comp))) := sorry --non-trivial
lemma new_lemma_110556 (h0 : topological_space (comm_group unsigned)) : totally_separated_space (comm_group unsigned) := sorry --non-trivial
lemma new_lemma_110557 (h0 : functor.add_const (topological_space (semigroup Type)) (has_neg pos)) : @preirreducible_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_110558 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (measurable_space linarith.comp)) := sorry --non-trivial
lemma new_lemma_110559 (h0 : list (normed_comm_ring linarith.comp)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_110560 (h0 : group (has_one (has_norm (has_norm fun_info)))) : normalizer_condition (has_one (has_norm (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_110561 (h0 : functor.add_const (function.extfun (Type 1) filter) (ring (ring (finset pos)))) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_110562 (h0 : ring (add_comm_monoid (has_add (has_add name)))) : strong_rank_condition (add_comm_monoid (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_110563 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_top (has_inv string_imp))) := sorry --non-trivial
lemma new_lemma_110564 (h0 : functor.add_const (topological_space (has_pos_part pos)) (has_neg (has_neg name))) : @locally_compact_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) (has_neg.{0} (has_neg.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_110565 (h0 : group (canonically_ordered_monoid (sub_neg_monoid Type))) : normalizer_condition (canonically_ordered_monoid (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_110566 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @complete_space.{0} (sub_neg_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (uniform_space.{0} (sub_neg_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_110567 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_110568 (h0 : cancel_comm_monoid_with_zero (ordered_cancel_add_comm_monoid (option num))) : unique_factorization_monoid (ordered_cancel_add_comm_monoid (option num)) := sorry --non-trivial
lemma new_lemma_110569 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_110570 (h0 : group (boolean_algebra (has_Inf (has_pos_part (has_Inf Type))))) : group.fg (boolean_algebra (has_Inf (has_pos_part (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_110571 (h0 : ring (comm_ring string.iterator_imp)) : rank_condition (comm_ring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_110572 (h0 : topological_space (has_emptyc (normed_group (random_gen linarith.comp_source)))) : totally_disconnected_space (has_emptyc (normed_group (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_110573 (h0 : functor.add_const (functor.add_const (monoid znum) unsigned) (option unsigned)) : @monoid.fg.{0} znum (@functor.add_const.run.{0 0} (monoid.{0} znum) unsigned (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (monoid.{0} znum) unsigned) (option.{0} unsigned) h0))  := sorry --non-trivial
lemma new_lemma_110574 (h0 : topological_space (ordered_comm_monoid (has_pos_part pos))) : sequential_space (ordered_comm_monoid (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_110575 (h0 : not (has_mem.mem group has_emptyc.emptyc -> false)) : @is_cyclic.{0} congr_arg_kind (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_110576 (h0 : topological_space (with_bot (semiring (has_top empty)))) : normal_space (with_bot (semiring (has_top empty))) := sorry --non-trivial
lemma new_lemma_110577 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_110578 (h0 : functor.add_const (topological_space (has_star num)) empty) : @path_connected_space.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_110579 (h1 : uniform_space (distrib (has_nnnorm (has_ssubset (has_ssubset (has_ssubset char)))))) : complete_space (distrib (has_nnnorm (has_ssubset (has_ssubset (has_ssubset char))))) := sorry --non-trivial
lemma new_lemma_110580 (h0 : topological_space (with_bot fun_info)) : totally_disconnected_space (with_bot fun_info) := sorry --non-trivial
lemma new_lemma_110581 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (topological_space.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (topological_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_110582 (h0 : ring (monoid ennreal)) : is_principal_ideal_ring (monoid ennreal) := sorry --non-trivial
lemma new_lemma_110583 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_noetherian_ring.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) semiring.{0}) (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_110584 (h0 : list (left_cancel_semigroup (semiring (semiring (semiring (semiring unsigned)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_110585 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) name) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) name h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_110586 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (left_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (left_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_110587 (h0 : ring (has_inv linarith.ineq)) : rank_condition (has_inv linarith.ineq) := sorry --non-trivial
lemma new_lemma_110588 (h0 : has_mem.mem real.angle has_emptyc.emptyc) : @is_domain.{0} real.angle (@finset.pi.empty.{1 0} Type ring.{0} real.angle h0)  := sorry --non-trivial
lemma new_lemma_110589 (h0 : functor.add_const (ring (add_cancel_monoid Type)) (has_neg linarith.comp)) : @is_domain.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (add_cancel_monoid.{1} Type)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_110590 (h0 : functor.add_const (topological_space (has_add ennreal)) unsigned) : @normal_space.{0} (has_add.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_110591 (h0 : topological_space (add_cancel_monoid (comm_group pos))) : regular_space (add_cancel_monoid (comm_group pos)) := sorry --non-trivial
lemma new_lemma_110592 (h0 : uniform_space (has_nndist (add_cancel_monoid name))) : complete_space (has_nndist (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_110593 (h0 : ring (has_nnnorm linarith.ineq)) : strong_rank_condition (has_nnnorm linarith.ineq) := sorry --non-trivial
lemma new_lemma_110594 (h0 : add_group (ordered_cancel_add_comm_monoid (option (option ennreal)))) : is_add_cyclic (ordered_cancel_add_comm_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_110595 (h0 : topological_space (add_cancel_monoid (has_neg Type))) : totally_separated_space (add_cancel_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_110596 (h0 : functor.add_const (complete_lattice (has_add pos)) Type) : @is_atomistic.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_add.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_110597 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_lt unsigned)) := sorry --non-trivial
lemma new_lemma_110598 (h0 : finset (add_cancel_monoid (option empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_110599 (h0 : topological_space (has_pos_part (has_add pos))) : irreducible_space (has_pos_part (has_add pos)) := sorry --non-trivial
lemma new_lemma_110600 (h0 : has_le ereal) (h1 : ereal) : is_max h1 := sorry --non-trivial
lemma new_lemma_110601 (h0 : functor.add_const (add_group (has_add Type)) pos) : @is_add_cyclic.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (has_add.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_110602 (h0 : filter (mul_zero_class (semiring (semiring congr_arg_kind)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_110603 (h0 : filter (semigroup (ring environment.implicit_infer_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_110604 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_110605 (h0 : functor.add_const (topological_space (has_dist unsigned)) ennreal) : @totally_separated_space.{0} (has_dist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} unsigned)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_110606 (h0 : not (topological_space (metric_space num) -> false)) : @totally_disconnected_space.{0} (metric_space.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_110607 (h0 : topological_space (add_comm_monoid (has_add name))) : path_connected_space (add_comm_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_110608 (h1 : ring (has_compl (has_nnnorm (has_nnnorm (has_nnnorm char))))) : rank_condition (has_compl (has_nnnorm (has_nnnorm (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_110609 (h0 : function.extfun Type group) : @group.fg.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_110610 (h0 : function.extfun (finset (Type 1 -> Type 1)) (has_mem.mem topological_space)) : @locally_compact_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@finset.pi.empty.{2 2} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) topological_space.{1} (@function.extfun_app.{3 0} (finset.{2} (Type 1 → Type 1)) (@has_mem.mem.{2 2} (Type 1 → Type 1) (finset.{2} (Type 1 → Type 1)) (@finset.has_mem.{2} (Type 1 → Type 1)) topological_space.{1}) h0 (@has_emptyc.emptyc.{2} (finset.{2} (Type 1 → Type 1)) (@finset.has_emptyc.{2} (Type 1 → Type 1))))) Type)  := sorry --non-trivial
lemma new_lemma_110611 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_separated_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_110612 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (metric_space.{0} (has_norm.{0} congr_arg_kind)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (metric_space.{0} (has_norm.{0} congr_arg_kind)))  := sorry --non-trivial
lemma new_lemma_110613 (h0 : set (set fun_info)) (h1 : fun_info -> add_comm_semigroup linarith.ineq) (h2 : coe_sort (set.range h1)) : set.sInter h0 (set.range_splitting h1 h2) := sorry --non-trivial
lemma new_lemma_110614 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (ordered_cancel_add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_110615 (h0 : filter (linear_ordered_add_comm_group complex)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_110616 (h0 : functor.add_const (uniform_space (normed_comm_ring unsigned)) Type) : @complete_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 1} (uniform_space.{0} (normed_comm_ring.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_110617 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} string_imp (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) string_imp)  := sorry --non-trivial
lemma new_lemma_110618 (h0 : functor.add_const (function.extfun (Type 1) ring) Type) : @strong_rank_condition.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) Type h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_110619 (h0 : add_group (with_bot (add_group (add_group linarith.comp)))) : is_add_cyclic (with_bot (add_group (add_group linarith.comp))) := sorry --non-trivial
lemma new_lemma_110620 (h0 : ring (semiring (has_norm empty))) : is_domain (semiring (has_norm empty)) := sorry --non-trivial
lemma new_lemma_110621 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) (has_neg Type)) : @has_exists_mul_of_le.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) (has_neg.{1} Type) h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_110622 (h0 : function.extfun nat fin) : @complete_space.{0} (sub_neg_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (uniform_space.{0} (sub_neg_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_110623 (h1 : set (linarith.ineq -> ereal)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_110624 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (linear_ordered_add_comm_group.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_add_comm_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_110625 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_110626 (h0 : complete_lattice (with_bot (has_inv fun_info))) : is_compactly_generated (with_bot (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_110627 (h0 : not (has_mem.mem (has_top num) has_emptyc.emptyc -> false)) : @path_connected_space.{0} (has_top.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_110628 (h0 : function.extfun Type (functor.add_const (topological_space (filter unsigned)))) : @totally_disconnected_space.{0} (filter.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (filter.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (filter.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_110629 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_110630 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} empty (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) empty)  := sorry --non-trivial
lemma new_lemma_110631 (h1 : has_coe (add_comm_semigroup enat) Prop) (h2 : add_comm_semigroup enat) : @coe_b.{1 1} (add_comm_semigroup.{0} enat) Prop h1 h2  := sorry --non-trivial
lemma new_lemma_110632 (h0 : topological_space (boolean_algebra (finset (has_neg Type)))) : normal_space (boolean_algebra (finset (has_neg Type))) := sorry --non-trivial
lemma new_lemma_110633 (h0 : function.extfun Type (prod (has_bot empty))) : id_rel (function.extfun_app h0 (has_bot empty)) := sorry --non-trivial
lemma new_lemma_110634 (h0 : topological_space (has_zero pos)) : sequential_space (has_zero pos) := sorry --non-trivial
lemma new_lemma_110635 (h0 : ring (uniform_space reducibility_hints)) : strong_rank_condition (uniform_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_110636 (h0 : functor.add_const (ring (boolean_algebra.core empty)) empty) : @rank_condition.{0} (boolean_algebra.core.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_110637 (h0 : topological_space (encodable (random_gen string_imp))) : path_connected_space (encodable (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_110638 (h0 : function.extfun Type topological_space) : @t1_space.{0} (non_assoc_semiring.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (non_assoc_semiring.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_110639 (h0 : not (monoid (id fun_info) -> false)) : @monoid.fg.{0} (@id.{2} Type fun_info) (@classical.by_contradiction'.{1} (monoid.{0} (@id.{2} Type fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_110640 (h0 : complete_lattice (has_nnnorm (has_lt (has_lt to_additive.value_type)))) : is_compactly_generated (has_nnnorm (has_lt (has_lt to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_110641 (h0 : topological_space (comm_monoid num)) : topological_space.separable_space (comm_monoid num) := sorry --non-trivial
lemma new_lemma_110642 (h0 : functor.add_const (ordered_add_comm_monoid (complete_distrib_lattice Type)) name) : @archimedean.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (complete_distrib_lattice.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_110643 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system num)) num) : @totally_separated_space.{0} (measurable_space.dynkin_system.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_110644 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_110645 (h0 : functor.add_const (topological_space znum) num) : @totally_separated_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) num h0)  := sorry --non-trivial
lemma new_lemma_110646 (h0 : functor.add_const (uniform_space (ring pos)) Type) : @separated_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_110647 (h0 : list (has_inv linarith.comp_source)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_110648 (h0 : not (ring linarith.comp -> false)) : @is_domain.{0} linarith.comp (@classical.by_contradiction'.{1} (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_110649 (h0 : topological_space (simple_graph (has_pos_part pos))) : sequential_space (simple_graph (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_110650 (h0 : functor.add_const (group (normed_comm_ring unsigned)) Type) : @is_simple_group.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 1} (group.{0} (normed_comm_ring.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_110651 (h0 : functor.add_const (group (has_to_string environment.implicit_infer_kind)) pos) : @is_simple_group.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_110652 (h0 : functor.add_const (cancel_comm_monoid_with_zero (canonically_ordered_comm_semiring Type)) (finset Type)) : @unique_factorization_monoid.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 1} (cancel_comm_monoid_with_zero.{1} (canonically_ordered_comm_semiring.{1} Type)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_110653 (h0 : not (topological_space (has_emptyc num) -> false)) : @path_connected_space.{0} (has_emptyc.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_110654 (h0 : add_group (nondiscrete_normed_field (nondiscrete_normed_field linarith.ineq))) : is_add_cyclic (nondiscrete_normed_field (nondiscrete_normed_field linarith.ineq)) := sorry --non-trivial
lemma new_lemma_110655 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_110656 (h0 : group (canonically_ordered_comm_semiring pos)) : group.fg (canonically_ordered_comm_semiring pos) := sorry --non-trivial
lemma new_lemma_110657 (h0 : not (topological_space (semiring unsigned) -> false)) : @topological_space.separable_space.{0} (semiring.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_110658 (h0 : list (semigroup (has_add (ring environment.implicit_infer_kind)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_110659 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @irreducible_space.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_110660 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (fintype.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (fintype.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_110661 (h0 : add_group (semigroup (has_to_string Type))) : is_add_cyclic (semigroup (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_110662 (h0 : ring (semigroup empty)) : strong_rank_condition (semigroup empty) := sorry --non-trivial
lemma new_lemma_110663 (h0 : uniform_space (has_ssubset (has_nnnorm (has_nnnorm to_additive.value_type)))) : complete_space (has_ssubset (has_nnnorm (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_110664 (h0 : topological_space (add_left_cancel_monoid (comm_ring (fintype (add_monoid char))))) : totally_disconnected_space (add_left_cancel_monoid (comm_ring (fintype (add_monoid char)))) := sorry --non-trivial
lemma new_lemma_110665 (h0 : functor.add_const (topological_space (ordered_comm_group empty)) congr_arg_kind) : @totally_disconnected_space.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_group.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_110666 (h0 : monoid (has_neg_part (has_add (add_cancel_monoid (has_add pos))))) : monoid.fg (has_neg_part (has_add (add_cancel_monoid (has_add pos)))) := sorry --non-trivial
lemma new_lemma_110667 (h0 : function.extfun nat fin) : @is_domain.{0} (canonically_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (ring.{0} (canonically_ordered_monoid.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_110668 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_110669 (h0 : function.extfun (Type 1) semiring) : @is_noetherian_ring.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} h0 (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_110670 (h0 : uniform_space (has_Inf (has_Inf pos))) : complete_space (has_Inf (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_110671 (h0 : complete_lattice (distrib_lattice (has_inv (has_inv string_imp)))) : is_compactly_generated (distrib_lattice (has_inv (has_inv string_imp))) := sorry --non-trivial
lemma new_lemma_110672 (h0 : functor.add_const (list (boolean_algebra.core Type)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_110673 (h0 : group (cancel_monoid (semigroup (has_add name)))) : group.fg (cancel_monoid (semigroup (has_add name))) := sorry --non-trivial
lemma new_lemma_110674 (h0 : uniform_space (dlist (has_nnnorm linarith.comp_source))) : complete_space (dlist (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_110675 (h0 : ring (cancel_monoid (option ennreal))) : rank_condition (cancel_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_110676 (h0 : ring (dlist (linear_ordered_add_comm_group fun_info))) : rank_condition (dlist (linear_ordered_add_comm_group fun_info)) := sorry --non-trivial
lemma new_lemma_110677 (h0 : ring (non_unital_non_assoc_semiring (metric_space (metric_space char)))) : strong_rank_condition (non_unital_non_assoc_semiring (metric_space (metric_space char))) := sorry --non-trivial
lemma new_lemma_110678 (h0 : group (has_zero (has_neg_part pos))) : normalizer_condition (has_zero (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_110679 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_110680 (h0 : functor.add_const (complete_lattice (has_Inf pos)) linarith.comp) : @is_compactly_generated.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_Inf.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_110681 (h0 : functor.add_const (function.extfun (Type 1) ring) Type) : @is_principal_ideal_ring.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) Type h0) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_110682 (h0 : functor.add_const (complete_lattice (cancel_monoid pos)) pos) : @is_atomistic.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_110683 (h0 : topological_space (has_nndist name)) : locally_compact_space (has_nndist name) := sorry --non-trivial
lemma new_lemma_110684 (h0 : topological_space (semigroup (option (option empty)))) : totally_disconnected_space (semigroup (option (option empty))) := sorry --non-trivial
lemma new_lemma_110685 (h0 : functor.add_const (topological_space (normed_linear_ordered_group congr_arg_kind)) unsigned) : @path_connected_space.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_110686 (h0 : function.extfun Type group) : @normalizer_condition.{0} (boolean_algebra.core.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (boolean_algebra.core.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_110687 (h0 : filter (add_comm_monoid congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_110688 (h0 : group (normed_field (mul_one_class (random_gen reducibility_hints)))) : is_cyclic (normed_field (mul_one_class (random_gen reducibility_hints))) := sorry --non-trivial
lemma new_lemma_110689 (h2 : topological_space (nondiscrete_normed_field (add_comm_semigroup ereal))) : totally_disconnected_space (nondiscrete_normed_field (add_comm_semigroup ereal)) := sorry --non-trivial
lemma new_lemma_110690 (h0 : functor.comp ordered_add_comm_monoid has_to_string unsigned) : @archimedean.{0} (has_to_string.{0} unsigned) (@functor.comp.run.{0 0 0} ordered_add_comm_monoid.{0} has_to_string.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_110691 (h0 : uniform_space (has_div (has_nnnorm string.iterator_imp))) : complete_space (has_div (has_nnnorm string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_110692 (h0 : topological_space (sub_neg_monoid (has_Inf (has_Inf (has_add (has_add linarith.comp)))))) : preconnected_space (sub_neg_monoid (has_Inf (has_Inf (has_add (has_add linarith.comp))))) := sorry --non-trivial
lemma new_lemma_110693 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_ring.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ordered_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_110694 (h0 : fin has_zero.zero) : @normal_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_110695 (h0 : topological_space (nondiscrete_normed_field (mul_one_class std_gen))) : path_connected_space (nondiscrete_normed_field (mul_one_class std_gen)) := sorry --non-trivial
lemma new_lemma_110696 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_atomistic.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) complete_lattice.{0}) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_110697 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_110698 (h0 : uniform_space (preorder congr_arg_kind)) : complete_space (preorder congr_arg_kind) := sorry --non-trivial
lemma new_lemma_110699 (h0 : ring (canonically_ordered_comm_semiring (has_neg name))) : is_principal_ideal_ring (canonically_ordered_comm_semiring (has_neg name)) := sorry --non-trivial
lemma new_lemma_110700 (h0 : functor.add_const (group (has_to_string unsigned)) pos) : @is_cyclic.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_110701 (h0 : topological_space (cancel_monoid (comm_group (has_neg_part (has_add name))))) : loc_path_connected_space (cancel_monoid (comm_group (has_neg_part (has_add name)))) := sorry --non-trivial
lemma new_lemma_110702 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_110703 (h0 : filter (linear_ordered_semiring (semiring unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_110704 (h0 : complete_lattice (has_top (has_norm (has_emptyc linarith.comp_source)))) : complete_lattice.is_Sup_finite_compact (has_top (has_norm (has_emptyc linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_110705 (h0 : function.extfun (Type 1) list) : list.nodup (function.extfun_app h0 (cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_110706 (h0 : ring (has_scalar (finset (has_scalar ennreal ennreal)) ennreal)) : rank_condition (has_scalar (finset (has_scalar ennreal ennreal)) ennreal) := sorry --non-trivial
lemma new_lemma_110707 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (complete_distrib_lattice empty)) := sorry --non-trivial
lemma new_lemma_110708 (h0 : function.extfun Type (functor.comp list has_neg)) : list.nodup (functor.comp.run (function.extfun_app h0 name)) := sorry --non-trivial
lemma new_lemma_110709 (h0 : topological_space (complete_semilattice_Sup (comm_ring (random_gen string_imp)))) : t0_space (complete_semilattice_Sup (comm_ring (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_110710 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} empty (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) empty)  := sorry --non-trivial
lemma new_lemma_110711 (h0 : list (normed_comm_ring (has_to_string linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_110712 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (linear_ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_110713 (h1 : group (random_gen linarith.comp)) : group.fg (random_gen linarith.comp) := sorry --non-trivial
lemma new_lemma_110714 (h0 : functor.add_const (monoid (has_add name)) Type) : @monoid.fg.{0} (has_add.{0} name) (@functor.add_const.run.{0 1} (monoid.{0} (has_add.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_110715 (h1 : complete_lattice (has_compl linarith.comp_source)) : is_compactly_generated (has_compl linarith.comp_source) := sorry --non-trivial
lemma new_lemma_110716 (h0 : uniform_space (has_neg_part pos)) : complete_space (has_neg_part pos) := sorry --non-trivial
lemma new_lemma_110717 (h0 : not (cancel_comm_monoid_with_zero (complete_semilattice_Sup congr_arg_kind) -> false)) : @unique_factorization_monoid.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (complete_semilattice_Sup.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_110718 (h0 : topological_space ennreal) : normal_space ennreal := sorry --non-trivial
lemma new_lemma_110719 (h0 : not (add_group (option num) -> false)) : @is_add_cyclic.{0} (option.{0} num) (@classical.by_contradiction'.{1} (add_group.{0} (option.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_110720 (h0 : topological_space (has_inv (boolean_algebra.core (has_nnnorm linarith.ineq)))) : totally_disconnected_space (has_inv (boolean_algebra.core (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_110721 (h0 : functor.comp filter mul_zero_class pos) : filter.ne_bot (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_110722 (h0 : set (normed_field linarith.ineq)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_110723 (h0 : ring (random_gen (random_gen linarith.comp))) : strong_rank_condition (random_gen (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_110724 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_110725 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_110726 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (partial_order.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (partial_order.{0} num))  := sorry --non-trivial
lemma new_lemma_110727 (h0 : topological_space (add_cancel_comm_monoid empty)) : discrete_topology (add_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_110728 (h0 : topological_space (has_neg (option pos))) : sequential_space (has_neg (option pos)) := sorry --non-trivial
lemma new_lemma_110729 (h0 : add_monoid (has_bot Type)) : add_monoid.fg (has_bot Type) := sorry --non-trivial
lemma new_lemma_110730 (h0 : function.extfun Type topological_space) (h1 : function.extfun Type preorder) : @order_closed_topology.{0} (has_norm.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} string_imp)) (@function.extfun_app.{2 1} Type preorder.{0} h1 (has_norm.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_110731 (h0 : ring (boolean_algebra (has_Inf pos))) : is_domain (boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_110732 (h0 : has_mem.mem (complete_semilattice_Sup linarith.comp) has_emptyc.emptyc) : @is_domain.{0} (complete_semilattice_Sup.{0} linarith.comp) (@finset.pi.empty.{1 0} Type ring.{0} (complete_semilattice_Sup.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_110733 (h0 : semiring (has_to_string (normed_comm_ring (has_add Type)))) : is_noetherian_ring (has_to_string (normed_comm_ring (has_add Type))) := sorry --non-trivial
lemma new_lemma_110734 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_110735 (h0 : add_monoid (ordered_cancel_add_comm_monoid (option (option congr_arg_kind)))) : add_monoid.fg (ordered_cancel_add_comm_monoid (option (option congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_110736 (h0 : function.extfun Type topological_space) : @regular_space.{0} (add_cancel_monoid.{0} (has_scalar.{0 0} (normed_comm_ring.{0} (has_add.{0} (has_add.{0} name))) name)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} (has_scalar.{0 0} (normed_comm_ring.{0} (has_add.{0} (has_add.{0} name))) name)))  := sorry --non-trivial
lemma new_lemma_110737 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (preorder.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_110738 (h0 : not (add_group (add_cancel_comm_monoid linarith.ineq) -> false)) : @is_add_cyclic.{0} (add_cancel_comm_monoid.{0} linarith.ineq) (@classical.by_contradiction'.{1} (add_group.{0} (add_cancel_comm_monoid.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_110739 (h0 : semiring (linear_ordered_semiring num)) : is_noetherian_ring (linear_ordered_semiring num) := sorry --non-trivial
lemma new_lemma_110740 (h0 : function.extfun Type (functor.add_const (list (is_R_or_C empty)))) : palindrome (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_110741 (h0 : ring (option (semiring empty))) : rank_condition (option (semiring empty)) := sorry --non-trivial
lemma new_lemma_110742 (h0 : add_monoid (has_norm num)) : add_monoid.fg (has_norm num) := sorry --non-trivial
lemma new_lemma_110743 (h0 : topological_space (with_one (has_top congr_arg_kind))) : path_connected_space (with_one (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_110744 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (normed_linear_ordered_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_linear_ordered_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_110745 (h0 : ring (has_union (semiring (has_norm linarith.comp)))) : is_domain (has_union (semiring (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_110746 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_separated_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_110747 (h0 : finset (complete_distrib_lattice (has_neg name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_110748 (h0 : functor.add_const (topological_space (has_nndist name)) unsigned) : @irreducible_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_110749 (h0 : topological_space (comm_ring (random_gen char))) : t0_space (comm_ring (random_gen char)) := sorry --non-trivial
lemma new_lemma_110750 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_110751 (h0 : has_lt (has_le (mul_one_class (pseudo_metric_space fun_info)))) : no_max_order (has_le (mul_one_class (pseudo_metric_space fun_info))) := sorry --non-trivial
lemma new_lemma_110752 (h0 : has_coe (nondiscrete_normed_field reducibility_hints) Prop) (h1 : nondiscrete_normed_field reducibility_hints) : @coe_b.{1 1} (nondiscrete_normed_field.{0} reducibility_hints) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_110753 (h0 : functor.add_const (semiring auto.case_option) ennreal) : @is_noetherian_ring.{0} auto.case_option (@functor.add_const.run.{0 0} (semiring.{0} auto.case_option) ennreal h0)  := sorry --non-trivial
lemma new_lemma_110754 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_110755 (h0 : function.extfun nat fin) : @locally_compact_space.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} pos)) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_110756 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_110757 (h0 : topological_space (has_pos_part (finset (has_Inf (has_neg pos))))) : discrete_topology (has_pos_part (finset (has_Inf (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_110758 (h0 : function.extfun (Type 1) topological_space) : @preirreducible_space.{1} (plift.{1} num) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (plift.{1} num))  := sorry --non-trivial
lemma new_lemma_110759 (h0 : complete_lattice (normed_field (mul_one_class (has_nnnorm (has_ssubset reducibility_hints))))) : is_compactly_generated (normed_field (mul_one_class (has_nnnorm (has_ssubset reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_110760 (h0 : uniform_space (distrib_lattice string_imp)) : complete_space (distrib_lattice string_imp) := sorry --non-trivial
lemma new_lemma_110761 (h0 : functor.add_const (complete_lattice (semigroup pos)) (mul_zero_class Type)) : @is_compactly_generated.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (semigroup.{0} pos)) (mul_zero_class.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_110762 (h0 : topological_space (has_zero (finset (has_neg (finset pos))))) : totally_disconnected_space (has_zero (finset (has_neg (finset pos)))) := sorry --non-trivial
lemma new_lemma_110763 (h0 : ring (partial_order empty)) : strong_rank_condition (partial_order empty) := sorry --non-trivial
lemma new_lemma_110764 (h0 : uniform_space (linear_ordered_semiring (has_top (semiring empty)))) : separated_space (linear_ordered_semiring (has_top (semiring empty))) := sorry --non-trivial
lemma new_lemma_110765 (h0 : functor.add_const (semiring (comm_group unsigned)) (finset linarith.comp)) : @is_noetherian_ring.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (comm_group.{0} unsigned)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_110766 (h0 : not (topological_space (linear_ordered_comm_group_with_zero string.iterator_imp) -> false)) : @totally_disconnected_space.{0} (linear_ordered_comm_group_with_zero.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_group_with_zero.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_110767 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) empty) : @path_connected_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_110768 (h0 : nat) (h1 : set (array h0 char -> fun_info)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_110769 (h0 : functor.add_const (topological_space (uniform_space.core pos)) Type) : @locally_compact_space.{0} (uniform_space.core.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (uniform_space.core.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_110770 (h0 : ring (has_top (has_ssubset (dlist (has_norm fun_info))))) : is_domain (has_top (has_ssubset (dlist (has_norm fun_info)))) := sorry --non-trivial
lemma new_lemma_110771 (h0 : function.extfun Type (functor.add_const (filter (monoid empty)))) : filter.ne_bot (functor.add_const.run (function.extfun_app h0 unsigned)) := sorry --non-trivial
lemma new_lemma_110772 (h0 : prod (has_neg_part ennreal) (has_neg_part ennreal)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_110773 (h0 : list (semigroup (semiring (option unsigned)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_110774 (h0 : ordered_add_comm_monoid (is_R_or_C unsigned)) : archimedean (is_R_or_C unsigned) := sorry --non-trivial
lemma new_lemma_110775 (h0 : ring (semiring empty)) : strong_rank_condition (semiring empty) := sorry --non-trivial
lemma new_lemma_110776 (h1 : uniform_space (topological_space fun_info)) : complete_space (topological_space fun_info) := sorry --non-trivial
lemma new_lemma_110777 (h0 : ring (has_neg (mul_zero_class (has_nndist Type)))) : is_domain (has_neg (mul_zero_class (has_nndist Type))) := sorry --non-trivial
lemma new_lemma_110778 (h0 : functor.add_const (uniform_space (add_comm_monoid linarith.comp)) environment.implicit_infer_kind) : @complete_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_comm_monoid.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_110779 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) environment.implicit_infer_kind) : @totally_separated_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_110780 (h0 : uniform_space (has_emptyc (random_gen fun_info))) : separated_space (has_emptyc (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_110781 (h0 : topological_space (has_emptyc (has_norm linarith.comp_source))) : locally_compact_space (has_emptyc (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_110782 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (boolean_algebra.core.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_110783 (h0 : topological_space (has_emptyc unsigned)) : totally_disconnected_space (has_emptyc unsigned) := sorry --non-trivial
lemma new_lemma_110784 (h0 : fin has_zero.zero) : @strong_rank_condition.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (normed_lattice_add_comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_110785 (h0 : function.extfun nat fin) : @path_connected_space.{0} (has_add.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_110786 (h0 : add_group (measurable_space (has_norm congr_arg_kind))) : is_add_cyclic (measurable_space (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_110787 (h0 : topological_space (free_add_monoid (semiring (semiring empty)))) : discrete_topology (free_add_monoid (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_110788 (h0 : function.extfun Type (functor.add_const (topological_space (ordered_ring empty)))) : @preirreducible_space.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} empty)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (ordered_ring.{0} empty))) h0 num))  := sorry --non-trivial
lemma new_lemma_110789 (h0 : functor.add_const (topological_space (pseudo_metric_space Type)) Type) : @loc_path_connected_space.{1} (pseudo_metric_space.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (pseudo_metric_space.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_110790 (h0 : monoid (pseudo_emetric_space (has_top (has_norm empty)))) : monoid.fg (pseudo_emetric_space (has_top (has_norm empty))) := sorry --non-trivial
lemma new_lemma_110791 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_110792 (h1 : add_group (has_inv (with_bot string_imp))) : is_add_cyclic (has_inv (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_110793 (h0 : ring (simple_graph linarith.comp_source)) : is_domain (simple_graph linarith.comp_source) := sorry --non-trivial
lemma new_lemma_110794 (h0 : functor.add_const (topological_space (preorder empty)) congr_arg_kind) : @path_connected_space.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_110795 (h0 : group (canonically_linear_ordered_monoid (has_add Type))) : normalizer_condition (canonically_linear_ordered_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_110796 (h0 : uniform_space (cancel_monoid (boolean_algebra.core ennreal))) : separated_space (cancel_monoid (boolean_algebra.core ennreal)) := sorry --non-trivial
lemma new_lemma_110797 (h0 : topological_space (semigroup (boolean_algebra.core linarith.comp))) : normal_space (semigroup (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_110798 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) Type) : @regular_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_110799 (h0 : functor.add_const (filter (ring pos)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_110800 (h0 : topological_space (boolean_algebra environment.implicit_infer_kind)) : regular_space (boolean_algebra environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_110801 (h0 : fin has_zero.zero) : @discrete_topology.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_110802 (h0 : function.extfun nat fin) : @separated_space.{0} (has_Inf.{0} real) (@matrix.vec_empty.{0} (uniform_space.{0} (has_Inf.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_110803 (h0 : uniform_space (with_bot (semiring (semiring num)))) : complete_space (with_bot (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_110804 (h0 : functor.add_const (topological_space (semiring num)) num) : @locally_compact_space.{0} (semiring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_110805 (h0 : fin has_zero.zero) : preirreducible_space empty := sorry --non-trivial
lemma new_lemma_110806 (h0 : uniform_space (comm_group (has_neg_part Type))) : separated_space (comm_group (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_110807 (h0 : group (distrib_lattice (random_gen to_additive.value_type))) : is_cyclic (distrib_lattice (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_110808 (h0 : complete_lattice (normed_comm_ring (comm_group unsigned))) : is_compactly_generated (normed_comm_ring (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_110809 (h0 : topological_space (has_pos_part (has_Inf (has_neg pos)))) : normal_space (has_pos_part (has_Inf (has_neg pos))) := sorry --non-trivial
lemma new_lemma_110810 (h0 : topological_space (id (with_bot linarith.comp_source))) : t0_space (id (with_bot linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_110811 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_bot.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_110812 (h1 : function.extfun Type group) : @group.fg.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type group.{0} h1 (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_110813 (h0 : topological_space (complete_distrib_lattice (has_pos_part (has_Inf (has_Inf pos))))) : t0_space (complete_distrib_lattice (has_pos_part (has_Inf (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_110814 (h0 : functor.add_const (ordered_add_comm_monoid (free_add_monoid unsigned)) congr_arg_kind) : @archimedean.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (free_add_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_110815 (h0 : not (group (plift unsigned) -> false)) : @group.fg.{1} (plift.{1} unsigned) (@classical.by_contradiction'.{2} (group.{1} (plift.{1} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_110816 (h0 : functor.add_const (topological_space (semigroup pos)) Type) : @totally_separated_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_110817 (h0 : function.extfun Type (functor.add_const (topological_space pos))) : @normal_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} pos)) h0 pos))  := sorry --non-trivial
lemma new_lemma_110818 (h0 : function.extfun nat fin) : @is_noetherian_ring.{0} (ordered_comm_monoid.{0} name) (@matrix.vec_empty.{0} (semiring.{0} (ordered_comm_monoid.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_110819 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_110820 (h0 : has_mem.mem (id fun_info) has_emptyc.emptyc) : @discrete_topology.{0} (@id.{2} Type fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (@id.{2} Type fun_info) h0)  := sorry --non-trivial
lemma new_lemma_110821 (h0 : functor.add_const (topological_space (has_add pos)) pos) : @totally_separated_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_110822 (h0 : topological_space (has_nndist (option (option name)))) : topological_space.separable_space (has_nndist (option (option name))) := sorry --non-trivial
lemma new_lemma_110823 (h0 : not (topological_space (complete_semilattice_Sup unsigned) -> false)) : @normal_space.{0} (complete_semilattice_Sup.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_110824 (h0 : group (boolean_algebra (has_add (has_add Type)))) : normalizer_condition (boolean_algebra (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_110825 (h1 : function.extfun Type ring) : @is_domain.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h1 (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_110826 (h0 : functor.add_const (group (normed_comm_ring ennreal)) pos) : @is_cyclic.{0} (normed_comm_ring.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_110827 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_110828 (h0 : group (comm_group (finset Type))) : group.fg (comm_group (finset Type)) := sorry --non-trivial
lemma new_lemma_110829 (h0 : list (has_Inf (has_Inf linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_110830 (h0 : has_mem.mem ring has_emptyc.emptyc) : @is_domain.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_110831 (h1 : ring (topological_space char)) : is_domain (topological_space char) := sorry --non-trivial
lemma new_lemma_110832 (h0 : complete_lattice (boolean_algebra (ring (ring linarith.comp)))) : is_atomistic (boolean_algebra (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_110833 (h0 : has_mem.mem (semiring num) has_emptyc.emptyc) : @locally_compact_space.{0} (semiring.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_110834 (h0 : topological_space (has_norm congr_arg_kind)) : preirreducible_space (has_norm congr_arg_kind) := sorry --non-trivial
lemma new_lemma_110835 (h0 : topological_space (add_cancel_monoid (has_to_string Type))) : totally_disconnected_space (add_cancel_monoid (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_110836 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_nnnorm.{0} char) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_nnnorm.{0} char))  := sorry --non-trivial
lemma new_lemma_110837 (h0 : function.extfun Type (functor.add_const (add_monoid (partial_order unsigned)))) : @add_monoid.fg.{0} (partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (partial_order.{0} unsigned)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (add_monoid.{0} (partial_order.{0} unsigned))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_110838 (h0 : topological_space (complete_distrib_lattice empty)) : locally_compact_space (complete_distrib_lattice empty) := sorry --non-trivial
lemma new_lemma_110839 (h0 : function.extfun (Type 1) topological_space) : @t0_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_110840 (h0 : functor.add_const (function.extfun Type group) environment.implicit_infer_kind) : @group.fg.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) environment.implicit_infer_kind h0) (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_110841 (h0 : add_group (has_add (has_add name))) : is_add_cyclic (has_add (has_add name)) := sorry --non-trivial
lemma new_lemma_110842 (h0 : topological_space (has_to_string (has_to_string Type))) : path_connected_space (has_to_string (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_110843 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (pseudo_metric_space.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (pseudo_metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_110844 (h0 : has_le (has_div linarith.ineq)) (h1 : bounded_order (has_div linarith.ineq)) : is_simple_order (has_div linarith.ineq) := sorry --non-trivial
lemma new_lemma_110845 (h0 : not (ring (has_norm linarith.comp_source) -> false)) : @rank_condition.{0} (has_norm.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (has_norm.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_110846 (h0 : functor.add_const (topological_space (complete_distrib_lattice environment.implicit_infer_kind)) Type) : @totally_separated_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_110847 (h0 : functor.add_const (topological_space (add_right_cancel_monoid congr_arg_kind)) unsigned) : @normal_space.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_right_cancel_monoid.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_110848 (h0 : has_mem.mem (has_top linarith.comp_source) has_emptyc.emptyc) : @is_cyclic.{0} (has_top.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type group.{0} (has_top.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_110849 (h0 : uniform_space (simple_graph (option num))) : complete_space (simple_graph (option num)) := sorry --non-trivial
lemma new_lemma_110850 (h0 : topological_space (complete_distrib_lattice (semigroup name))) : totally_separated_space (complete_distrib_lattice (semigroup name)) := sorry --non-trivial
lemma new_lemma_110851 (h0 : topological_space (add_cancel_monoid name)) : path_connected_space (add_cancel_monoid name) := sorry --non-trivial
lemma new_lemma_110852 (h0 : group (has_emptyc (has_norm (has_norm congr_arg_kind)))) : normalizer_condition (has_emptyc (has_norm (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_110853 (h0 : complete_lattice (ordered_ring (semiring (semiring (semiring empty))))) : complete_lattice.is_Sup_finite_compact (ordered_ring (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_110854 (h0 : complete_lattice (sub_neg_monoid (has_neg (has_neg Type)))) : complete_lattice.is_Sup_finite_compact (sub_neg_monoid (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_110855 (h0 : measurable_space (normed_field reducibility_hints)) (h1 : filter (normed_field reducibility_hints)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_110856 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @rank_condition.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) ring.{0}) (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_110857 (h0 : topological_space (has_norm (has_norm linarith.comp))) : t0_space (has_norm (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_110858 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (non_assoc_semiring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (non_assoc_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_110859 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_110860 (h0 : topological_space (comm_group (has_neg_part (has_neg_part (has_add environment.implicit_infer_kind))))) : normal_space (comm_group (has_neg_part (has_neg_part (has_add environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_110861 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_110862 (h0 : functor.add_const (topological_space (boolean_algebra pos)) environment.implicit_infer_kind) : @t1_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_110863 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_110864 (h1 : topological_space (uniform_space char)) : path_connected_space (uniform_space char) := sorry --non-trivial
lemma new_lemma_110865 (h0 : group (has_bot (has_add (has_add name)))) : is_simple_group (has_bot (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_110866 (h0 : add_monoid (linear_ordered_comm_ring (semiring (has_norm unsigned)))) : add_monoid.fg (linear_ordered_comm_ring (semiring (has_norm unsigned))) := sorry --non-trivial
lemma new_lemma_110867 (h0 : functor.add_const (monoid (add_comm_monoid Type)) (boolean_algebra Type)) : @monoid.fg.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (monoid.{1} (add_comm_monoid.{1} Type)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_110868 (h0 : functor.add_const (filter (add_comm_monoid pos)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_110869 (h0 : not (filter (linear_ordered_comm_ring empty) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_110870 (h0 : topological_space (option ennreal)) : locally_compact_space (option ennreal) := sorry --non-trivial
lemma new_lemma_110871 (h0 : functor.add_const (topological_space (complete_distrib_lattice linarith.comp)) linarith.comp) : @locally_compact_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_110872 (h0 : topological_space (boolean_algebra (has_pos_part linarith.comp))) : preirreducible_space (boolean_algebra (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_110873 (h0 : functor.add_const (group (semigroup Type)) name) : @is_cyclic.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (semigroup.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_110874 (h0 : add_group (has_add (has_add linarith.comp))) : is_add_cyclic (has_add (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_110875 (h0 : ring (has_nndist (comm_group unsigned))) : is_domain (has_nndist (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_110876 (h0 : fin has_zero.zero) : @regular_space.{1} (finset.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (finset.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_110877 (h0 : complete_lattice (has_to_string (boolean_algebra (has_add Type)))) : is_compactly_generated (has_to_string (boolean_algebra (has_add Type))) := sorry --non-trivial
lemma new_lemma_110878 (h1 : ring (mul_one_class linarith.ineq)) : is_domain (mul_one_class linarith.ineq) := sorry --non-trivial
lemma new_lemma_110879 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (lex.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (lex.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_110880 (h0 : ring (complete_distrib_lattice (finset Type))) : rank_condition (complete_distrib_lattice (finset Type)) := sorry --non-trivial
lemma new_lemma_110881 (h0 : topological_space (has_to_string (comm_group name))) : t1_space (has_to_string (comm_group name)) := sorry --non-trivial
lemma new_lemma_110882 (h0 : topological_space (comm_group (option pos))) : sequential_space (comm_group (option pos)) := sorry --non-trivial
lemma new_lemma_110883 (h0 : topological_space (random_gen (random_gen linarith.comp_source))) : totally_disconnected_space (random_gen (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_110884 (h0 : topological_space (has_pos_part (has_nndist (has_add linarith.comp)))) : irreducible_space (has_pos_part (has_nndist (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_110885 (h0 : not (uniform_space (has_star congr_arg_kind) -> false)) : @separated_space.{0} (has_star.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_star.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_110886 (h0 : ordered_comm_monoid (comm_group (pseudo_metric_space pos))) : has_exists_mul_of_le (comm_group (pseudo_metric_space pos)) := sorry --non-trivial
lemma new_lemma_110887 (h0 : topological_space (pseudo_metric_space (has_to_string ennreal))) : irreducible_space (pseudo_metric_space (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_110888 (h0 : functor.add_const (finset (normed_comm_ring Type)) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_110889 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) Type) : @sequential_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_110890 (h0 : filter (pseudo_metric_space num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_110891 (h0 : topological_space (has_norm (has_top fun_info))) : path_connected_space (has_norm (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_110892 (h0 : add_group (add_monoid to_additive.value_type)) : is_add_cyclic (add_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_110893 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_110894 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (complete_distrib_lattice.{0} empty))  := sorry --non-trivial
lemma new_lemma_110895 (h0 : function.extfun Type group) : @group.fg.{0} (has_nnnorm.{0} (has_nnnorm.{0} to_additive.value_type)) (@function.extfun_app.{2 1} Type group.{0} h0 (has_nnnorm.{0} (has_nnnorm.{0} to_additive.value_type)))  := sorry --non-trivial
lemma new_lemma_110896 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) pos) : @topological_space.separable_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_110897 (h0 : add_group (comm_ring (comm_ring string_imp))) : is_add_cyclic (comm_ring (comm_ring string_imp)) := sorry --non-trivial
lemma new_lemma_110898 (h0 : functor.add_const (ring (ordered_comm_ring pos)) name) : @is_domain.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_110899 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_star.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_star.{0} num))  := sorry --non-trivial
lemma new_lemma_110900 (h0 : add_group (semiring (random_gen fun_info))) : is_add_cyclic (semiring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_110901 (h1 : uniform_space (linear_ordered_comm_group_with_zero reducibility_hints)) : complete_space (linear_ordered_comm_group_with_zero reducibility_hints) := sorry --non-trivial
lemma new_lemma_110902 (h0 : group (normed_group congr_arg_kind)) : normalizer_condition (normed_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_110903 (h0 : uniform_space (has_bot (comm_semigroup name))) : complete_space (has_bot (comm_semigroup name)) := sorry --non-trivial
lemma new_lemma_110904 (h0 : set (normed_field linarith.ineq)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_110905 (h0 : group (has_add name)) : is_simple_group (has_add name) := sorry --non-trivial
lemma new_lemma_110906 (h0 : functor.add_const (topological_space (left_cancel_monoid num)) congr_arg_kind) : @irreducible_space.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_110907 (h0 : fin has_zero.zero) : @normal_space.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))) (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_110908 (h0 : functor.add_const (group (has_Inf linarith.comp)) linarith.comp) : @normalizer_condition.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_Inf.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_110909 (h0 : cancel_comm_monoid_with_zero (has_neg_part (has_add (option name)))) : unique_factorization_monoid (has_neg_part (has_add (option name))) := sorry --non-trivial
lemma new_lemma_110910 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (canonically_ordered_comm_semiring.{0} (has_add.{0} name)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} (has_add.{0} name)))  := sorry --non-trivial
lemma new_lemma_110911 (h0 : uniform_space (add_cancel_monoid name)) : separated_space (add_cancel_monoid name) := sorry --non-trivial
lemma new_lemma_110912 (h0 : not (monoid (complete_semilattice_Sup congr_arg_kind) -> false)) : @monoid.fg.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (monoid.{0} (complete_semilattice_Sup.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_110913 (h0 : function.extfun nat fin) : @t1_space.{0} (canonically_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_110914 (h0 : group (semigroup (option ennreal))) : is_cyclic (semigroup (option ennreal)) := sorry --non-trivial
lemma new_lemma_110915 (h0 : topological_space (distrib (has_nnnorm (has_nnnorm (has_nnnorm string.iterator_imp))))) : t0_space (distrib (has_nnnorm (has_nnnorm (has_nnnorm string.iterator_imp)))) := sorry --non-trivial
lemma new_lemma_110916 (h1 : ring (has_compl (has_nnnorm (comm_ring reducibility_hints)))) : rank_condition (has_compl (has_nnnorm (comm_ring reducibility_hints))) := sorry --non-trivial
lemma new_lemma_110917 (h0 : topological_space (ring (mul_zero_class name))) : totally_disconnected_space (ring (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_110918 (h0 : complete_lattice (has_union (has_union linarith.comp))) : is_atomistic (has_union (has_union linarith.comp)) := sorry --non-trivial
lemma new_lemma_110919 (h0 : uniform_space (linear_ordered_semiring (semiring num))) : complete_space (linear_ordered_semiring (semiring num)) := sorry --non-trivial
lemma new_lemma_110920 (h0 : topological_space (has_sub congr_arg_kind)) : t0_space (has_sub congr_arg_kind) := sorry --non-trivial
lemma new_lemma_110921 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (@id.{2} Type fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (@id.{2} Type fun_info))  := sorry --non-trivial
lemma new_lemma_110922 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_110923 (h0 : topological_space (canonically_ordered_monoid Type)) : t1_space (canonically_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_110924 (h0 : functor.add_const (ordered_add_comm_monoid (has_Inf pos)) (ring name)) : @archimedean.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_Inf.{0} pos)) (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_110925 (h0 : function.extfun Type topological_space) : @t1_space.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_110926 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) name) : @locally_compact_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_110927 (h0 : topological_space (ordered_comm_monoid (has_Inf (has_Inf pos)))) : totally_separated_space (ordered_comm_monoid (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_110928 (h0 : group (boolean_algebra (comm_group Type))) : group.fg (boolean_algebra (comm_group Type)) := sorry --non-trivial
lemma new_lemma_110929 (h0 : group (preorder num)) : group.fg (preorder num) := sorry --non-trivial
lemma new_lemma_110930 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) name) : @preconnected_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_110931 (h0 : finset (div_inv_monoid empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_110932 (h0 : group (has_to_string (finset pos))) : is_simple_group (has_to_string (finset pos)) := sorry --non-trivial
lemma new_lemma_110933 (h0 : not (complete_lattice (plift congr_arg_kind) -> false)) : @complete_lattice.is_Sup_finite_compact.{1} (plift.{1} congr_arg_kind) (@classical.by_contradiction'.{2} (complete_lattice.{1} (plift.{1} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_110934 (h0 : semiring (add_cancel_monoid (finset linarith.comp))) : is_noetherian_ring (add_cancel_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_110935 (h0 : functor.add_const (ordered_add_comm_monoid (has_Inf Type)) Type) : @archimedean.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 1} (ordered_add_comm_monoid.{1} (has_Inf.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_110936 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (complete_semilattice_Sup num)) := sorry --non-trivial
lemma new_lemma_110937 (h0 : ring (boolean_algebra (has_add environment.implicit_infer_kind))) : strong_rank_condition (boolean_algebra (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_110938 (h0 : has_neg linarith.ineq) (h1 : measurable_space linarith.ineq) : has_measurable_neg linarith.ineq := sorry --non-trivial
lemma new_lemma_110939 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen fun_info))) : @locally_compact_space.{0} (random_gen.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_110940 (h0 : function.extfun (Type 1) topological_space) : @preirreducible_space.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_110941 (h0 : function.extfun Type group) : @group.fg.{0} (has_top.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h0 (has_top.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_110942 (h0 : functor.add_const (function.extfun (Type 1) group) (finset pos)) : @is_cyclic.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) (finset.{0} pos) h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_110943 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (finset unsigned)) := sorry --non-trivial
lemma new_lemma_110944 (h0 : topological_space (ordered_comm_ring name)) : regular_space (ordered_comm_ring name) := sorry --non-trivial
lemma new_lemma_110945 (h1 : add_comm_semigroup ereal -> add_comm_semigroup ereal) (h2 : add_comm_semigroup ereal) : function.is_fixed_pt h1 h2 := sorry --non-trivial
lemma new_lemma_110946 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_110947 (h0 : topological_space (has_zero (has_neg environment.implicit_infer_kind))) : loc_path_connected_space (has_zero (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_110948 (h0 : uniform_space (add_semigroup unsigned)) : separated_space (add_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_110949 (h0 : ordered_comm_monoid (has_neg_part (option (option (complete_distrib_lattice ennreal))))) : has_exists_mul_of_le (has_neg_part (option (option (complete_distrib_lattice ennreal)))) := sorry --non-trivial
lemma new_lemma_110950 (h0 : uniform_space (encodable (has_nnnorm fun_info))) : complete_space (encodable (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_110951 (h0 : topological_space (ordered_comm_monoid (has_add name))) : regular_space (ordered_comm_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_110952 (h0 : functor.add_const (function.extfun Type group) Type) : @group.fg.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_110953 (h0 : topological_space (add_cancel_monoid (comm_group name))) : path_connected_space (add_cancel_monoid (comm_group name)) := sorry --non-trivial
lemma new_lemma_110954 (h0 : functor.add_const (complete_lattice (normed_linear_ordered_group unsigned)) num) : @is_compactly_generated.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_linear_ordered_group.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_110955 (h0 : topological_space (ring (has_pos_part pos))) : normal_space (ring (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_110956 (h0 : functor.add_const (function.extfun Type complete_lattice) pos) : @is_atomistic.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) pos h0) (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_110957 (h0 : group (complete_distrib_lattice (ring Type))) : normalizer_condition (complete_distrib_lattice (ring Type)) := sorry --non-trivial
lemma new_lemma_110958 (h0 : topological_space (has_nnnorm (has_inv to_additive.value_type))) : locally_compact_space (has_nnnorm (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_110959 (h0 : not (topological_space (has_inv linarith.ineq) -> false)) : @totally_disconnected_space.{0} (has_inv.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_inv.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_110960 (h0 : group (linear_ordered_field (option (option (option unsigned))))) : is_cyclic (linear_ordered_field (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_110961 (h0 : ring (canonically_ordered_comm_semiring (has_add pos))) : strong_rank_condition (canonically_ordered_comm_semiring (has_add pos)) := sorry --non-trivial
lemma new_lemma_110962 (h0 : topological_space (ring name)) : sequential_space (ring name) := sorry --non-trivial
lemma new_lemma_110963 (h0 : functor.add_const (topological_space (has_to_string ennreal)) name) : @totally_disconnected_space.{0} (has_to_string.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_110964 (h0 : filter (with_one (semiring empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_110965 (h0 : topological_space (has_pos_part (has_add Type))) : preirreducible_space (has_pos_part (has_add Type)) := sorry --non-trivial
lemma new_lemma_110966 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_110967 (h0 : topological_space (with_one string_imp)) : totally_separated_space (with_one string_imp) := sorry --non-trivial
lemma new_lemma_110968 (h0 : topological_space (has_zero (normed_comm_ring (add_comm_monoid Type)))) : t0_space (has_zero (normed_comm_ring (add_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_110969 (h0 : function.extfun (Type 1) add_group) : @is_add_cyclic.{1} (has_bot.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} h0 (has_bot.{1} Type))  := sorry --non-trivial
lemma new_lemma_110970 (h0 : not (group (has_ssubset reducibility_hints) -> false)) : @is_cyclic.{0} (has_ssubset.{0} reducibility_hints) (@classical.by_contradiction'.{1} (group.{0} (has_ssubset.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_110971 (h0 : monoid (id (semiring empty))) : monoid.fg (id (semiring empty)) := sorry --non-trivial
lemma new_lemma_110972 (h0 : group (add_cancel_monoid linarith.comp)) : normalizer_condition (add_cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_110973 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen empty))) : @is_domain.{0} (random_gen.{0} empty) (@finset.pi.empty.{1 0} Type ring.{0} (random_gen.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_110974 (h0 : functor.add_const (semiring (add_cancel_monoid ennreal)) ennreal) : @is_noetherian_ring.{0} (add_cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (semiring.{0} (add_cancel_monoid.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_110975 (h0 : function.extfun (Type 1) group) : @is_simple_group.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_110976 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_cyclic.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (group.{1} (canonically_linear_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_110977 (h0 : finset (group_with_zero (option num))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_110978 (h0 : function.extfun Type topological_space) : @t1_space.{0} (canonically_ordered_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_110979 (h0 : not (semiring (has_union empty) -> false)) : @is_noetherian_ring.{0} (has_union.{0} empty) (@classical.by_contradiction'.{1} (semiring.{0} (has_union.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_110980 (h0 : ordered_add_comm_monoid (plift (semiring empty))) : archimedean (plift (semiring empty)) := sorry --non-trivial
lemma new_lemma_110981 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} pos (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) pos)  := sorry --non-trivial
lemma new_lemma_110982 (h0 : filter (normed_group (comm_ring to_additive.value_type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_110983 (h0 : ring (has_emptyc (semiring (has_norm linarith.comp_source)))) : strong_rank_condition (has_emptyc (semiring (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_110984 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_110985 (h0 : topological_space (generalized_boolean_algebra (has_neg Type))) : loc_path_connected_space (generalized_boolean_algebra (has_neg Type)) := sorry --non-trivial
lemma new_lemma_110986 (h0 : ring (has_inv (has_inv (has_ssubset to_additive.value_type)))) : rank_condition (has_inv (has_inv (has_ssubset to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_110987 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_110988 (h0 : fin has_zero.zero) : @discrete_topology.{0} (has_zero.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_zero.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_110989 (h0 : filter Prop) (h1 : part (filter Prop)) (h2 : decidable (part.dom h1)) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@part.get_or_else.{0} (filter.{0} Prop) h1 h2 (@id.{1} (filter.{0} Prop) h0))  := sorry --non-trivial
lemma new_lemma_110990 (h0 : functor.comp topological_space has_neg_part Type) : @t1_space.{1} (has_neg_part.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_neg_part.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_110991 (h0 : group (dlist (has_top (random_gen linarith.ineq)))) : group.fg (dlist (has_top (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_110992 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_right_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_110993 (h0 : topological_space (nondiscrete_normed_field fun_info)) : path_connected_space (nondiscrete_normed_field fun_info) := sorry --non-trivial
lemma new_lemma_110994 (h1 : set (add_comm_semigroup (add_comm_semigroup enat) -> enat)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_110995 (h0 : group (has_pos_part (has_Inf (has_Inf (has_Inf (has_add linarith.comp)))))) : normalizer_condition (has_pos_part (has_Inf (has_Inf (has_Inf (has_add linarith.comp))))) := sorry --non-trivial
lemma new_lemma_110996 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_110997 (h0 : group (comm_semigroup (sub_neg_monoid (has_Inf real)))) : normalizer_condition (comm_semigroup (sub_neg_monoid (has_Inf real))) := sorry --non-trivial
lemma new_lemma_110998 (h0 : uniform_space (comm_group (has_to_string name))) : separated_space (comm_group (has_to_string name)) := sorry --non-trivial
lemma new_lemma_110999 (h0 : topological_space (option (semiring (semiring unsigned)))) : topological_space.separable_space (option (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_111000 (h0 : functor.add_const (cancel_comm_monoid_with_zero (boolean_algebra linarith.comp)) pos) : @unique_factorization_monoid.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_111001 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} real.angle (@function.extfun_app.{2 1} Type topological_space.{0} h0 real.angle)  := sorry --non-trivial
lemma new_lemma_111002 (h0 : functor.add_const (topological_space (plift unsigned)) (option empty)) : @t1_space.{1} (plift.{1} unsigned) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} unsigned)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_111003 (h0 : functor.add_const (topological_space (has_Sup num)) empty) : @t1_space.{0} (has_Sup.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_111004 (h0 : not (topological_space enat -> false)) : @t0_space.{0} enat (@classical.by_contradiction'.{1} (topological_space.{0} enat) h0)  := sorry --non-trivial
lemma new_lemma_111005 (h0 : topological_space (has_bot (sub_neg_monoid Type))) : totally_disconnected_space (has_bot (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_111006 (h2 : not (topological_space (has_append linarith.comp_source) -> false)) : @noncompact_space.{0} (has_append.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_append.{0} linarith.comp_source)) h2)  := sorry --non-trivial
lemma new_lemma_111007 (h0 : topological_space (distrib to_additive.value_type)) : path_connected_space (distrib to_additive.value_type) := sorry --non-trivial
lemma new_lemma_111008 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_111009 (h0 : group (topological_space (mul_one_class (mul_one_class (mul_one_class reducibility_hints))))) : is_cyclic (topological_space (mul_one_class (mul_one_class (mul_one_class reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_111010 (h0 : topological_space (has_nndist (has_add ennreal))) : totally_separated_space (has_nndist (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_111011 (h0 : function.extfun Type group) : @normalizer_condition.{0} linarith.comp (@function.extfun_app.{2 1} Type group.{0} h0 linarith.comp)  := sorry --non-trivial
lemma new_lemma_111012 (h0 : functor.add_const (ring (complete_distrib_lattice environment.implicit_infer_kind)) linarith.comp) : @strong_rank_condition.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_111013 (h0 : topological_space (complete_distrib_lattice (has_to_string unsigned))) : totally_separated_space (complete_distrib_lattice (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_111014 (h0 : topological_space (distrib_lattice (comm_ring fun_info))) : path_connected_space (distrib_lattice (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_111015 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_dist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_111016 (h4 : complete_lattice (normed_field char)) : complete_lattice.is_Sup_finite_compact (normed_field char) := sorry --non-trivial
lemma new_lemma_111017 (h0 : topological_space (has_Sup (add_comm_monoid (option (option unsigned))))) : totally_separated_space (has_Sup (add_comm_monoid (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_111018 (h0 : ring (has_le reducibility_hints)) : strong_rank_condition (has_le reducibility_hints) := sorry --non-trivial
lemma new_lemma_111019 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @t1_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_111020 (h0 : complete_lattice (has_lt (has_lt linarith.ineq))) : is_compactly_generated (has_lt (has_lt linarith.ineq)) := sorry --non-trivial
lemma new_lemma_111021 (h0 : semiring (has_to_string (ring (add_left_cancel_monoid Type)))) : is_noetherian_ring (has_to_string (ring (add_left_cancel_monoid Type))) := sorry --non-trivial
lemma new_lemma_111022 (h0 : functor.add_const (uniform_space environment.implicit_infer_kind) linarith.comp) : @complete_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (uniform_space.{0} environment.implicit_infer_kind) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_111023 (h0 : not (ring (comm_ring char) -> false)) : @strong_rank_condition.{0} (comm_ring.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (comm_ring.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_111024 (h0 : topological_space (semiring (semiring linarith.comp))) : irreducible_space (semiring (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_111025 (h0 : functor.add_const (complete_lattice (free_add_monoid congr_arg_kind)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (free_add_monoid.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_111026 (h0 : cancel_comm_monoid_with_zero (normed_lattice_add_comm_group linarith.comp)) : unique_factorization_monoid (normed_lattice_add_comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_111027 (h1 : ring (measurable_space linarith.comp)) : strong_rank_condition (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_111028 (h0 : topological_space (monoid_with_zero (option (option pos)))) : preconnected_space (monoid_with_zero (option (option pos))) := sorry --non-trivial
lemma new_lemma_111029 (h0 : function.extfun (Type 1) topological_space) : @t1_space.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_111030 (h0 : functor.add_const (topological_space (comm_group name)) linarith.comp) : @path_connected_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_111031 (h0 : complete_lattice (complete_distrib_lattice (has_nndist pos))) : complete_lattice.is_Sup_finite_compact (complete_distrib_lattice (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_111032 (h0 : group (semi_normed_ring reducibility_hints)) : is_cyclic (semi_normed_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_111033 (h0 : topological_space (monoid_with_zero (option (option ennreal)))) : t0_space (monoid_with_zero (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_111034 (h0 : group (has_nndist (option pos))) : normalizer_condition (has_nndist (option pos)) := sorry --non-trivial
lemma new_lemma_111035 (h0 : complete_lattice (normed_lattice_add_comm_group (finset real))) : complete_lattice.is_Sup_finite_compact (normed_lattice_add_comm_group (finset real)) := sorry --non-trivial
lemma new_lemma_111036 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_111037 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_111038 (h0 : fin has_zero.zero) : @topological_space.separable_space.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_111039 (h0 : function.extfun Type topological_space) : @t0_space.{0} (complete_semilattice_Sup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_111040 (h0 h1 : multiset (mul_one_class linarith.ineq)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_111041 (h0 : topological_space (distrib (random_gen fun_info))) : path_connected_space (distrib (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_111042 (h0 : topological_space (semiring (has_top num))) : totally_separated_space (semiring (has_top num)) := sorry --non-trivial
lemma new_lemma_111043 (h0 : topological_space (has_pos_part real)) : discrete_topology (has_pos_part real) := sorry --non-trivial
lemma new_lemma_111044 (h2 : uniform_space (with_one (with_bot linarith.comp_source))) : complete_space (with_one (with_bot linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_111045 (h0 : topological_space (has_Inf (has_neg name))) : locally_compact_space (has_Inf (has_neg name)) := sorry --non-trivial
lemma new_lemma_111046 (h0 : topological_space (ring (ring (has_add Type)))) : normal_space (ring (ring (has_add Type))) := sorry --non-trivial
lemma new_lemma_111047 (h0 : filter (dlist string_imp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_111048 (h0 : fin has_zero.zero) : @discrete_topology.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_111049 (h1 : ring (mul_one_class (add_comm_semigroup fun_info))) : strong_rank_condition (mul_one_class (add_comm_semigroup fun_info)) := sorry --non-trivial
lemma new_lemma_111050 (h0 : semiring (has_bot (has_Inf real))) : is_noetherian_ring (has_bot (has_Inf real)) := sorry --non-trivial
lemma new_lemma_111051 (h0 : function.extfun Type ring) : @is_domain.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_cancel_add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_111052 (h0 : topological_space (metric_space (semiring linarith.comp))) : irreducible_space (metric_space (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_111053 (h0 : topological_space (has_Inf pos)) : loc_path_connected_space (has_Inf pos) := sorry --non-trivial
lemma new_lemma_111054 (h0 : topological_space (add_comm_monoid (comm_group name))) : t1_space (add_comm_monoid (comm_group name)) := sorry --non-trivial
lemma new_lemma_111055 (h0 : functor.add_const (complete_lattice (linear_ordered_add_comm_monoid_with_top unsigned)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_add_comm_monoid_with_top.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_ordered_add_comm_monoid_with_top.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_111056 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (linear_ordered_add_comm_group.{0} string_imp) (@function.extfun_app.{2 1} Type monoid.{0} h0 (linear_ordered_add_comm_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_111057 (h0 : function.extfun (Type 1) uniform_space) : @complete_space.{1} Type (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 Type)  := sorry --non-trivial
lemma new_lemma_111058 (h0 h1 : set char) (h2 : char) : nonempty (set.inter h0 h1 h2) := sorry --non-trivial
lemma new_lemma_111059 (h0 : not (group (measure_theory.measure_space empty) -> false)) : @normalizer_condition.{0} (measure_theory.measure_space.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (measure_theory.measure_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_111060 (h0 : ordered_comm_monoid (ordered_comm_monoid (has_add pos))) : has_exists_mul_of_le (ordered_comm_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_111061 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_111062 (h0 : ring (random_gen (random_gen (has_ssubset (has_nnnorm linarith.ineq))))) : is_domain (random_gen (random_gen (has_ssubset (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_111063 (h0 : topological_space (non_assoc_semiring unsigned)) : loc_path_connected_space (non_assoc_semiring unsigned) := sorry --non-trivial
lemma new_lemma_111064 (h0 : function.extfun Type group) : @group.fg.{0} (measurable_space.dynkin_system.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} num)))))) (@function.extfun_app.{2 1} Type group.{0} h0 (measurable_space.dynkin_system.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} num)))))))  := sorry --non-trivial
lemma new_lemma_111065 (h0 : topological_space (group_with_zero unsigned)) : preirreducible_space (group_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_111066 (h0 : function.extfun (Type 1) topological_space) : @t1_space.{1} (sub_neg_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (sub_neg_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_111067 (h0 : semiring (bin_tree unsigned)) : is_noetherian_ring (bin_tree unsigned) := sorry --non-trivial
lemma new_lemma_111068 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (omega_complete_partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (omega_complete_partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_111069 (h0 : topological_space (has_Inf real)) : totally_separated_space (has_Inf real) := sorry --non-trivial
lemma new_lemma_111070 (h0 : topological_space (ordered_comm_monoid (has_Inf (has_add (has_Inf real))))) : discrete_topology (ordered_comm_monoid (has_Inf (has_add (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_111071 (h0 : topological_space (linear_ordered_semiring (has_norm linarith.comp))) : normal_space (linear_ordered_semiring (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_111072 (h0 : group (linear_ordered_semiring (has_norm unsigned))) : is_cyclic (linear_ordered_semiring (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_111073 (h0 : cancel_comm_monoid_with_zero (has_ssubset reducibility_hints)) : unique_factorization_monoid (has_ssubset reducibility_hints) := sorry --non-trivial
lemma new_lemma_111074 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_ssubset.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_ssubset.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_111075 (h0 : group (complete_semilattice_Sup (random_gen to_additive.value_type))) : normalizer_condition (complete_semilattice_Sup (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_111076 (h0 : topological_space (left_cancel_monoid (semiring empty))) : loc_path_connected_space (left_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_111077 (h0 : functor.add_const (filter (has_zero linarith.comp)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_111078 (h0 : ordered_comm_monoid (semigroup (finset pos))) : has_exists_mul_of_le (semigroup (finset pos)) := sorry --non-trivial
lemma new_lemma_111079 (h0 : topological_space (has_neg (has_nndist Type))) : t1_space (has_neg (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_111080 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_111081 (h0 : functor.add_const (filter (ring pos)) environment.implicit_infer_kind) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_111082 (h0 : fin has_zero.zero) : @separated_space.{0} (has_Inf.{0} real) (@matrix.vec_empty.{0} (uniform_space.{0} (has_Inf.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_111083 (h0 : topological_space (has_Inf real)) : irreducible_space (has_Inf real) := sorry --non-trivial
lemma new_lemma_111084 (h0 : topological_space (has_top (has_top (random_gen (has_top (has_top (has_ssubset linarith.ineq))))))) : t0_space (has_top (has_top (random_gen (has_top (has_top (has_ssubset linarith.ineq)))))) := sorry --non-trivial
lemma new_lemma_111085 (h0 : uniform_space (boolean_algebra.core (boolean_algebra.core pos))) : separated_space (boolean_algebra.core (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_111086 (h0 : uniform_space (add_comm_semigroup char)) : separated_space (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_111087 (h0 : functor.add_const (list (ordered_ring empty)) num) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_111088 (h0 : functor.add_const (topological_space (has_zero Type)) pos) : @t1_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_111089 (h0 : topological_space (add_comm_monoid pos)) : totally_separated_space (add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_111090 (h0 : functor.add_const (topological_space (cancel_monoid name)) name) : @preirreducible_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_111091 (h0 : topological_space (has_add (has_neg pos))) : locally_compact_space (has_add (has_neg pos)) := sorry --non-trivial
lemma new_lemma_111092 (h0 : has_mem.mem (random_gen (has_norm num)) has_emptyc.emptyc) : @strong_rank_condition.{0} (random_gen.{0} (has_norm.{0} num)) (@finset.pi.empty.{1 0} Type ring.{0} (random_gen.{0} (has_norm.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_111093 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) pos) : @regular_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_111094 (h0 : function.extfun Type topological_space) : @t1_space.{0} (measurable_space.dynkin_system.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.dynkin_system.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_111095 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (mul_zero_class.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (mul_zero_class.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_111096 (h0 : function.extfun Type group) : @normalizer_condition.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_111097 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} auto.case_option (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 auto.case_option)  := sorry --non-trivial
lemma new_lemma_111098 (h0 : ring (random_gen (comm_ring to_additive.value_type))) : strong_rank_condition (random_gen (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_111099 (h0 : ring (has_pos_part (sub_neg_monoid real))) : is_domain (has_pos_part (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_111100 (h0 : finset (has_pos_part (has_add pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_111101 (h0 : cancel_comm_monoid_with_zero (has_to_string (has_add unsigned))) : unique_factorization_monoid (has_to_string (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_111102 (h0 : has_mem.mem (random_gen num) has_emptyc.emptyc) : @normalizer_condition.{0} (random_gen.{0} num) (@finset.pi.empty.{1 0} Type group.{0} (random_gen.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_111103 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @preirreducible_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_111104 (h0 : group (cancel_monoid (finset environment.implicit_infer_kind))) : group.fg (cancel_monoid (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_111105 (h0 : has_lt (mul_one_class (pseudo_metric_space (add_comm_semigroup enat)))) : no_max_order (mul_one_class (pseudo_metric_space (add_comm_semigroup enat))) := sorry --non-trivial
lemma new_lemma_111106 (h0 : topological_space (linear_ordered_semiring fun_info)) : totally_disconnected_space (linear_ordered_semiring fun_info) := sorry --non-trivial
lemma new_lemma_111107 (h0 : ring (nondiscrete_normed_field (mul_one_class (mul_one_class string.iterator_imp)))) : strong_rank_condition (nondiscrete_normed_field (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_111108 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (free_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (free_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_111109 (h0 : ring (has_Sup empty)) : strong_rank_condition (has_Sup empty) := sorry --non-trivial
lemma new_lemma_111110 (h1 : topological_space (distrib_lattice string_imp)) : t0_space (distrib_lattice string_imp) := sorry --non-trivial
lemma new_lemma_111111 (h0 : functor.add_const (topological_space (has_zero Type)) environment.implicit_infer_kind) : @totally_disconnected_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_111112 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_111113 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (mul_zero_class pos)) := sorry --non-trivial
lemma new_lemma_111114 (h0 : ordered_comm_monoid (has_to_string (ring (ring linarith.comp)))) : has_exists_mul_of_le (has_to_string (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_111115 (h0 : functor.add_const (topological_space (complete_distrib_lattice linarith.comp)) linarith.comp) : @t1_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_111116 (h0 : functor.add_const (add_group (mul_zero_class pos)) Type) : @is_add_cyclic.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 1} (add_group.{0} (mul_zero_class.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_111117 (h0 : add_comm_semigroup enat -> add_comm_semigroup enat) (h1 : add_comm_semigroup enat) : function.is_fixed_pt h0 h1 := sorry --non-trivial
lemma new_lemma_111118 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (normed_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (normed_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_111119 (h0 : has_mem.mem (id (semiring (semiring (semiring num)))) has_emptyc.emptyc) : @rank_condition.{0} (@id.{2} Type (semiring.{0} (semiring.{0} (semiring.{0} num)))) (@finset.pi.empty.{1 0} Type ring.{0} (@id.{2} Type (semiring.{0} (semiring.{0} (semiring.{0} num)))) h0)  := sorry --non-trivial
lemma new_lemma_111120 (h0 : topological_space (random_gen (mul_one_class (random_gen (random_gen linarith.ineq))))) : t0_space (random_gen (mul_one_class (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_111121 (h0 : list (has_nndist (has_neg (finset pos)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_111122 (h0 : topological_space (boolean_algebra (has_add (ring linarith.comp)))) : discrete_topology (boolean_algebra (has_add (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_111123 (h0 : topological_space (has_neg_part (has_nndist (finset pos)))) : totally_disconnected_space (has_neg_part (has_nndist (finset pos))) := sorry --non-trivial
lemma new_lemma_111124 (h0 : functor.add_const (topological_space (boolean_algebra pos)) linarith.comp) : @preirreducible_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_111125 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @complete_space.{1} Type (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 uniform_space.{1}) Type)  := sorry --non-trivial
lemma new_lemma_111126 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (canonically_linear_ordered_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_linear_ordered_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_111127 (h0 : ordered_comm_monoid (has_to_string (finset (finset (finset pos))))) : has_exists_mul_of_le (has_to_string (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_111128 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (ordered_cancel_add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ordered_cancel_add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_111129 (h0 : list (finset (finset linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_111130 (h0 : uniform_space (has_bot (has_Inf Type))) : separated_space (has_bot (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_111131 (h0 : uniform_space (simple_graph pos)) : complete_space (simple_graph pos) := sorry --non-trivial
lemma new_lemma_111132 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_111133 (h0 : fin has_zero.zero) : t1_space real := sorry --non-trivial
lemma new_lemma_111134 (h0 : has_vadd char char) (h1 h2 : topological_space char) : has_continuous_vadd char char := sorry --non-trivial
lemma new_lemma_111135 (h0 : not (topological_space (semiring to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (semiring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_111136 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_111137 (h0 : topological_space (has_nndist (complete_distrib_lattice name))) : preirreducible_space (has_nndist (complete_distrib_lattice name)) := sorry --non-trivial
lemma new_lemma_111138 (h0 : group (comm_group ennreal)) : is_cyclic (comm_group ennreal) := sorry --non-trivial
lemma new_lemma_111139 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @t0_space.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_111140 (h0 : topological_space (mul_zero_class (finset environment.implicit_infer_kind))) : normal_space (mul_zero_class (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_111141 (h0 : topological_space (has_inv (linear_ordered_comm_ring (random_gen linarith.comp_source)))) : totally_disconnected_space (has_inv (linear_ordered_comm_ring (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_111142 (h0 : functor.add_const (uniform_space (finset linarith.comp)) name) : @complete_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (finset.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_111143 (h1 : not (uniform_space (semi_normed_comm_ring char) -> false)) : @complete_space.{0} (semi_normed_comm_ring.{0} char) (@classical.by_contradiction'.{1} (uniform_space.{0} (semi_normed_comm_ring.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_111144 (h0 : complete_lattice (ring (add_comm_monoid Type))) : is_compactly_generated (ring (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_111145 (h0 : fin has_zero.zero) : @totally_separated_space.{1} (canonically_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (canonically_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_111146 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (lattice.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_111147 (h0 : topological_space (add_cancel_monoid (option pos))) : totally_disconnected_space (add_cancel_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_111148 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_111149 (h1 : topological_space (canonically_ordered_monoid linarith.ineq)) : locally_compact_space (canonically_ordered_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_111150 (h0 : topological_space (plift (metric_space (option empty)))) : loc_path_connected_space (plift (metric_space (option empty))) := sorry --non-trivial
lemma new_lemma_111151 (h1 : comm_monoid_with_zero (normed_field ereal)) (h2 : normed_field ereal) : prime h2 := sorry --non-trivial
lemma new_lemma_111152 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_111153 (h0 : list (left_cancel_semigroup num)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_111154 (h0 : topological_space (pseudo_emetric_space pos)) : locally_compact_space (pseudo_emetric_space pos) := sorry --non-trivial
lemma new_lemma_111155 (h0 : functor.add_const (topological_space (monoid unsigned)) unsigned) : @locally_compact_space.{0} (monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_111156 (h0 : group (has_pos_part (has_Inf linarith.comp))) : is_cyclic (has_pos_part (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_111157 (h0 : group (has_Inf (finset (has_add pos)))) : normalizer_condition (has_Inf (finset (has_add pos))) := sorry --non-trivial
lemma new_lemma_111158 (h0 : Prop) (h1 : list Prop) (h2 : not (punit -> false) -> punit) (h3 : nonempty punit) : category_theory.hom_of_element (list.ilast' h0 h1) (classical.choice_of_by_contradiction' h2 h3) := sorry --non-trivial
lemma new_lemma_111159 (h0 : ring (normed_group string_imp)) : strong_rank_condition (normed_group string_imp) := sorry --non-trivial
lemma new_lemma_111160 (h0 : ring (add_cancel_monoid (has_add linarith.comp))) : rank_condition (add_cancel_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_111161 (h0 : topological_space name) : locally_compact_space name := sorry --non-trivial
lemma new_lemma_111162 (h0 : reducibility_hints -> reducibility_hints -> Prop) : is_extensional reducibility_hints h0 := sorry --non-trivial
lemma new_lemma_111163 (h0 : add_group (left_cancel_monoid (has_inner empty unsigned))) : is_add_cyclic (left_cancel_monoid (has_inner empty unsigned)) := sorry --non-trivial
lemma new_lemma_111164 (h1 : ring (comm_ring fun_info)) : rank_condition (comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_111165 (h0 : complete_lattice (topological_space reducibility_hints)) : complete_lattice.is_Sup_finite_compact (topological_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_111166 (h0 : topological_space (finset (has_nndist linarith.comp))) : preirreducible_space (finset (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_111167 (h0 : group (add_comm_monoid (has_add name))) : is_simple_group (add_comm_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_111168 (h0 : complete_lattice (metric_space (semiring congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (metric_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_111169 (h0 : ring (finset (has_nndist (has_add (has_add name))))) : rank_condition (finset (has_nndist (has_add (has_add name)))) := sorry --non-trivial
lemma new_lemma_111170 (h0 : function.extfun nat fin) : @complete_lattice.is_Sup_finite_compact.{0} (add_group.{0} (semiring.{0} unsigned)) (@matrix.vec_empty.{0} (complete_lattice.{0} (add_group.{0} (semiring.{0} unsigned))) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_111171 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (pseudo_metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (pseudo_metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_111172 (h0 : uniform_space (linear_ordered_semiring (random_gen (random_gen linarith.ineq)))) : separated_space (linear_ordered_semiring (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_111173 (h0 : topological_space (has_ssubset (random_gen (has_ssubset fun_info)))) : path_connected_space (has_ssubset (random_gen (has_ssubset fun_info))) := sorry --non-trivial
lemma new_lemma_111174 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_111175 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_111176 (h0 : topological_space (semi_normed_ring string.iterator_imp)) : t0_space (semi_normed_ring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_111177 (h0 : complete_lattice (normed_linear_ordered_group (option unsigned))) : is_atomistic (normed_linear_ordered_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_111178 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @irreducible_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_111179 (h0 : topological_space (boolean_algebra (has_to_string unsigned))) : preconnected_space (boolean_algebra (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_111180 (h1 : ring (with_one (has_ssubset (has_ssubset char)))) : rank_condition (with_one (has_ssubset (has_ssubset char))) := sorry --non-trivial
lemma new_lemma_111181 (h0 : add_group (semigroup (has_neg Type))) : is_add_cyclic (semigroup (has_neg Type)) := sorry --non-trivial
lemma new_lemma_111182 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_111183 (h0 : functor.add_const (semiring (has_bot linarith.comp)) (has_add (has_Inf linarith.comp))) : @is_noetherian_ring.{0} (has_bot.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (has_bot.{0} linarith.comp)) (has_add.{0} (has_Inf.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_111184 (h0 : uniform_space (complete_semilattice_Sup empty)) : separated_space (complete_semilattice_Sup empty) := sorry --non-trivial
lemma new_lemma_111185 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_111186 (h0 : function.extfun Type group) : @is_cyclic.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type group.{0} h0 (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_111187 (h1 : Prop) : set.separates_points (id (fun (h0 : add_comm_semigroup string.iterator_imp -> linarith.ineq), h1)) := sorry --non-trivial
lemma new_lemma_111188 (h0 : topological_space (comm_group (semigroup (has_add unsigned)))) : loc_path_connected_space (comm_group (semigroup (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_111189 (h0 : functor.add_const (semiring (boolean_algebra Type)) (ring Type)) : @is_noetherian_ring.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (semiring.{1} (boolean_algebra.{1} Type)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_111190 (h0 : not (topological_space (partial_order num) -> false)) : @t1_space.{0} (partial_order.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (partial_order.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_111191 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) name) : @regular_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_111192 (h0 : uniform_space (with_bot (semiring (semiring (semiring (semiring (semiring empty))))))) : complete_space (with_bot (semiring (semiring (semiring (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_111193 (h0 : semiring (nondiscrete_normed_field fun_info)) (h1 : add_group (star_ring (nondiscrete_normed_field fun_info))) : is_add_cyclic (star_ring (nondiscrete_normed_field fun_info)) := sorry --non-trivial
lemma new_lemma_111194 (h0 : functor.add_const (ring (option unsigned)) num) : @strong_rank_condition.{0} (option.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (option.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_111195 (h0 : uniform_space (sub_neg_monoid (has_add (has_add (has_Inf pos))))) : separated_space (sub_neg_monoid (has_add (has_add (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_111196 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (preorder ennreal)) := sorry --non-trivial
lemma new_lemma_111197 (h1 : set (uniform_space string_imp)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_111198 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_111199 (h0 : functor.add_const Prop (boolean_algebra.core congr_arg_kind)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_111200 (h0 : has_mem.mem (has_norm (has_norm unsigned)) has_emptyc.emptyc) : @totally_separated_space.{0} (has_norm.{0} (has_norm.{0} unsigned)) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} (has_norm.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_111201 (h0 : set (normed_field (mul_one_class enat))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_111202 (h0 : function.extfun Type ring) : @is_domain.{0} (add_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_111203 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_111204 (h0 : functor.add_const (topological_space (group_with_zero ennreal)) num) : @t1_space.{0} (group_with_zero.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (group_with_zero.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_111205 (h0 : functor.add_const (group (boolean_algebra linarith.comp)) linarith.comp) : @is_cyclic.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_111206 (h0 : set (distrib enat)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_111207 (h0 : functor.add_const (topological_space (add_cancel_monoid empty)) (option empty)) : @totally_separated_space.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_111208 (h0 : ereal -> ereal) : nonempty (function.bijective h0) := sorry --non-trivial
lemma new_lemma_111209 (h0 : functor.add_const (complete_lattice (option num)) num) : @is_atomistic.{0} (option.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (option.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_111210 (h0 : uniform_space (add_cancel_monoid (semiring empty))) : separated_space (add_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_111211 (h0 : topological_space (semiring linarith.comp)) : normal_space (semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_111212 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem monoid)) : @monoid.fg.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) monoid.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_111213 (h0 : function.extfun Type topological_space) : @t1_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_111214 (h0 : ordered_add_comm_monoid (boolean_algebra.core (has_to_string (ring (ring Type))))) : archimedean (boolean_algebra.core (has_to_string (ring (ring Type)))) := sorry --non-trivial
lemma new_lemma_111215 (h0 : function.extfun Type group) : @is_simple_group.{0} (option.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (option.{0} num))  := sorry --non-trivial
lemma new_lemma_111216 (h0 : group (linear_ordered_add_comm_group linarith.comp_source)) : is_cyclic (linear_ordered_add_comm_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_111217 (h0 : group (linear_ordered_comm_monoid_with_zero (option empty))) : normalizer_condition (linear_ordered_comm_monoid_with_zero (option empty)) := sorry --non-trivial
lemma new_lemma_111218 (h0 : functor.add_const (group pos) Type) : @is_cyclic.{0} pos (@functor.add_const.run.{0 1} (group.{0} pos) Type h0)  := sorry --non-trivial
lemma new_lemma_111219 (h0 : set (linarith.ineq -> boolean_algebra.core std_gen)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_111220 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (as_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (as_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_111221 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @path_connected_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_111222 (h1 : topological_space (denumerable (has_ssubset (has_ssubset (random_gen string_imp))))) : t0_space (denumerable (has_ssubset (has_ssubset (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_111223 (h0 : functor.add_const (ordered_comm_monoid (generalized_boolean_algebra pos)) (has_add name)) : @has_exists_mul_of_le.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (generalized_boolean_algebra.{0} pos)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_111224 (h0 : topological_space (add_comm_monoid (has_bot (has_Inf pos)))) : path_connected_space (add_comm_monoid (has_bot (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_111225 (h1 : ring (with_one linarith.comp_source)) : is_domain (with_one linarith.comp_source) := sorry --non-trivial
lemma new_lemma_111226 (h0 : not (topological_space (linear_ordered_comm_ring num) -> false)) : @normal_space.{0} (linear_ordered_comm_ring.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_ring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_111227 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_111228 (h0 : complete_lattice name) : complete_lattice.is_Sup_finite_compact name := sorry --non-trivial
lemma new_lemma_111229 (h0 : set (add_left_cancel_monoid (has_lt (mul_one_class linarith.comp_source)))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_111230 (h0 : has_lt (has_nnnorm ereal)) : no_max_order (has_nnnorm ereal) := sorry --non-trivial
lemma new_lemma_111231 (h0 : group (simple_graph (finset pos))) : normalizer_condition (simple_graph (finset pos)) := sorry --non-trivial
lemma new_lemma_111232 (h0 : add_group (with_one (has_norm fun_info))) : is_add_cyclic (with_one (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_111233 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_inv.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (has_inv.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_111234 (h0 : functor.add_const (monoid (has_to_string ennreal)) (has_neg ennreal)) : @monoid.fg.{0} (has_to_string.{0} ennreal) (@functor.add_const.run.{0 0} (monoid.{0} (has_to_string.{0} ennreal)) (has_neg.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_111235 (h0 : function.extfun ((finset Type -> Prop) -> Prop) (function.extfun (finset Type -> Prop))) : @monoid.fg.{0} (has_norm.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.ineq)))))) (@finset.pi.empty.{1 0} Type monoid.{0} (has_norm.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.ineq)))))) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.ineq))))))) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) (@function.extfun_app.{2 0} ((finset.{1} Type → Prop) → Prop) (function.extfun.{2 0} (finset.{1} Type → Prop)) h0 (function.extfun.{2 0} (finset.{1} Type))) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.ineq)))))))) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_111236 (h0 : add_group (generalized_boolean_algebra (finset linarith.comp))) : is_add_cyclic (generalized_boolean_algebra (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_111237 (h0 : ring (denumerable (has_ssubset (has_ssubset (random_gen to_additive.value_type))))) : strong_rank_condition (denumerable (has_ssubset (has_ssubset (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_111238 (h0 : ring (measurable_space (has_top (has_top (has_top (has_top linarith.comp_source)))))) : rank_condition (measurable_space (has_top (has_top (has_top (has_top linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_111239 (h0 : ring (linear_ordered_field pos) -> ring (linear_ordered_field pos) -> Prop) : is_symm (ring (linear_ordered_field pos)) h0 := sorry --non-trivial
lemma new_lemma_111240 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_111241 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_compactly_generated.{0} (linear_ordered_semiring.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} empty))))) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) complete_lattice.{0}) (linear_ordered_semiring.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} empty))))))  := sorry --non-trivial
lemma new_lemma_111242 (h0 : prod (has_nnnorm char) (has_nnnorm char)) : set.diagonal (has_nnnorm char) h0 := sorry --non-trivial
lemma new_lemma_111243 (h0 : ring (has_to_string (has_to_string (ring environment.implicit_infer_kind)))) : is_domain (has_to_string (has_to_string (ring environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_111244 (h0 : semiring (complete_distrib_lattice linarith.comp)) : is_noetherian_ring (complete_distrib_lattice linarith.comp) := sorry --non-trivial
lemma new_lemma_111245 (h0 : functor.add_const (ring (has_neg pos)) (has_add (has_to_string linarith.comp))) : @is_principal_ideal_ring.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} pos)) (has_add.{0} (has_to_string.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_111246 (h0 : function.extfun nat fin) : @is_add_cyclic.{0} (has_bot.{0} linarith.comp) (@matrix.vec_empty.{0} (add_group.{0} (has_bot.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_111247 (h0 : false) (h1 : group auto.case_option) : @topological_group.{0} auto.case_option (@false.elim.{1} (topological_space.{0} auto.case_option) h0) h1  := sorry --trivial
lemma new_lemma_111248 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) Type) : @separated_space.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) uniform_space.{1}) Type h0) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_111249 (h0 : semiring (normed_lattice_add_comm_group (has_add (has_add real)))) : is_noetherian_ring (normed_lattice_add_comm_group (has_add (has_add real))) := sorry --non-trivial
lemma new_lemma_111250 (h0 : fin has_zero.zero) : @regular_space.{0} (sub_neg_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_111251 (h0 : ring (normed_group (has_nnnorm (random_gen to_additive.value_type)))) : is_domain (normed_group (has_nnnorm (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_111252 (h0 : functor.add_const (function.extfun Type topological_space) name) : @irreducible_space.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_111253 (h0 : topological_space (ordered_comm_ring (has_neg (has_neg Type)))) : locally_compact_space (ordered_comm_ring (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_111254 (h1 : topological_space (has_inv char)) : t0_space (has_inv char) := sorry --non-trivial
lemma new_lemma_111255 (h0 : topological_space (add_cancel_monoid environment.implicit_infer_kind)) : topological_space.separable_space (add_cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_111256 (h0 : not (filter (linear_ordered_semiring num) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_111257 (h0 : list (mul_zero_class (boolean_algebra.core (finset Type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_111258 (h0 : topological_space (boolean_algebra (has_add (has_pos_part pos)))) : discrete_topology (boolean_algebra (has_add (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_111259 (h0 : measurable_space (add_comm_semigroup enat)) (h1 : set (add_comm_semigroup enat)) : measurable_set h1 := sorry --non-trivial
lemma new_lemma_111260 (h0 : functor.add_const (list (semigroup unsigned)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_111261 (h0 : function.extfun (Type 1) topological_space) : @topological_space.separable_space.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_111262 (h0 : topological_space (linear_ordered_comm_ring (semiring empty))) : t1_space (linear_ordered_comm_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_111263 (h0 : topological_space (add_cancel_monoid ennreal)) : discrete_topology (add_cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_111264 (h0 : not (topological_space (has_top congr_arg_kind) -> false)) : @irreducible_space.{0} (has_top.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_111265 (h0 : ordered_comm_monoid (pseudo_metric_space ennreal)) : has_exists_mul_of_le (pseudo_metric_space ennreal) := sorry --non-trivial
lemma new_lemma_111266 (h2 : set (has_compl linarith.comp_source)) : set.finite h2 := sorry --non-trivial
lemma new_lemma_111267 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (bin_tree.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (bin_tree.{0} empty))  := sorry --non-trivial
lemma new_lemma_111268 (h0 : topological_space (has_zero (has_add (finset ennreal)))) : totally_separated_space (has_zero (has_add (finset ennreal))) := sorry --non-trivial
lemma new_lemma_111269 (h0 : list (boolean_algebra.core (comm_group environment.implicit_infer_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_111270 (h0 : functor.add_const (function.extfun Type topological_space) (has_add (has_Inf (has_pos_part (has_pos_part pos))))) : @irreducible_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_add.{0} (has_Inf.{0} (has_pos_part.{0} (has_pos_part.{0} pos)))) h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_111271 (h0 : filter (canonically_ordered_comm_semiring (option (has_to_string ennreal)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_111272 (h0 : functor.add_const (add_group (normed_comm_ring name)) Type) : @is_add_cyclic.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 1} (add_group.{0} (normed_comm_ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_111273 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @irreducible_space.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_111274 (h0 : complete_lattice (has_norm (has_norm (random_gen (random_gen num))))) : complete_lattice.is_Sup_finite_compact (has_norm (has_norm (random_gen (random_gen num)))) := sorry --non-trivial
lemma new_lemma_111275 (h0 : functor.add_const (uniform_space (semigroup pos)) (has_to_string environment.implicit_infer_kind)) : @complete_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (semigroup.{0} pos)) (has_to_string.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_111276 (h0 : function.extfun Type (functor.comp complete_lattice has_neg_part)) : @is_atomistic.{0} (has_neg_part.{0} name) (@functor.comp.run.{0 0 0} complete_lattice.{0} has_neg_part.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} complete_lattice.{0} has_neg_part.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_111277 (h0 : not (topological_space (has_one unsigned) -> false)) : @t0_space.{0} (has_one.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_one.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_111278 (h0 : cancel_comm_monoid_with_zero (normed_comm_ring ennreal)) : unique_factorization_monoid (normed_comm_ring ennreal) := sorry --non-trivial
lemma new_lemma_111279 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @irreducible_space.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_111280 (h0 : topological_space (has_Inf (has_Inf Type))) : t0_space (has_Inf (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_111281 (h0 : not (topological_space (has_inv linarith.ineq) -> false)) : @path_connected_space.{0} (has_inv.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_inv.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_111282 (h0 : semiring (boolean_algebra (boolean_algebra linarith.comp))) : is_noetherian_ring (boolean_algebra (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_111283 (h0 : functor.add_const (topological_space nnreal) unsigned) : t1_space nnreal := sorry --non-trivial
lemma new_lemma_111284 (h0 : topological_space (has_top (with_one (random_gen string_imp)))) : locally_compact_space (has_top (with_one (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_111285 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_111286 (h1 : not (group (random_gen reducibility_hints) -> false)) : @is_cyclic.{0} (random_gen.{0} reducibility_hints) (@classical.by_contradiction'.{1} (group.{0} (random_gen.{0} reducibility_hints)) h1)  := sorry --non-trivial
lemma new_lemma_111287 (h0 : complete_lattice (comm_group (has_add pos))) : is_compactly_generated (comm_group (has_add pos)) := sorry --non-trivial
lemma new_lemma_111288 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @path_connected_space.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_111289 (h0 : topological_space (mul_zero_class (semiring (ordered_cancel_comm_monoid congr_arg_kind)))) : discrete_topology (mul_zero_class (semiring (ordered_cancel_comm_monoid congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_111290 (h0 : complete_lattice (has_to_string (finset linarith.comp))) : is_compactly_generated (has_to_string (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_111291 (h0 : topological_space (has_lt fun_info)) : totally_disconnected_space (has_lt fun_info) := sorry --non-trivial
lemma new_lemma_111292 (h0 : topological_space (has_top (semiring congr_arg_kind))) : t0_space (has_top (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_111293 (h0 : complete_lattice (add_comm_monoid (option num))) : is_compactly_generated (add_comm_monoid (option num)) := sorry --non-trivial
lemma new_lemma_111294 (h0 : functor.add_const (group (boolean_algebra environment.implicit_infer_kind)) unsigned) : @is_cyclic.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_111295 (h0 : functor.add_const (group Type) (ring pos)) : @is_cyclic.{1} Type (@functor.add_const.run.{1 0} (group.{1} Type) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_111296 (h0 : functor.add_const (monoid (boolean_algebra Type)) Type) : @monoid.fg.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (monoid.{1} (boolean_algebra.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_111297 (h0 : monoid (non_assoc_semiring num)) : monoid.fg (non_assoc_semiring num) := sorry --non-trivial
lemma new_lemma_111298 (h0 : function.extfun (Type 1) list) : list.nodup (function.extfun_app h0 (finset Type)) := sorry --non-trivial
lemma new_lemma_111299 (h0 : topological_space (comm_semigroup (has_pos_part pos))) : path_connected_space (comm_semigroup (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_111300 (h0 : functor.add_const (add_group (has_to_string Type)) (has_neg_part pos)) : @is_add_cyclic.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (has_to_string.{1} Type)) (has_neg_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_111301 (h0 : topological_space (finset (finset Type))) : totally_disconnected_space (finset (finset Type)) := sorry --non-trivial
lemma new_lemma_111302 (h0 : topological_space (ordered_comm_ring (has_neg linarith.comp))) : totally_disconnected_space (ordered_comm_ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_111303 (h0 : functor.add_const (function.extfun Type topological_space) (has_pos_part linarith.comp)) : @loc_path_connected_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_pos_part.{0} linarith.comp) h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_111304 (h0 : topological_space (add_comm_semigroup (add_comm_semigroup std_gen))) (h1 : preorder (add_comm_semigroup (add_comm_semigroup std_gen))) : order_topology (add_comm_semigroup (add_comm_semigroup std_gen)) := sorry --non-trivial
lemma new_lemma_111305 (h0 : topological_space (dlist char)) : t0_space (dlist char) := sorry --non-trivial
lemma new_lemma_111306 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (preorder.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (preorder.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_111307 (h0 : topological_space (has_nnnorm (has_nnnorm to_additive.value_type))) : path_connected_space (has_nnnorm (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_111308 (h1 : filter (has_add (has_nnnorm fun_info))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_111309 (h0 : function.extfun nat fin) : @unique_factorization_monoid.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (cancel_comm_monoid_with_zero.{1} (has_bot.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_111310 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_111311 (h0 : monoid (has_norm (random_gen (random_gen fun_info)))) : monoid.fg (has_norm (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_111312 (h0 : uniform_space (has_nndist (semiring empty))) : complete_space (has_nndist (semiring empty)) := sorry --non-trivial
lemma new_lemma_111313 (h0 : ordered_add_comm_monoid (has_to_string (normed_comm_ring name))) : archimedean (has_to_string (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_111314 (h0 : functor.add_const (filter (add_cancel_monoid name)) ennreal) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_111315 (h0 : functor.add_const (add_monoid (boolean_algebra pos)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (boolean_algebra.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_111316 (h0 : function.extfun Type topological_space) : @t0_space.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_111317 (h0 : semiring (left_cancel_semigroup congr_arg_kind)) : is_noetherian_ring (left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_111318 (h0 : topological_space (add_cancel_monoid linarith.comp)) : loc_path_connected_space (add_cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_111319 (h0 : functor.add_const (topological_space (has_nndist pos)) name) : @t0_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_111320 (h0 : topological_space (normed_comm_ring (option ennreal))) : t0_space (normed_comm_ring (option ennreal)) := sorry --non-trivial
lemma new_lemma_111321 (h0 : complete_lattice (add_cancel_monoid congr_arg_kind)) : is_compactly_generated (add_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_111322 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) (finset pos)) : @locally_compact_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_111323 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_111324 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_111325 (h0 : add_group (has_div (mul_one_class (mul_one_class (mul_one_class string.iterator_imp))))) : is_add_cyclic (has_div (mul_one_class (mul_one_class (mul_one_class string.iterator_imp)))) := sorry --non-trivial
lemma new_lemma_111326 (h1 : not (uniform_space (mul_one_class string_imp) -> false)) : @complete_space.{0} (mul_one_class.{0} string_imp) (@classical.by_contradiction'.{1} (uniform_space.{0} (mul_one_class.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_111327 (h0 : functor.add_const (ordered_add_comm_monoid (semigroup congr_arg_kind)) empty) : @archimedean.{0} (semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (semigroup.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_111328 (h0 : topological_space (normed_field (random_gen (has_nnnorm reducibility_hints)))) : path_connected_space (normed_field (random_gen (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_111329 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_111330 (h0 : group (add_cancel_comm_monoid (topological_space linarith.comp_source))) : is_cyclic (add_cancel_comm_monoid (topological_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_111331 (h0 : ring (semi_normed_ring (mul_one_class char))) : rank_condition (semi_normed_ring (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_111332 (h0 : set (has_compl linarith.comp_source)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_111333 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @t0_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_111334 (h0 : functor.add_const (group (partial_order congr_arg_kind)) unsigned) : @normalizer_condition.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (partial_order.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_111335 (h0 : topological_space (has_ssubset linarith.ineq)) : t0_space (has_ssubset linarith.ineq) := sorry --non-trivial
lemma new_lemma_111336 (h0 : function.extfun (finset Type) (has_mem.mem (has_one empty))) : @monoid.fg.{0} (has_one.{0} empty) (@finset.pi.empty.{1 0} Type monoid.{0} (has_one.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_111337 (h0 : semiring (id (semiring fun_info))) : is_noetherian_ring (id (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_111338 (h0 : not (filter (has_star unsigned) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_111339 (h0 : list (with_bot to_additive.value_type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_111340 (h0 : topological_space (add_comm_semigroup fun_info)) (h1 : preorder (add_comm_semigroup fun_info)) : order_topology (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_111341 (h0 : topological_space (comm_group (has_to_string unsigned))) : normal_space (comm_group (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_111342 (h0 : functor.add_const (function.extfun (Type 1) ring) Type) : @is_domain.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) Type h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_111343 (h0 : ring (has_neg_part Type)) : rank_condition (has_neg_part Type) := sorry --non-trivial
lemma new_lemma_111344 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_111345 (h0 : functor.add_const (ring (normed_comm_ring unsigned)) unsigned) : @strong_rank_condition.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_111346 (h0 : topological_space (semigroup ennreal)) : normal_space (semigroup ennreal) := sorry --non-trivial
lemma new_lemma_111347 (h1 : topological_space (nondiscrete_normed_field enat)) (h2 : add_group (nondiscrete_normed_field enat)) : topological_add_group (nondiscrete_normed_field enat) := sorry --non-trivial
lemma new_lemma_111348 (h3 : has_lt (mul_one_class (boolean_algebra.core string.iterator_imp))) : no_max_order (mul_one_class (boolean_algebra.core string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_111349 (h0 : filter (has_top (has_norm (has_inv to_additive.value_type)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_111350 (h1 : ring (has_inv string_imp)) : rank_condition (has_inv string_imp) := sorry --non-trivial
lemma new_lemma_111351 (h0 : char -> char -> Prop) : is_trans char h0 := sorry --non-trivial
lemma new_lemma_111352 (h0 : functor.add_const (topological_space (has_neg environment.implicit_infer_kind)) pos) : @topological_space.separable_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_111353 (h0 : topological_space (fintype (has_nnnorm (fintype (has_append linarith.ineq))))) : totally_disconnected_space (fintype (has_nnnorm (fintype (has_append linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_111354 (h0 : finset (has_neg (has_neg (has_Inf (has_neg Type))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_111355 (h0 : topological_space (metric_space (semiring unsigned))) : normal_space (metric_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_111356 (h0 : complete_lattice (ordered_ring empty)) : complete_lattice.is_Sup_finite_compact (ordered_ring empty) := sorry --non-trivial
lemma new_lemma_111357 (h0 : topological_space (add_cancel_monoid (boolean_algebra name))) : preconnected_space (add_cancel_monoid (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_111358 (h0 : topological_space (random_gen (semiring (has_top num)))) : normal_space (random_gen (semiring (has_top num))) := sorry --non-trivial
lemma new_lemma_111359 (h0 : ring (has_ssubset (has_top fun_info))) : rank_condition (has_ssubset (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_111360 (h0 : functor.add_const (topological_space (has_add Type)) (add_cancel_monoid Type)) : @t0_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_add.{1} Type)) (add_cancel_monoid.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_111361 (h0 : cancel_comm_monoid_with_zero (complete_linear_order empty)) : unique_factorization_monoid (complete_linear_order empty) := sorry --non-trivial
lemma new_lemma_111362 (h0 : prod (linear_ordered_comm_ring (semiring congr_arg_kind)) (linear_ordered_comm_ring (semiring congr_arg_kind))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_111363 (h0 : functor.add_const (topological_space (finset pos)) linarith.comp) : @loc_path_connected_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_111364 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_atomistic.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_111365 (h0 : ring (has_to_string (ring (ring Type)))) : strong_rank_condition (has_to_string (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_111366 (h0 : functor.add_const (ring (left_cancel_monoid congr_arg_kind)) congr_arg_kind) : @rank_condition.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_111367 (h0 : uniform_space (linear_ordered_field unsigned)) : complete_space (linear_ordered_field unsigned) := sorry --non-trivial
lemma new_lemma_111368 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (comm_ring.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_ring.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_111369 (h0 : topological_space (has_zero (finset environment.implicit_infer_kind))) : totally_disconnected_space (has_zero (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_111370 (h0 : nnreal -> empty -> empty) : left_commutative h0 := sorry --non-trivial
lemma new_lemma_111371 (h0 : monoid (ordered_comm_ring (has_add (has_pos_part (has_pos_part Type))))) : monoid.fg (ordered_comm_ring (has_add (has_pos_part (has_pos_part Type)))) := sorry --non-trivial
lemma new_lemma_111372 (h0 : topological_space (cancel_monoid (cancel_monoid (has_nndist ennreal)))) : normal_space (cancel_monoid (cancel_monoid (has_nndist ennreal))) := sorry --non-trivial
lemma new_lemma_111373 (h0 : function.extfun nat fin) : @add_monoid.fg.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (add_monoid.{1} (has_bot.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_111374 (h0 : ordered_add_comm_monoid (normed_comm_ring (option (option unsigned)))) : archimedean (normed_comm_ring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_111375 (h0 : semiring (has_pos_part (has_Inf (has_neg pos)))) : is_noetherian_ring (has_pos_part (has_Inf (has_neg pos))) := sorry --non-trivial
lemma new_lemma_111376 (h0 : topological_space (has_nndist (mul_zero_class (mul_zero_class pos)))) : totally_disconnected_space (has_nndist (mul_zero_class (mul_zero_class pos))) := sorry --non-trivial
lemma new_lemma_111377 (h0 : ring (add_group (semiring (semiring num)))) : strong_rank_condition (add_group (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_111378 (h0 : uniform_space (has_union (has_norm linarith.comp))) : complete_space (has_union (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_111379 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_111380 (h0 : function.extfun Type topological_space) : @normal_space.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_111381 (h0 : topological_space (has_add num)) : preconnected_space (has_add num) := sorry --non-trivial
lemma new_lemma_111382 (h0 : comm_semiring (has_nnnorm (random_gen linarith.ineq))) (h1 : topological_space (encodable (linear_recurrence (has_nnnorm (random_gen linarith.ineq))))) : locally_compact_space (encodable (linear_recurrence (has_nnnorm (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_111383 (h0 : complete_lattice (boolean_algebra.core congr_arg_kind)) : is_atomistic (boolean_algebra.core congr_arg_kind) := sorry --non-trivial
lemma new_lemma_111384 (h0 : functor.add_const (topological_space (ordered_ring num)) unsigned) : @normal_space.{0} (ordered_ring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_111385 (h0 : filter (semiring linarith.comp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_111386 : nonempty congr_arg_kind := sorry --simp
lemma new_lemma_111387 (h0 : ordered_add_comm_monoid (linear_ordered_field (option (option pos)))) : archimedean (linear_ordered_field (option (option pos))) := sorry --non-trivial
lemma new_lemma_111388 (h0 : group (measurable_space (has_norm empty))) : group.fg (measurable_space (has_norm empty)) := sorry --non-trivial
lemma new_lemma_111389 (h0 : topological_space (simple_graph ereal)) : t0_space (simple_graph ereal) := sorry --non-trivial
lemma new_lemma_111390 (h0 : functor.add_const (topological_space (cancel_monoid ennreal)) ennreal) : @path_connected_space.{0} (cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_111391 (h0 : topological_space (ordered_comm_monoid (has_neg (ring pos)))) : preirreducible_space (ordered_comm_monoid (has_neg (ring pos))) := sorry --non-trivial
lemma new_lemma_111392 (h0 : uniform_space (has_Inf (has_pos_part linarith.comp))) : complete_space (has_Inf (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_111393 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} name (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) name)  := sorry --non-trivial
lemma new_lemma_111394 (h0 : group (with_one (random_gen string_imp))) : normalizer_condition (with_one (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_111395 (h0 : function.extfun (Type 1) add_group) : @is_add_cyclic.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} h0 (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_111396 (h0 : functor.add_const (cancel_comm_monoid_with_zero (boolean_algebra pos)) name) : @unique_factorization_monoid.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (boolean_algebra.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_111397 (h0 : ring (has_to_string (normed_comm_ring (cancel_monoid environment.implicit_infer_kind)))) : rank_condition (has_to_string (normed_comm_ring (cancel_monoid environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_111398 (h0 : functor.add_const (group (comm_group pos)) name) : @group.fg.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_111399 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_111400 (h0 : ring (cancel_monoid (has_nndist ennreal))) : strong_rank_condition (cancel_monoid (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_111401 (h0 : ring (has_norm unsigned)) : is_domain (has_norm unsigned) := sorry --non-trivial
lemma new_lemma_111402 (h0 : functor.add_const (complete_lattice (boolean_algebra pos)) name) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_111403 (h1 : group (normed_field (normed_field (has_nnnorm (has_nnnorm (random_gen reducibility_hints)))))) : is_cyclic (normed_field (normed_field (has_nnnorm (has_nnnorm (random_gen reducibility_hints))))) := sorry --non-trivial
lemma new_lemma_111404 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_111405 (h0 : group (option (semiring (semiring (semiring (semiring num)))))) : normalizer_condition (option (semiring (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_111406 (h0 : functor.add_const (topological_space (semigroup name)) (has_neg Type)) : @loc_path_connected_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} name)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_111407 (h0 : group (random_gen (has_inv linarith.comp_source))) : normalizer_condition (random_gen (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_111408 (h2 : topological_space (has_top (has_top string_imp))) : locally_compact_space (has_top (has_top string_imp)) := sorry --non-trivial
lemma new_lemma_111409 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_111410 (h0 : function.extfun Type (functor.add_const (topological_space (linear_order unsigned)))) : @totally_disconnected_space.{0} (linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_order.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (linear_order.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_111411 (h0 : ordered_comm_monoid (canonically_ordered_comm_semiring unsigned)) : has_exists_mul_of_le (canonically_ordered_comm_semiring unsigned) := sorry --non-trivial
lemma new_lemma_111412 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_111413 (h0 : functor.add_const (function.extfun Type group) unsigned) : @group.fg.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) unsigned h0) (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_111414 (h0 : uniform_space (comm_group (ring linarith.comp))) : complete_space (comm_group (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_111415 (h0 : topological_space (has_neg_part (add_cancel_monoid (has_add unsigned)))) : totally_separated_space (has_neg_part (add_cancel_monoid (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_111416 (h0 : linear_order linarith.comp_source -> linear_order linarith.comp_source -> Prop) (h1 : has_top (has_top num) -> linear_order linarith.comp_source) : directed h0 h1 := sorry --non-trivial
lemma new_lemma_111417 (h0 : add_group (has_union (semiring num))) : is_add_cyclic (has_union (semiring num)) := sorry --non-trivial
lemma new_lemma_111418 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_neg name)) := sorry --non-trivial
lemma new_lemma_111419 (h0 : functor.add_const (complete_lattice (has_zero linarith.comp)) name) : @is_atomistic.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_111420 (h1 : complete_lattice (with_one (with_bot to_additive.value_type))) : is_compactly_generated (with_one (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_111421 (h0 : functor.add_const (filter (add_comm_monoid Type)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_111422 (h0 : ring (distrib_lattice (has_nnnorm char))) : rank_condition (distrib_lattice (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_111423 (h0 : functor.add_const (complete_lattice (cancel_monoid Type)) (has_add environment.implicit_infer_kind)) : @is_atomistic.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (cancel_monoid.{1} Type)) (has_add.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_111424 (h0 : monoid (has_neg_part (has_add (semigroup Type)))) : monoid.fg (has_neg_part (has_add (semigroup Type))) := sorry --non-trivial
lemma new_lemma_111425 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_111426 (h0 : add_group (complete_distrib_lattice (has_Inf pos))) : is_add_cyclic (complete_distrib_lattice (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_111427 (h0 : group (metric_space (semiring unsigned))) : is_cyclic (metric_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_111428 (h0 : functor.add_const (monoid (cancel_monoid pos)) Type) : @monoid.fg.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (monoid.{0} (cancel_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_111429 (h0 : not (topological_space (linear_ordered_semiring unsigned) -> false)) : @discrete_topology.{0} (linear_ordered_semiring.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_111430 (h0 : functor.add_const (semiring (ordered_ring unsigned)) congr_arg_kind) : @is_noetherian_ring.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (ordered_ring.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_111431 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (complete_semilattice_Sup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (complete_semilattice_Sup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_111432 (h0 : functor.add_const (topological_space (metric_space congr_arg_kind)) num) : @t0_space.{0} (metric_space.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (metric_space.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_111433 (h0 : functor.add_const (semiring (has_zero linarith.comp)) (has_neg (has_nndist (finset linarith.comp)))) : @is_noetherian_ring.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (has_zero.{0} linarith.comp)) (has_neg.{0} (has_nndist.{0} (finset.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_111434 (h0 : not (ring (plift empty) -> false)) : @rank_condition.{1} (plift.{1} empty) (@classical.by_contradiction'.{2} (ring.{1} (plift.{1} empty)) h0)  := sorry --non-trivial
lemma new_lemma_111435 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_111436 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @discrete_topology.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_111437 (h0 : functor.add_const (topological_space (has_to_string name)) name) : @irreducible_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_111438 (h0 : group (denumerable (id string_imp))) : normalizer_condition (denumerable (id string_imp)) := sorry --non-trivial
lemma new_lemma_111439 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_111440 (h0 : functor.add_const (complete_lattice (measurable_space.dynkin_system unsigned)) unsigned) : @is_compactly_generated.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (measurable_space.dynkin_system.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_111441 (h0 : uniform_space (comm_ring (has_nnnorm linarith.ineq))) : complete_space (comm_ring (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_111442 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) linarith.comp) : @t1_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_111443 (h0 : has_mem.mem (normed_group to_additive.value_type) has_emptyc.emptyc) : @rank_condition.{0} (normed_group.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type ring.{0} (normed_group.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_111444 (h0 : uniform_space (has_norm string_imp)) : complete_space (has_norm string_imp) := sorry --non-trivial
lemma new_lemma_111445 (h0 : complete_lattice (has_top (semiring num))) : is_atomistic (has_top (semiring num)) := sorry --non-trivial
lemma new_lemma_111446 (h0 : cancel_comm_monoid_with_zero (normed_comm_ring unsigned)) : unique_factorization_monoid (normed_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_111447 (h0 : not (function.extfun Type list -> false)) : list.nodup (function.extfun_app (classical.by_contradiction' h0) (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_111448 (h0 : monoid (has_add (has_neg environment.implicit_infer_kind))) : monoid.fg (has_add (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_111449 (h0 : topological_space (has_neg_part (has_add Type))) : preconnected_space (has_neg_part (has_add Type)) := sorry --non-trivial
lemma new_lemma_111450 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (ordered_ring.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_ring.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_111451 (h0 : list (normed_comm_ring (has_neg_part (comm_group (has_neg_part pos))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_111452 (h0 : add_comm_semigroup linarith.ineq -> add_comm_semigroup linarith.ineq -> Prop) : is_irrefl (add_comm_semigroup linarith.ineq) h0 := sorry --non-trivial
lemma new_lemma_111453 (h0 : topological_space (has_Inf (ring (has_Inf name)))) : normal_space (has_Inf (ring (has_Inf name))) := sorry --non-trivial
lemma new_lemma_111454 (h0 : complete_lattice (with_one ereal)) : is_compactly_generated (with_one ereal) := sorry --non-trivial
lemma new_lemma_111455 (h0 : functor.add_const (finset (has_add environment.implicit_infer_kind)) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_111456 (h0 : topological_space (comm_group (finset Type))) : totally_disconnected_space (comm_group (finset Type)) := sorry --non-trivial
lemma new_lemma_111457 (h0 : semiring (ring (comm_group Type))) : is_noetherian_ring (ring (comm_group Type)) := sorry --non-trivial
lemma new_lemma_111458 (h2 : group (has_append char)) : is_cyclic (has_append char) := sorry --non-trivial
lemma new_lemma_111459 (h0 : functor.add_const (topological_space (normed_linear_ordered_group congr_arg_kind)) unsigned) : @discrete_topology.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_111460 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_111461 (h0 : functor.add_const (topological_space (has_zero unsigned)) environment.implicit_infer_kind) : @normal_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_111462 (h0 : add_group (random_gen (with_bot empty))) : is_add_cyclic (random_gen (with_bot empty)) := sorry --non-trivial
lemma new_lemma_111463 (h0 : not (complete_lattice (has_compl reducibility_hints) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_compl.{0} reducibility_hints) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_compl.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_111464 (h0 : uniform_space (has_add (finset (has_Inf linarith.comp)))) : separated_space (has_add (finset (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_111465 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_111466 (h0 : functor.add_const (topological_space (ordered_ring congr_arg_kind)) empty) : @loc_path_connected_space.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_111467 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (ring ennreal)) := sorry --non-trivial
lemma new_lemma_111468 (h0 : ring (ordered_cancel_add_comm_monoid num)) : rank_condition (ordered_cancel_add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_111469 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_111470 (h1 : not (topological_space (linear_ordered_semiring fun_info) -> false)) : @totally_separated_space.{0} (linear_ordered_semiring.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_111471 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) h0) (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_111472 (h0 : function.extfun (Type 1) finset) : finset.nonempty (function.extfun_app h0 (normed_lattice_add_comm_group Type)) := sorry --non-trivial
lemma new_lemma_111473 (h0 : function.extfun Type ring) : @is_domain.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_111474 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (is_R_or_C.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (is_R_or_C.{0} empty))  := sorry --non-trivial
lemma new_lemma_111475 (h0 : complete_lattice (encodable string_imp)) : complete_lattice.is_Sup_finite_compact (encodable string_imp) := sorry --non-trivial
lemma new_lemma_111476 (h0 : set (has_le ereal)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_111477 (h0 : add_monoid (ring (has_pos_part pos))) : add_monoid.fg (ring (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_111478 (h0 : group (add_comm_monoid (finset Type))) : is_simple_group (add_comm_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_111479 (h0 : topological_space (ordered_comm_ring name)) : normal_space (ordered_comm_ring name) := sorry --non-trivial
lemma new_lemma_111480 (h0 : monoid (with_bot (has_top (has_top linarith.ineq)))) : monoid.fg (with_bot (has_top (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_111481 (h0 : topological_space (ordered_comm_monoid (finset linarith.comp))) : t0_space (ordered_comm_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_111482 (h0 : topological_space (has_one (semiring linarith.comp))) : t0_space (has_one (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_111483 (h0 : topological_space (has_edist num)) : t0_space (has_edist num) := sorry --non-trivial
lemma new_lemma_111484 (h0 : add_group (measurable_space.dynkin_system (semiring (semiring num)))) : is_add_cyclic (measurable_space.dynkin_system (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_111485 (h0 : list (has_inter (option (option empty)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_111486 (h0 : functor.add_const (add_monoid (has_nndist environment.implicit_infer_kind)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_nndist.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_111487 (h0 : topological_space (has_norm (random_gen (has_top congr_arg_kind)))) : totally_separated_space (has_norm (random_gen (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_111488 (h0 : complete_lattice (has_compl (mul_one_class to_additive.value_type))) : is_compactly_generated (has_compl (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_111489 (h0 : uniform_space (boolean_algebra (has_Inf (has_pos_part (ring linarith.comp))))) : separated_space (boolean_algebra (has_Inf (has_pos_part (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_111490 (h0 : topological_space char) : topological_space.first_countable_topology char := sorry --non-trivial
lemma new_lemma_111491 (h0 : functor.add_const (complete_lattice (filter empty)) num) : is_atomistic (filter empty) := sorry --non-trivial
lemma new_lemma_111492 (h0 : not (ring (id (has_top (semiring (has_top (has_top (has_top unsigned)))))) -> false)) : @rank_condition.{0} (@id.{2} Type (has_top.{0} (semiring.{0} (has_top.{0} (has_top.{0} (has_top.{0} unsigned)))))) (@classical.by_contradiction'.{1} (ring.{0} (@id.{2} Type (has_top.{0} (semiring.{0} (has_top.{0} (has_top.{0} (has_top.{0} unsigned))))))) h0)  := sorry --non-trivial
lemma new_lemma_111493 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_111494 (h0 : function.extfun Type (prod (partial_order empty))) : id_rel (function.extfun_app h0 (partial_order empty)) := sorry --non-trivial
lemma new_lemma_111495 (h0 : add_group (linear_ordered_add_comm_group string_imp)) : is_add_cyclic (linear_ordered_add_comm_group string_imp) := sorry --non-trivial
lemma new_lemma_111496 (h1 : ring (has_ssubset linarith.ineq)) : rank_condition (has_ssubset linarith.ineq) := sorry --non-trivial
lemma new_lemma_111497 (h0 : functor.comp topological_space has_nndist pos) : @locally_compact_space.{0} (has_nndist.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_111498 (h0 : set (complete_distrib_lattice string.iterator_imp)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_111499 (h0 : add_group (random_gen (mul_one_class reducibility_hints))) : is_add_cyclic (random_gen (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_111500 (h1 : function.extfun Type topological_space) : @t0_space.{0} (encodable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (encodable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_111501 (h0 : functor.add_const (function.extfun Type add_monoid) Type) : @add_monoid.fg.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type add_monoid.{0}) Type h0) (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_111502 (h0 : group (ring (ring (ring Type)))) : is_simple_group (ring (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_111503 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_111504 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_111505 (h0 : not (filter (lattice unsigned) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_111506 (h0 : functor.add_const (topological_space (complete_distrib_lattice environment.implicit_infer_kind)) Type) : @normal_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_111507 (h0 : uniform_space (has_bot (has_add (has_bot real)))) : complete_space (has_bot (has_add (has_bot real))) := sorry --non-trivial
lemma new_lemma_111508 (h0 : group (semigroup (cancel_monoid (option name)))) : normalizer_condition (semigroup (cancel_monoid (option name))) := sorry --non-trivial
lemma new_lemma_111509 (h0 : functor.add_const (topological_space (ring pos)) ennreal) : @irreducible_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_111510 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (linear_ordered_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_111511 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (measure_theory.measure_space.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (measure_theory.measure_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_111512 (h0 : measurable_space (add_comm_semigroup char)) (h1 : set (add_comm_semigroup char)) : measurable_set h1 := sorry --non-trivial
lemma new_lemma_111513 (h0 : functor.comp ordered_add_comm_monoid has_neg_part (ring unsigned)) : @archimedean.{0} (has_neg_part.{0} (ring.{0} unsigned)) (@functor.comp.run.{0 0 0} ordered_add_comm_monoid.{0} has_neg_part.{0} (ring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_111514 (h0 : topological_space (has_nnnorm (mul_one_class (mul_one_class linarith.comp_source)))) : path_connected_space (has_nnnorm (mul_one_class (mul_one_class linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_111515 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_111516 (h0 : ring (ordered_comm_ring (canonically_linear_ordered_monoid real))) : is_principal_ideal_ring (ordered_comm_ring (canonically_linear_ordered_monoid real)) := sorry --non-trivial
lemma new_lemma_111517 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_111518 (h0 : topological_space (has_neg_part unsigned)) : totally_disconnected_space (has_neg_part unsigned) := sorry --non-trivial
lemma new_lemma_111519 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_111520 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_111521 (h0 : complete_lattice (with_one (semiring empty))) : is_compactly_generated (with_one (semiring empty)) := sorry --non-trivial
lemma new_lemma_111522 (h0 : functor.add_const (function.extfun (Type 1) semiring) environment.implicit_infer_kind) : @is_noetherian_ring.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) semiring.{1}) environment.implicit_infer_kind h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_111523 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_111524 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_111525 (h0 : ring (has_pos_part Type)) : rank_condition (has_pos_part Type) := sorry --non-trivial
lemma new_lemma_111526 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_111527 (h0 : function.extfun Type ring) : @rank_condition.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_111528 (h0 : topological_space (encodable (has_nnnorm fun_info))) : path_connected_space (encodable (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_111529 (h0 : group (has_pos_part (has_Inf (has_Inf name)))) : group.fg (has_pos_part (has_Inf (has_Inf name))) := sorry --non-trivial
lemma new_lemma_111530 (h0 : functor.add_const (ring (canonically_linear_ordered_monoid ennreal)) num) : @is_domain.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (canonically_linear_ordered_monoid.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_111531 (h0 : function.extfun Type group) : @normalizer_condition.{0} (measure_theory.measure_space.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (measure_theory.measure_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_111532 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @path_connected_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_111533 (h0 : topological_space (has_neg (finset name))) : irreducible_space (has_neg (finset name)) := sorry --non-trivial
lemma new_lemma_111534 (h0 : topological_space (has_neg (ring Type))) : regular_space (has_neg (ring Type)) := sorry --non-trivial
lemma new_lemma_111535 (h0 : functor.add_const (topological_space (finset pos)) linarith.comp) : @totally_disconnected_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_111536 (h0 : ordered_add_comm_monoid (complete_distrib_lattice (has_nndist linarith.comp))) : archimedean (complete_distrib_lattice (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_111537 (h0 : ring (add_cancel_monoid (has_nndist pos))) : rank_condition (add_cancel_monoid (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_111538 (h0 : topological_space (complete_distrib_lattice Type)) : irreducible_space (complete_distrib_lattice Type) := sorry --non-trivial
lemma new_lemma_111539 (h1 : has_mem.mem num has_emptyc.emptyc) : @irreducible_space.{0} num (@finset.pi.empty.{1 0} Type topological_space.{0} num h1)  := sorry --non-trivial
lemma new_lemma_111540 (h1 : add_group (denumerable linarith.ineq)) : is_add_cyclic (denumerable linarith.ineq) := sorry --non-trivial
lemma new_lemma_111541 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_111542 (h0 : add_group (normed_comm_ring (metric_space (has_Inf (has_pos_part linarith.comp))))) : is_add_cyclic (normed_comm_ring (metric_space (has_Inf (has_pos_part linarith.comp)))) := sorry --non-trivial
lemma new_lemma_111543 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) linarith.comp) : @preirreducible_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_111544 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_111545 (h0 : topological_space (has_lt string_imp)) : path_connected_space (has_lt string_imp) := sorry --non-trivial
lemma new_lemma_111546 (h1 : topological_space (has_norm (random_gen string_imp))) : t0_space (has_norm (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_111547 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_111548 (h0 : filter (has_Sup empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_111549 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @totally_separated_space.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_111550 (h0 : topological_space (topological_space (random_gen to_additive.value_type))) : totally_disconnected_space (topological_space (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_111551 (h0 : topological_space (has_le ereal)) : t0_space (has_le ereal) := sorry --non-trivial
lemma new_lemma_111552 (h0 : complete_lattice (left_cancel_semigroup congr_arg_kind)) : is_atomistic (left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_111553 (h0 : topological_space (has_inter empty)) : irreducible_space (has_inter empty) := sorry --non-trivial
lemma new_lemma_111554 (h0 : has_mem.mem Prop has_zero.zero) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@multiset.pi.empty.{1 0} Type filter.{0} Prop h0)  := sorry --non-trivial
lemma new_lemma_111555 (h0 : topological_space (has_neg (finset pos))) : preirreducible_space (has_neg (finset pos)) := sorry --non-trivial
lemma new_lemma_111556 (h0 : not (topological_space (complete_semilattice_Sup linarith.comp_source) -> false)) : @totally_separated_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_111557 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_111558 (h0 : has_mem.mem ring has_emptyc.emptyc) : @rank_condition.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_111559 (h1 : not (ring (semi_normed_ring char) -> false)) : @is_domain.{0} (semi_normed_ring.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_ring.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_111560 (h0 : group (sub_neg_monoid (has_add (has_neg name)))) : is_simple_group (sub_neg_monoid (has_add (has_neg name))) := sorry --non-trivial
lemma new_lemma_111561 (h0 : multiset (uniform_space reducibility_hints)) (h1 : not (multiset (uniform_space reducibility_hints) -> false)) : multiset.disjoint h0 (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_111562 (h0 : functor.comp ring has_nndist unsigned) : @is_principal_ideal_ring.{0} (has_nndist.{0} unsigned) (@functor.comp.run.{0 0 0} ring.{0} has_nndist.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_111563 (h0 : group (has_nndist (has_neg ennreal))) : group.fg (has_nndist (has_neg ennreal)) := sorry --non-trivial
lemma new_lemma_111564 (h0 : complete_lattice (has_append (comm_ring (denumerable char)))) : complete_lattice.is_Sup_finite_compact (has_append (comm_ring (denumerable char))) := sorry --non-trivial
lemma new_lemma_111565 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_111566 (h0 : topological_space (measurable_space.dynkin_system (partial_order empty))) : locally_compact_space (measurable_space.dynkin_system (partial_order empty)) := sorry --non-trivial
lemma new_lemma_111567 (h0 : functor.add_const (group (has_neg_part Type)) linarith.comp) : @is_cyclic.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_neg_part.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_111568 (h0 : ring (with_one (random_gen linarith.comp))) : strong_rank_condition (with_one (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_111569 (h0 : complete_lattice (has_top (has_norm (has_top linarith.comp_source)))) : is_atomistic (has_top (has_norm (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_111570 (h0 : set (mul_one_class (add_comm_semigroup (add_comm_semigroup ereal)))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_111571 (h0 : group (complete_semilattice_Sup (has_nnnorm fun_info))) : group.fg (complete_semilattice_Sup (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_111572 (h0 : not (ring (has_top num) -> false)) : @strong_rank_condition.{0} (has_top.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (has_top.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_111573 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_111574 (h0 : complete_lattice (normed_field (comm_ring linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (normed_field (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_111575 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (group_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (group_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_111576 (h0 : monoid (complete_semilattice_Sup congr_arg_kind)) : monoid.fg (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_111577 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (group_with_zero.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (group_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_111578 (h0 : has_neg (semiring congr_arg_kind)) (h1 : measurable_space (semiring congr_arg_kind)) : has_measurable_neg (semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_111579 (h0 : functor.add_const (topological_space (free_add_monoid num)) num) : @topological_space.separable_space.{0} (free_add_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_111580 (h0 : functor.add_const (finset (add_cancel_monoid unsigned)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_111581 (h0 : ring (has_top (dlist (has_norm (has_top (dlist to_additive.value_type)))))) : is_domain (has_top (dlist (has_norm (has_top (dlist to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_111582 (h0 : topological_space (topological_space char)) : path_connected_space (topological_space char) := sorry --non-trivial
lemma new_lemma_111583 (h0 : not (group (with_one linarith.ineq) -> false)) : @is_cyclic.{0} (with_one.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (with_one.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_111584 (h0 : fin has_zero.zero) : @group.fg.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (group.{1} (generalized_boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_111585 (h0 : complete_lattice (canonically_ordered_comm_semiring (option pos))) : is_compactly_generated (canonically_ordered_comm_semiring (option pos)) := sorry --non-trivial
lemma new_lemma_111586 (h0 : topological_space (canonically_ordered_comm_semiring (finset Type))) : totally_disconnected_space (canonically_ordered_comm_semiring (finset Type)) := sorry --non-trivial
lemma new_lemma_111587 (h0 : topological_space (complete_linear_order num)) : discrete_topology (complete_linear_order num) := sorry --non-trivial
lemma new_lemma_111588 (h0 : functor.add_const (filter (ordered_comm_monoid Type)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_111589 (h0 : topological_space (has_neg (ring (has_pos_part (has_pos_part (has_pos_part linarith.comp)))))) : locally_compact_space (has_neg (ring (has_pos_part (has_pos_part (has_pos_part linarith.comp))))) := sorry --non-trivial
lemma new_lemma_111590 (h0 : functor.add_const (monoid (has_to_string pos)) (has_to_string name)) : @monoid.fg.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (has_to_string.{0} pos)) (has_to_string.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_111591 (h0 : finset (complete_semilattice_Sup congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_111592 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} h0 (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_111593 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_111594 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} h0 (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_111595 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) (ring (has_neg name))) : @t0_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) (ring.{0} (has_neg.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_111596 (h0 : uniform_space (has_nndist ennreal)) : separated_space (has_nndist ennreal) := sorry --non-trivial
lemma new_lemma_111597 (h0 : functor.add_const (ring (is_R_or_C num)) congr_arg_kind) : @strong_rank_condition.{0} (is_R_or_C.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (is_R_or_C.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_111598 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_111599 (h2 : ring (semi_normed_comm_ring (random_gen char))) : is_domain (semi_normed_comm_ring (random_gen char)) := sorry --non-trivial
lemma new_lemma_111600 (h0 : complete_lattice (mul_zero_class (semiring empty))) : is_atomistic (mul_zero_class (semiring empty)) := sorry --non-trivial
lemma new_lemma_111601 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_111602 (h0 : functor.add_const (filter (add_semigroup empty)) empty) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_111603 (h1 : topological_space (has_add char)) : totally_disconnected_space (has_add char) := sorry --non-trivial
lemma new_lemma_111604 (h0 : option (topological_space (semigroup name))) (h1 : functor.comp topological_space semigroup name) : @topological_space.separable_space.{0} (semigroup.{0} name) (@option.get_or_else.{0} (topological_space.{0} (semigroup.{0} name)) h0 (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} name h1))  := sorry --non-trivial
lemma new_lemma_111605 (h0 : ring (has_bot (sub_neg_monoid real))) : is_domain (has_bot (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_111606 (h0 : add_group (dlist char)) : is_add_cyclic (dlist char) := sorry --non-trivial
lemma new_lemma_111607 (h0 : group (comm_group name)) : normalizer_condition (comm_group name) := sorry --non-trivial
lemma new_lemma_111608 (h0 : functor.add_const (group (ring Type)) (ring (has_add Type))) : @is_cyclic.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (ring.{1} Type)) (ring.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_111609 (h0 : complete_lattice (semiring (has_norm empty))) : is_atomistic (semiring (has_norm empty)) := sorry --non-trivial
lemma new_lemma_111610 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_111611 (h0 : functor.add_const (ordered_comm_monoid (complete_distrib_lattice Type)) linarith.comp) : @has_exists_mul_of_le.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (complete_distrib_lattice.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_111612 (h1 : topological_space (has_lt string.iterator_imp)) : path_connected_space (has_lt string.iterator_imp) := sorry --non-trivial
lemma new_lemma_111613 (h0 : has_mul ereal -> has_mul ereal -> Prop) : is_total (has_mul ereal) h0 := sorry --non-trivial
lemma new_lemma_111614 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (linear_ordered_add_comm_group char)) := sorry --non-trivial
lemma new_lemma_111615 (h0 : not (group (fintype string_imp) -> false)) : @is_cyclic.{0} (fintype.{0} string_imp) (@classical.by_contradiction'.{1} (group.{0} (fintype.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_111616 (h0 : filter (id (semiring congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_111617 (h0 : group (has_Inf (sub_neg_monoid real))) : group.fg (has_Inf (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_111618 (h0 : not (filter linarith.ineq -> false)) : is_countably_spanning (filter.limsup (classical.by_contradiction' h0)) := sorry --non-trivial
lemma new_lemma_111619 (h0 : topological_space (has_bot (has_Inf (ordered_comm_monoid (has_Inf (has_Inf (has_Inf pos))))))) : totally_separated_space (has_bot (has_Inf (ordered_comm_monoid (has_Inf (has_Inf (has_Inf pos)))))) := sorry --non-trivial
lemma new_lemma_111620 (h0 : ring to_additive.value_type) : rank_condition to_additive.value_type := sorry --non-trivial
lemma new_lemma_111621 (h0 : topological_space (has_nndist (has_add (comm_group (has_to_string environment.implicit_infer_kind))))) : normal_space (has_nndist (has_add (comm_group (has_to_string environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_111622 (h0 : functor.add_const (group (has_nndist name)) pos) : @is_simple_group.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_111623 (h2 : add_group (uniform_space string_imp)) : is_add_cyclic (uniform_space string_imp) := sorry --non-trivial
lemma new_lemma_111624 (h0 : ring (has_top (has_nnnorm (has_inv fun_info)))) : rank_condition (has_top (has_nnnorm (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_111625 (h0 : topological_space (dlist (comm_ring (random_gen to_additive.value_type)))) : irreducible_space (dlist (comm_ring (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_111626 (h0 : functor.add_const (ordered_add_comm_monoid (canonically_ordered_monoid linarith.comp)) linarith.comp) : @archimedean.{0} (canonically_ordered_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (canonically_ordered_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_111627 (h0 : functor.add_const (group (finset linarith.comp)) pos) : @normalizer_condition.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_111628 (h0 : topological_space (option unsigned)) : topological_space.separable_space (option unsigned) := sorry --non-trivial
lemma new_lemma_111629 (h0 : filter (add_left_cancel_monoid linarith.comp_source)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_111630 (h0 : topological_space (option empty)) : loc_path_connected_space (option empty) := sorry --non-trivial
lemma new_lemma_111631 (h0 : topological_space (comm_group (add_comm_monoid (add_comm_monoid Type)))) : discrete_topology (comm_group (add_comm_monoid (add_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_111632 (h0 : set (has_div (has_nnnorm string.iterator_imp))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_111633 (h0 : functor.add_const (ordered_add_comm_monoid (non_assoc_semiring empty)) unsigned) : @archimedean.{0} (non_assoc_semiring.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (non_assoc_semiring.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_111634 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_111635 (h1 : not (monoid (has_top congr_arg_kind) -> false)) : @monoid.fg.{0} (has_top.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (monoid.{0} (has_top.{0} congr_arg_kind)) h1)  := sorry --non-trivial
lemma new_lemma_111636 (h0 : monoid (with_bot (has_inv (random_gen fun_info)))) : monoid.fg (with_bot (has_inv (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_111637 (h0 : topological_space (complete_linear_order (semiring (semiring empty)))) : totally_disconnected_space (complete_linear_order (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_111638 (h0 : ordered_comm_monoid (pseudo_metric_space pos)) : has_exists_mul_of_le (pseudo_metric_space pos) := sorry --non-trivial
lemma new_lemma_111639 (h0 : complete_lattice (with_bot (has_inv (has_inv (has_inv linarith.comp_source))))) : is_compactly_generated (with_bot (has_inv (has_inv (has_inv linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_111640 (h0 : functor.add_const (functor.add_const (complete_lattice linarith.comp) pos) (has_neg Type)) : @complete_lattice.is_Sup_finite_compact.{0} linarith.comp (@functor.add_const.run.{0 0} (complete_lattice.{0} linarith.comp) pos (@functor.add_const.run.{0 1} (functor.add_const.{0 0} (complete_lattice.{0} linarith.comp) pos) (has_neg.{1} Type) h0))  := sorry --non-trivial
lemma new_lemma_111641 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_111642 (h0 : topological_space (add_cancel_monoid (option (option (ordered_comm_group congr_arg_kind))))) : discrete_topology (add_cancel_monoid (option (option (ordered_comm_group congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_111643 (h0 : ring (with_bot (has_top (random_gen num)))) : rank_condition (with_bot (has_top (random_gen num))) := sorry --non-trivial
lemma new_lemma_111644 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_111645 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group empty))) : @totally_disconnected_space.{0} (normed_group.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_111646 (h0 : topological_space (ring num)) : path_connected_space (ring num) := sorry --non-trivial
lemma new_lemma_111647 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_111648 (h0 : group (normed_lattice_add_comm_group (has_add (has_add (has_Inf (has_add linarith.comp)))))) : group.fg (normed_lattice_add_comm_group (has_add (has_add (has_Inf (has_add linarith.comp))))) := sorry --non-trivial
lemma new_lemma_111649 (h0 : uniform_space (has_inter empty)) : complete_space (has_inter empty) := sorry --non-trivial
lemma new_lemma_111650 (h0 : has_mem.mem (normed_group linarith.comp) has_emptyc.emptyc) : @t0_space.{0} (normed_group.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_111651 (h0 : add_group (add_left_cancel_semigroup (option empty))) : is_add_cyclic (add_left_cancel_semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_111652 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_111653 (h0 : functor.add_const (function.extfun (Type 1) list) pos) : list.nodup (function.extfun_app (functor.add_const.run h0) (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_111654 (h0 : function.extfun Type ring) : @rank_condition.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_111655 (h0 : topological_space (finset (finset (has_Inf Type)))) : preirreducible_space (finset (finset (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_111656 (h0 : uniform_space (uniform_space (uniform_space linarith.ineq))) : complete_space (uniform_space (uniform_space linarith.ineq)) := sorry --non-trivial
lemma new_lemma_111657 (h0 : topological_space (id fun_info)) : discrete_topology (id fun_info) := sorry --non-trivial
lemma new_lemma_111658 (h0 : uniform_space (normed_group (has_top (has_top fun_info)))) : complete_space (normed_group (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_111659 (h0 : has_mem.mem (random_gen congr_arg_kind) has_emptyc.emptyc) : @is_add_cyclic.{0} (random_gen.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type add_group.{0} (random_gen.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_111660 (h0 : add_group (ordered_comm_monoid (has_add real))) : is_add_cyclic (ordered_comm_monoid (has_add real)) := sorry --non-trivial
lemma new_lemma_111661 (h0 : topological_space (has_pos_part (has_pos_part linarith.comp))) : discrete_topology (has_pos_part (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_111662 (h0 : group (ordered_comm_ring (has_pos_part linarith.comp))) : group.fg (ordered_comm_ring (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_111663 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_111664 (h0 h2 : list fun_info) : list.is_infix h0 h2 := sorry --non-trivial
lemma new_lemma_111665 (h0 : functor.add_const (cancel_comm_monoid_with_zero (finset environment.implicit_infer_kind)) linarith.comp) : @unique_factorization_monoid.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (finset.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_111666 (h0 : function.extfun Type group) : @group.fg.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_111667 (h0 : functor.add_const (topological_space (cancel_monoid name)) linarith.comp) : @preirreducible_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_111668 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (canonically_linear_ordered_monoid num)) := sorry --non-trivial
lemma new_lemma_111669 (h0 : functor.add_const (list (has_nndist pos)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_111670 (h0 : uniform_space (canonically_ordered_monoid (sub_neg_monoid Type))) : separated_space (canonically_ordered_monoid (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_111671 (h0 : ring (linear_ordered_comm_group (option empty))) : rank_condition (linear_ordered_comm_group (option empty)) := sorry --non-trivial
lemma new_lemma_111672 (h0 : semiring (measurable_space (has_norm fun_info))) : is_noetherian_ring (measurable_space (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_111673 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_111674 (h0 : ring (ring (option (option congr_arg_kind)))) : is_domain (ring (option (option congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_111675 (h0 : topological_space (add_cancel_monoid pos)) : totally_separated_space (add_cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_111676 (h0 : topological_space (has_top (semiring unsigned))) : discrete_topology (has_top (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_111677 (h0 : uniform_space (option (semiring (semiring empty)))) : separated_space (option (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_111678 (h0 : topological_space (add_comm_semigroup (mul_one_class fun_info))) : t0_space (add_comm_semigroup (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_111679 (h0 : finset (has_pos_part Type)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_111680 (h0 : monoid (ring (option (option empty)))) : monoid.fg (ring (option (option empty))) := sorry --non-trivial
lemma new_lemma_111681 (h0 : add_group num -> num) (h1 : functor.add_const (functor.add_const (uniform_space num) num) (semiring num)) : @separated_space.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_group.{0} num)) empty (@uniform_space.comap.{0 0} (add_group.{0} num) num h0 (@functor.add_const.run.{0 0} (uniform_space.{0} num) num (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (uniform_space.{0} num) num) (semiring.{0} num) h1))))  := sorry --non-trivial
lemma new_lemma_111682 (h0 : topological_space (has_Sup congr_arg_kind)) : loc_path_connected_space (has_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_111683 (h0 : topological_space (has_neg (has_neg_part (has_neg_part Type)))) : loc_path_connected_space (has_neg (has_neg_part (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_111684 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @t0_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_111685 (h0 : complete_lattice (has_ssubset (mul_one_class reducibility_hints))) : is_compactly_generated (has_ssubset (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_111686 (h0 : has_mem.mem (linear_ordered_semiring num) has_emptyc.emptyc) : @monoid.fg.{0} (linear_ordered_semiring.{0} num) (@finset.pi.empty.{1 0} Type monoid.{0} (linear_ordered_semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_111687 (h0 : functor.add_const (complete_lattice (canonically_ordered_comm_semiring empty)) unsigned) : @is_compactly_generated.{0} (canonically_ordered_comm_semiring.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_ordered_comm_semiring.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_111688 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_111689 (h0 : functor.add_const (semiring (canonically_ordered_comm_semiring Type)) environment.implicit_infer_kind) : @is_noetherian_ring.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (canonically_ordered_comm_semiring.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_111690 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (complete_linear_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_111691 (h0 : functor.add_const (group (has_neg Type)) (ring pos)) : @is_simple_group.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_neg.{1} Type)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_111692 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (linear_ordered_comm_ring.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_111693 (h0 : not (topological_space (plift congr_arg_kind) -> false)) : @t1_space.{1} (plift.{1} congr_arg_kind) (@classical.by_contradiction'.{2} (topological_space.{1} (plift.{1} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_111694 (h0 : filter (has_neg name)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_111695 (h0 : topological_space (semigroup (has_nndist name))) : normal_space (semigroup (has_nndist name)) := sorry --non-trivial
lemma new_lemma_111696 (h0 : topological_space (id num)) : irreducible_space (id num) := sorry --non-trivial
lemma new_lemma_111697 (h0 : function.extfun nat fin) : @is_compactly_generated.{0} (sub_neg_monoid.{0} name) (@matrix.vec_empty.{0} (complete_lattice.{0} (sub_neg_monoid.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_111698 (h0 : topological_space (has_add (ordered_ring (ordered_ring (has_neg linarith.comp))))) : sequential_space (has_add (ordered_ring (ordered_ring (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_111699 (h0 : group (normed_group (semiring (semiring congr_arg_kind)))) : normalizer_condition (normed_group (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_111700 (h0 : functor.add_const (ordered_add_comm_monoid (has_to_string unsigned)) unsigned) : @archimedean.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_to_string.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_111701 (h0 : functor.add_const (topological_space (has_neg_part environment.implicit_infer_kind)) linarith.comp) : @regular_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_111702 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (normed_group.{0} (random_gen.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (normed_group.{0} (random_gen.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_111703 (h0 : topological_space (linear_ordered_semiring linarith.comp)) : totally_separated_space (linear_ordered_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_111704 (h0 : cancel_comm_monoid_with_zero (linear_ordered_comm_ring (semiring (has_top empty)))) : unique_factorization_monoid (linear_ordered_comm_ring (semiring (has_top empty))) := sorry --non-trivial
lemma new_lemma_111705 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) Type) : @path_connected_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_111706 (h0 : ordered_add_comm_monoid (add_group unsigned)) : archimedean (add_group unsigned) := sorry --non-trivial
lemma new_lemma_111707 (h0 : set (omega_complete_partial_order (mul_one_class char))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_111708 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @totally_separated_space.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_111709 (h0 : ring (has_neg unsigned)) : rank_condition (has_neg unsigned) := sorry --non-trivial
lemma new_lemma_111710 (h0 : uniform_space (generalized_boolean_algebra linarith.comp)) : complete_space (generalized_boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_111711 (h1 : not (add_group (random_gen fun_info) -> false)) : @is_add_cyclic.{0} (random_gen.{0} fun_info) (@classical.by_contradiction'.{1} (add_group.{0} (random_gen.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_111712 (h0 : functor.add_const (finset (has_zero pos)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_111713 (h0 : topological_space (has_ssubset (random_gen (random_gen linarith.comp_source)))) : locally_compact_space (has_ssubset (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_111714 (h1 : topological_space (semiring congr_arg_kind)) : totally_separated_space (semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_111715 (h0 : function.extfun Type (functor.add_const (uniform_space ennreal))) : @separated_space.{0} ennreal (@functor.add_const.run.{0 0} (uniform_space.{0} ennreal) (option.{0} unsigned) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} ennreal)) h0 (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_111716 (h0 : filter (option empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_111717 (h0 : topological_space (add_cancel_monoid (ring (ring (finset name))))) : regular_space (add_cancel_monoid (ring (ring (finset name)))) := sorry --non-trivial
lemma new_lemma_111718 (h0 : topological_space (has_top (semiring linarith.comp_source))) : path_connected_space (has_top (semiring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_111719 (h0 : topological_space (has_dist (option (option ennreal)))) : path_connected_space (has_dist (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_111720 (h0 : topological_space (semiring (has_top linarith.comp_source))) : t0_space (semiring (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_111721 (h0 : uniform_space (complete_semilattice_Sup num)) : separated_space (complete_semilattice_Sup num) := sorry --non-trivial
lemma new_lemma_111722 (h0 : functor.add_const (add_monoid (canonically_ordered_comm_semiring name)) pos) : @add_monoid.fg.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (canonically_ordered_comm_semiring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_111723 (h1 : ring (has_add string_imp)) : is_domain (has_add string_imp) := sorry --non-trivial
lemma new_lemma_111724 (h0 : ring (with_bot (has_inv linarith.comp_source))) : rank_condition (with_bot (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_111725 (h0 : function.extfun Type topological_space) : @t0_space.{0} (encodable.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (encodable.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_111726 (h0 : ring string.iterator_imp) : is_field string.iterator_imp := sorry --non-trivial
lemma new_lemma_111727 (h0 : functor.add_const (topological_space (has_pos_part Type)) Type) : @loc_path_connected_space.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_pos_part.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_111728 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (comm_semigroup.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (comm_semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_111729 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @locally_compact_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_111730 (h0 : functor.add_const (group (ring Type)) name) : @is_simple_group.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_111731 (h0 : group (add_cancel_monoid to_additive.value_type)) : is_cyclic (add_cancel_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_111732 (h0 : add_cancel_comm_monoid (has_nnnorm char) -> add_cancel_comm_monoid (has_nnnorm char) -> Prop) : is_trans (add_cancel_comm_monoid (has_nnnorm char)) h0 := sorry --non-trivial
lemma new_lemma_111733 (h0 : has_le (mul_one_class (mul_one_class string.iterator_imp))) (h1 : mul_one_class (mul_one_class string.iterator_imp)) : is_max h1 := sorry --non-trivial
lemma new_lemma_111734 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_111735 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_emptyc.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_emptyc.{0} empty))  := sorry --non-trivial
lemma new_lemma_111736 (h0 : has_mem.mem (has_emptyc linarith.ineq) has_emptyc.emptyc) : @is_compactly_generated.{0} (has_emptyc.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_emptyc.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_111737 (h2 : function.extfun Type group) : @normalizer_condition.{0} string_imp (@function.extfun_app.{2 1} Type group.{0} h2 string_imp)  := sorry --non-trivial
lemma new_lemma_111738 (h0 : topological_space (has_pos_part (ordered_comm_ring (has_neg Type)))) : totally_separated_space (has_pos_part (ordered_comm_ring (has_neg Type))) := sorry --non-trivial
lemma new_lemma_111739 (h0 : filter real) (h1 : complete_lattice (filter.germ h0 congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (filter.germ h0 congr_arg_kind) := sorry --non-trivial
lemma new_lemma_111740 (h0 : topological_space (finset ennreal)) : irreducible_space (finset ennreal) := sorry --non-trivial
lemma new_lemma_111741 (h0 : ring (id (has_norm num))) : strong_rank_condition (id (has_norm num)) := sorry --non-trivial
lemma new_lemma_111742 (h0 : not (ring num -> false)) : @rank_condition.{0} num (@classical.by_contradiction'.{1} (ring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_111743 (h1 : topological_space char) (h2 : preorder char) : order_closed_topology char := sorry --non-trivial
lemma new_lemma_111744 (h0 : topological_space (canonically_ordered_comm_semiring (has_add Type))) : preirreducible_space (canonically_ordered_comm_semiring (has_add Type)) := sorry --non-trivial
lemma new_lemma_111745 (h0 : topological_space (random_gen (semiring (semiring num)))) : path_connected_space (random_gen (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_111746 (h0 : ring (cancel_monoid (option empty))) : is_principal_ideal_ring (cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_111747 (h0 : ring (topological_space (comm_ring char))) : is_domain (topological_space (comm_ring char)) := sorry --non-trivial
lemma new_lemma_111748 (h0 : topological_space (has_nndist (finset (finset pos)))) : regular_space (has_nndist (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_111749 (h2 : ring (has_neg_part char) -> Prop) (h3 : Exists (fun (x : ring (has_neg_part char)), h2 x)) : @strong_rank_condition.{0} (has_neg_part.{0} char) (@classical.some.{1} (ring.{0} (has_neg_part.{0} char)) h2 h3)  := sorry --non-trivial
lemma new_lemma_111750 (h0 : uniform_space (has_add (has_to_string (finset linarith.comp)))) : separated_space (has_add (has_to_string (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_111751 (h0 : fin has_zero.zero) : @normal_space.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_111752 (h0 : topological_space (has_Inf (finset linarith.comp))) : totally_separated_space (has_Inf (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_111753 (h0 : topological_space (add_comm_semigroup (add_comm_semigroup (mul_one_class enat)))) : path_connected_space (add_comm_semigroup (add_comm_semigroup (mul_one_class enat))) := sorry --non-trivial
lemma new_lemma_111754 (h0 : add_group (has_pos_part (sub_neg_monoid (has_Inf Type)))) : is_add_cyclic (has_pos_part (sub_neg_monoid (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_111755 (h0 : functor.add_const (list (has_pos_part pos)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_111756 (h0 : topological_space (has_Inf (ordered_comm_monoid real))) : totally_separated_space (has_Inf (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_111757 (h0 : ordered_add_comm_monoid (complete_distrib_lattice (has_add Type))) : archimedean (complete_distrib_lattice (has_add Type)) := sorry --non-trivial
lemma new_lemma_111758 (h0 : topological_space (semigroup empty)) : locally_compact_space (semigroup empty) := sorry --non-trivial
lemma new_lemma_111759 (h0 : topological_space (semigroup (option pos))) : path_connected_space (semigroup (option pos)) := sorry --non-trivial
lemma new_lemma_111760 (h0 : topological_space (has_emptyc (has_norm num))) : totally_disconnected_space (has_emptyc (has_norm num)) := sorry --non-trivial
lemma new_lemma_111761 (h0 : topological_space (semigroup (semigroup environment.implicit_infer_kind))) : sequential_space (semigroup (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_111762 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_111763 (h0 : complete_lattice (complete_semilattice_Sup to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (complete_semilattice_Sup to_additive.value_type) := sorry --non-trivial
lemma new_lemma_111764 (h0 : complete_lattice (comm_semigroup pos)) : is_atomistic (comm_semigroup pos) := sorry --non-trivial
lemma new_lemma_111765 (h0 : topological_space (ring (has_zero Type))) : discrete_topology (ring (has_zero Type)) := sorry --non-trivial
lemma new_lemma_111766 (h1 : topological_space (denumerable (has_ssubset (has_nnnorm char)))) : t0_space (denumerable (has_ssubset (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_111767 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @irreducible_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_111768 (h0 : complete_lattice (complete_linear_order (semiring unsigned))) : is_compactly_generated (complete_linear_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_111769 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (plift empty)) := sorry --non-trivial
lemma new_lemma_111770 (h0 : topological_space (has_neg (has_nndist environment.implicit_infer_kind))) : sequential_space (has_neg (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_111771 (h0 : semiring (with_bot linarith.comp_source)) (h1 : with_bot linarith.comp_source) : odd h1 := sorry --non-trivial
lemma new_lemma_111772 (h0 : topological_space (finset (has_to_string name))) : path_connected_space (finset (has_to_string name)) := sorry --non-trivial
lemma new_lemma_111773 (h0 : has_mem.mem (metric_space congr_arg_kind) has_emptyc.emptyc) : @locally_compact_space.{0} (metric_space.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (metric_space.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_111774 (h0 : functor.add_const (ordered_add_comm_monoid (add_cancel_monoid name)) unsigned) : @archimedean.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (add_cancel_monoid.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_111775 (h0 : uniform_space (has_emptyc empty)) : complete_space (has_emptyc empty) := sorry --non-trivial
lemma new_lemma_111776 (h0 : topological_space (generalized_boolean_algebra (sub_neg_monoid real))) : t0_space (generalized_boolean_algebra (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_111777 (h0 : ring (add_comm_monoid (option (option num)))) : is_domain (add_comm_monoid (option (option num))) := sorry --non-trivial
lemma new_lemma_111778 (h0 : topological_space (canonically_linear_ordered_monoid (has_neg pos))) : totally_disconnected_space (canonically_linear_ordered_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_111779 (h0 : list (boolean_algebra (ring Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_111780 (h1 : topological_space (random_gen (has_nnnorm fun_info))) (h2 : preorder (random_gen (has_nnnorm fun_info))) : order_topology (random_gen (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_111781 (h0 : has_mem.mem (complete_semilattice_Sup fun_info) has_emptyc.emptyc) : @complete_space.{0} (complete_semilattice_Sup.{0} fun_info) (@finset.pi.empty.{1 0} Type uniform_space.{0} (complete_semilattice_Sup.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_111782 (h0 : ordered_add_comm_monoid (ring (has_neg_part name))) : archimedean (ring (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_111783 (h0 : semiring (has_Inf (has_add (has_pos_part (has_pos_part pos))))) : is_noetherian_ring (has_Inf (has_add (has_pos_part (has_pos_part pos)))) := sorry --non-trivial
lemma new_lemma_111784 (h1 : complete_lattice (distrib_lattice fun_info)) : is_compactly_generated (distrib_lattice fun_info) := sorry --non-trivial
lemma new_lemma_111785 (h0 : complete_lattice (normed_group (has_ssubset to_additive.value_type))) : is_compactly_generated (normed_group (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_111786 (h0 : fin has_zero.zero) : @monoid.fg.{0} (has_Inf.{0} pos) (@matrix.vec_empty.{0} (monoid.{0} (has_Inf.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_111787 (h0 : uniform_space (has_add (complete_semilattice_Sup string_imp))) : complete_space (has_add (complete_semilattice_Sup string_imp)) := sorry --non-trivial
lemma new_lemma_111788 (h1 : add_group (non_unital_non_assoc_semiring linarith.comp_source)) : is_add_cyclic (non_unital_non_assoc_semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_111789 (h1 : uniform_space (distrib (random_gen char))) : complete_space (distrib (random_gen char)) := sorry --non-trivial
lemma new_lemma_111790 (h0 : functor.add_const (topological_space (ring linarith.comp)) environment.implicit_infer_kind) : @irreducible_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_111791 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (id (option unsigned))) := sorry --non-trivial
lemma new_lemma_111792 (h0 : topological_space (semi_normed_comm_ring (has_norm fun_info))) : t0_space (semi_normed_comm_ring (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_111793 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_111794 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) name) : @totally_separated_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_111795 (h0 : topological_space (has_div string.iterator_imp)) (h1 : preorder (has_div string.iterator_imp)) : order_topology (has_div string.iterator_imp) := sorry --non-trivial
lemma new_lemma_111796 (h0 : filter (measurable_space (has_top linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_111797 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_111798 (h0 : functor.add_const (group (ring pos)) (has_add Type)) : @normalizer_condition.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (ring.{0} pos)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_111799 (h0 : topological_space (linear_ordered_comm_ring num)) : discrete_topology (linear_ordered_comm_ring num) := sorry --non-trivial
lemma new_lemma_111800 (h1 : topological_space enat) : t0_space enat := sorry --non-trivial
lemma new_lemma_111801 (h0 : functor.add_const (ordered_comm_monoid (canonically_ordered_comm_semiring pos)) linarith.comp) : @has_exists_mul_of_le.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (canonically_ordered_comm_semiring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_111802 (h0 : complete_lattice (has_nnnorm ereal)) : is_compactly_generated (has_nnnorm ereal) := sorry --non-trivial
lemma new_lemma_111803 (h0 : finset (option (semiring congr_arg_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_111804 (h0 : ring (semiring (semiring linarith.comp))) : is_domain (semiring (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_111805 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) Type) : @separated_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) uniform_space.{1}) Type h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_111806 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (uniform_space.core unsigned)) := sorry --non-trivial
lemma new_lemma_111807 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_111808 (h0 : function.extfun (Type 1) ordered_comm_monoid) : @has_exists_mul_of_le.{1} (sub_neg_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} h0 (sub_neg_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_111809 (h0 : functor.add_const (list (add_left_cancel_semigroup unsigned)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_111810 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_111811 (h0 : semiring (canonically_ordered_comm_semiring linarith.comp)) : is_noetherian_ring (canonically_ordered_comm_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_111812 (h0 : add_group (has_ssubset enat)) (h1 : punit) : is_add_cyclic (has_ssubset enat) := sorry --non-trivial
lemma new_lemma_111813 (h0 : uniform_space (has_lt std_gen)) : complete_space (has_lt std_gen) := sorry --non-trivial
lemma new_lemma_111814 (h0 : ring (dlist (random_gen (random_gen to_additive.value_type)))) : is_domain (dlist (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_111815 (h0 : complete_lattice (has_nndist (has_nndist environment.implicit_infer_kind))) : is_compactly_generated (has_nndist (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_111816 (h0 : functor.add_const (ring (semigroup linarith.comp)) (has_to_string Type)) : @strong_rank_condition.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (semigroup.{0} linarith.comp)) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_111817 (h0 : functor.add_const (ring (has_add linarith.comp)) (has_pos_part Type)) : @strong_rank_condition.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (has_add.{0} linarith.comp)) (has_pos_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_111818 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} real.angle (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) real.angle)  := sorry --non-trivial
lemma new_lemma_111819 (h0 : ordered_comm_monoid (complete_distrib_lattice (has_Inf Type))) : has_exists_mul_of_le (complete_distrib_lattice (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_111820 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_111821 (h0 : topological_space (measurable_space.dynkin_system (semiring congr_arg_kind))) : path_connected_space (measurable_space.dynkin_system (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_111822 (h0 : functor.add_const (semiring (has_star congr_arg_kind)) congr_arg_kind) : @is_noetherian_ring.{0} (has_star.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (semiring.{0} (has_star.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_111823 (h1 : ring (normed_field (distrib string.iterator_imp))) : rank_condition (normed_field (distrib string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_111824 (h0 : ring (comm_group (has_add (add_comm_monoid (has_add name))))) : is_domain (comm_group (has_add (add_comm_monoid (has_add name)))) := sorry --non-trivial
lemma new_lemma_111825 (h1 : topological_space (has_add (comm_ring char))) : totally_disconnected_space (has_add (comm_ring char)) := sorry --non-trivial
lemma new_lemma_111826 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_111827 (h0 : ring (metric_space (has_norm linarith.comp))) : strong_rank_condition (metric_space (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_111828 (h0 : topological_space (has_add to_additive.value_type)) : path_connected_space (has_add to_additive.value_type) := sorry --non-trivial
lemma new_lemma_111829 (h1 : complete_lattice (add_monoid linarith.ineq)) : complete_lattice.is_Sup_finite_compact (add_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_111830 (h0 : Prop -> Prop) : classical.epsilon h0 := sorry --non-trivial
lemma new_lemma_111831 (h0 : ordered_add_comm_monoid (canonically_ordered_add_monoid (option (semiring empty)))) : archimedean (canonically_ordered_add_monoid (option (semiring empty))) := sorry --non-trivial
lemma new_lemma_111832 (h0 : not (topological_space (complete_semilattice_Sup empty) -> false)) : @irreducible_space.{0} (complete_semilattice_Sup.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_111833 (h0 : uniform_space (comm_semigroup (has_pos_part real))) : complete_space (comm_semigroup (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_111834 (h0 : functor.add_const (group (has_neg_part environment.implicit_infer_kind)) pos) : @normalizer_condition.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_neg_part.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_111835 (h0 : group (comm_group (has_to_string Type))) : is_simple_group (comm_group (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_111836 (h0 : add_group (canonically_linear_ordered_monoid (has_Inf (has_add Type)))) : is_add_cyclic (canonically_linear_ordered_monoid (has_Inf (has_add Type))) := sorry --non-trivial
lemma new_lemma_111837 (h2 : function.extfun Type group) : @normalizer_condition.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h2 (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_111838 (h0 : topological_space (boolean_algebra (has_Inf name))) : t0_space (boolean_algebra (has_Inf name)) := sorry --non-trivial
lemma new_lemma_111839 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_111840 (h0 : topological_space (has_norm (has_top (has_top fun_info)))) : path_connected_space (has_norm (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_111841 (h1 : char -> add_comm_semigroup ereal -> add_comm_semigroup ereal) (h3 : add_comm_semigroup ereal -> Prop) : contravariant char (add_comm_semigroup ereal) h1 (fun (h2 : add_comm_semigroup ereal), h3) := sorry --non-trivial
lemma new_lemma_111842 (h0 : ring (simple_graph (mul_one_class (has_ssubset reducibility_hints)))) : is_domain (simple_graph (mul_one_class (has_ssubset reducibility_hints))) := sorry --non-trivial
lemma new_lemma_111843 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_111844 (h0 : functor.add_const (topological_space (has_add Type)) (finset Type)) : @totally_separated_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_add.{1} Type)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_111845 (h0 : filter (measurable_space (has_norm (linear_ordered_semiring (has_top empty))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_111846 (h0 : ring (comm_semigroup (has_add Type))) : rank_condition (comm_semigroup (has_add Type)) := sorry --non-trivial
lemma new_lemma_111847 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_111848 (h0 : group (boolean_algebra (comm_group unsigned))) : group.fg (boolean_algebra (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_111849 (h0 : fin has_zero.zero) : @monoid.fg.{1} (canonically_linear_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) monoid.{1}) h0) (canonically_linear_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_111850 (h0 : functor.add_const (topological_space (has_add linarith.comp)) (has_to_string Type)) : @regular_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} linarith.comp)) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_111851 (h1 : group (linear_ordered_add_comm_group string_imp)) : is_cyclic (linear_ordered_add_comm_group string_imp) := sorry --non-trivial
lemma new_lemma_111852 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (omega_complete_partial_order.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (omega_complete_partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_111853 (h0 : ring (ordered_ring empty)) : is_field (ordered_ring empty) := sorry --non-trivial
lemma new_lemma_111854 (h0 : filter (ordered_cancel_add_comm_monoid pos)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_111855 (h0 : functor.add_const (topological_space (ring unsigned)) unsigned) : @loc_path_connected_space.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_111856 (h0 : list (ring (ring Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_111857 (h0 : topological_space (has_pos_part linarith.comp)) : preconnected_space (has_pos_part linarith.comp) := sorry --non-trivial
lemma new_lemma_111858 (h0 : list (measurable_space (has_inv (has_top (has_inv linarith.comp_source))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_111859 (h3 : complete_lattice (has_le string_imp)) : is_compactly_generated (has_le string_imp) := sorry --non-trivial
lemma new_lemma_111860 (h0 : uniform_space (has_pos_part (semi_normed_ring linarith.comp_source))) : complete_space (has_pos_part (semi_normed_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_111861 (h0 : group (ordered_cancel_add_comm_monoid (option unsigned))) : normalizer_condition (ordered_cancel_add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_111862 (h0 : uniform_space (semigroup congr_arg_kind)) : separated_space (semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_111863 (h0 : functor.add_const (group (boolean_algebra name)) (boolean_algebra linarith.comp)) : @group.fg.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} name)) (boolean_algebra.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_111864 (h0 : ring (topological_space (has_nnnorm (has_nnnorm fun_info)))) : is_domain (topological_space (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_111865 (h0 : uniform_space (boolean_algebra real)) : complete_space (boolean_algebra real) := sorry --non-trivial
lemma new_lemma_111866 (h0 : preorder std_gen) (h1 : topological_space (pred_order std_gen)) : preirreducible_space (pred_order std_gen) := sorry --non-trivial
lemma new_lemma_111867 (h0 : group (plift (semiring num))) : is_cyclic (plift (semiring num)) := sorry --non-trivial
lemma new_lemma_111868 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) name) : @normal_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_111869 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) Type) : @preirreducible_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_111870 (h0 : functor.add_const (finset (bin_tree congr_arg_kind)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_111871 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_111872 (h1 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} num (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h1) num)  := sorry --non-trivial
lemma new_lemma_111873 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @path_connected_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_111874 (h0 : uniform_space (ordered_comm_monoid (has_add (has_add linarith.comp)))) : complete_space (ordered_comm_monoid (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_111875 (h0 : filter (has_top (has_ssubset linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_111876 (h0 : functor.add_const (uniform_space (finset pos)) environment.implicit_infer_kind) : @separated_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (finset.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_111877 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_111878 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_111879 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_111880 (h0 : functor.add_const (monoid (boolean_algebra.core environment.implicit_infer_kind)) (has_neg pos)) : @monoid.fg.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_111881 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_111882 (h0 : topological_space (boolean_algebra.core (add_comm_monoid Type))) : path_connected_space (boolean_algebra.core (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_111883 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) environment.implicit_infer_kind) : @discrete_topology.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_111884 (h0 : functor.comp topological_space comm_group environment.implicit_infer_kind) : @discrete_topology.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_111885 (h0 : uniform_space (has_union (semiring empty))) : separated_space (has_union (semiring empty)) := sorry --non-trivial
lemma new_lemma_111886 (h0 : functor.add_const (ring (boolean_algebra linarith.comp)) pos) : @is_domain.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_111887 (h0 : finset (simple_graph unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_111888 (h2 : group empty) : group.fg empty := sorry --non-trivial
lemma new_lemma_111889 (h0 : topological_space (add_comm_monoid empty)) : totally_disconnected_space (add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_111890 (h0 : uniform_space (linear_ordered_semiring num)) : separated_space (linear_ordered_semiring num) := sorry --non-trivial
lemma new_lemma_111891 (h0 : list (semigroup (has_neg Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_111892 (h0 : ordered_add_comm_monoid (has_bot (has_add real))) : archimedean (has_bot (has_add real)) := sorry --non-trivial
lemma new_lemma_111893 (h0 : group (has_nndist (mul_zero_class (mul_zero_class pos)))) : is_simple_group (has_nndist (mul_zero_class (mul_zero_class pos))) := sorry --non-trivial
lemma new_lemma_111894 (h3 : not (topological_space (random_gen linarith.ineq) -> false)) : @totally_disconnected_space.{0} (random_gen.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} linarith.ineq)) h3)  := sorry --non-trivial
lemma new_lemma_111895 (h0 : topological_space (canonically_ordered_monoid (has_Inf pos))) : discrete_topology (canonically_ordered_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_111896 (h0 : functor.add_const (group (has_zero linarith.comp)) environment.implicit_infer_kind) : @is_simple_group.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_111897 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_111898 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) name) : @topological_space.separable_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_111899 (h0 : functor.add_const (monoid (has_add environment.implicit_infer_kind)) (has_neg Type)) : @monoid.fg.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (monoid.{0} (has_add.{0} environment.implicit_infer_kind)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_111900 (h0 : complete_lattice (has_to_string (has_neg_part pos))) : is_compactly_generated (has_to_string (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_111901 (h0 : functor.add_const (list (semigroup environment.implicit_infer_kind)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_111902 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @monoid.fg.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) monoid.{0}) (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_111903 (h1 : ring (normed_field (topological_space (normed_field reducibility_hints)))) : strong_rank_condition (normed_field (topological_space (normed_field reducibility_hints))) := sorry --non-trivial
lemma new_lemma_111904 (h0 : add_group (ordered_comm_ring (has_add (has_pos_part (has_add (has_Inf Type)))))) : is_add_cyclic (ordered_comm_ring (has_add (has_pos_part (has_add (has_Inf Type))))) := sorry --non-trivial
lemma new_lemma_111905 (h0 : ring (normed_group fun_info)) : is_domain (normed_group fun_info) := sorry --non-trivial
lemma new_lemma_111906 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_bot.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_111907 (h0 : fin has_zero.zero) : @is_cyclic.{0} (canonically_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (group.{0} (canonically_ordered_monoid.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_111908 (h0 : topological_space (has_inter (option (option (option ennreal))))) : t0_space (has_inter (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_111909 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_111910 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_111911 (h1 : set (has_compl (has_ssubset std_gen))) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_111912 (h0 : uniform_space (has_Inf (has_neg (has_Inf pos)))) : separated_space (has_Inf (has_neg (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_111913 (h0 : has_top string_imp -> Prop) : Exists h0 := sorry --non-trivial
lemma new_lemma_111914 (h0 : topological_space unsigned) : discrete_topology unsigned := sorry --non-trivial
lemma new_lemma_111915 (h0 : list (ordered_cancel_add_comm_monoid congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_111916 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @add_monoid.fg.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 add_monoid.{1}) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_111917 (h0 : group (ordered_comm_ring (has_add (sub_neg_monoid (has_bot real))))) : is_cyclic (ordered_comm_ring (has_add (sub_neg_monoid (has_bot real)))) := sorry --non-trivial
lemma new_lemma_111918 (h0 : list (normed_group to_additive.value_type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_111919 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_nndist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_nndist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_111920 (h0 : functor.add_const (ordered_comm_monoid (ordered_comm_ring pos)) (boolean_algebra.core (has_add linarith.comp))) : @has_exists_mul_of_le.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ordered_comm_ring.{0} pos)) (boolean_algebra.core.{0} (has_add.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_111921 (h0 : topological_space (has_ssubset (has_nnnorm reducibility_hints))) : t0_space (has_ssubset (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_111922 (h0 : topological_space (boolean_algebra.core (has_to_string ennreal))) : irreducible_space (boolean_algebra.core (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_111923 (h0 : finset unsigned) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_111924 (h0 : functor.add_const (functor.add_const (ordered_comm_monoid linarith.comp) linarith.comp) pos) : @has_exists_mul_of_le.{0} linarith.comp (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} linarith.comp) linarith.comp (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ordered_comm_monoid.{0} linarith.comp) linarith.comp) pos h0))  := sorry --non-trivial
lemma new_lemma_111925 (h0 : topological_space (has_Inf (has_add (has_pos_part (has_add pos))))) : locally_compact_space (has_Inf (has_add (has_pos_part (has_add pos)))) := sorry --non-trivial
lemma new_lemma_111926 (h0 : functor.add_const (ring (comm_group unsigned)) unsigned) : @is_principal_ideal_ring.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_111927 (h0 : ring (id congr_arg_kind)) : rank_condition (id congr_arg_kind) := sorry --non-trivial
lemma new_lemma_111928 (h0 : function.extfun (Type 1) topological_space) : @discrete_topology.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_111929 (h0 : not (topological_space (linear_ordered_add_comm_group environment.implicit_infer_kind) -> false)) : @path_connected_space.{0} (linear_ordered_add_comm_group.{0} environment.implicit_infer_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_add_comm_group.{0} environment.implicit_infer_kind)) h0)  := sorry --non-trivial
lemma new_lemma_111930 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_111931 (h0 : ring (topological_space (has_nnnorm reducibility_hints))) : is_domain (topological_space (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_111932 (h0 : function.extfun Type group) : @is_simple_group.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_111933 (h0 : functor.add_const (finset (linear_ordered_cancel_comm_monoid empty)) (semiring empty)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_111934 (h0 : functor.add_const (add_group (boolean_algebra unsigned)) (has_neg name)) : @is_add_cyclic.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (boolean_algebra.{0} unsigned)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_111935 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_111936 (h0 : ordered_add_comm_monoid (generalized_boolean_algebra real)) : archimedean (generalized_boolean_algebra real) := sorry --non-trivial
lemma new_lemma_111937 (h0 : ring (random_gen (has_inv (has_inv (has_inv (has_inv linarith.comp_source)))))) : is_domain (random_gen (has_inv (has_inv (has_inv (has_inv linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_111938 (h0 : ring (has_append (has_nnnorm fun_info))) : is_domain (has_append (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_111939 (h0 : topological_space (distrib_lattice (has_norm (has_inv (has_norm to_additive.value_type))))) : irreducible_space (distrib_lattice (has_norm (has_inv (has_norm to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_111940 (h0 : functor.add_const (topological_space (free_add_monoid unsigned)) unsigned) : @irreducible_space.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_111941 (h0 : uniform_space (normed_comm_ring (has_add (has_add (boolean_algebra linarith.comp))))) : complete_space (normed_comm_ring (has_add (has_add (boolean_algebra linarith.comp)))) := sorry --non-trivial
lemma new_lemma_111942 (h1 : group (has_emptyc linarith.comp)) : group.fg (has_emptyc linarith.comp) := sorry --non-trivial
lemma new_lemma_111943 (h2 : ring (linear_ordered_add_comm_group to_additive.value_type)) : is_domain (linear_ordered_add_comm_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_111944 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (comm_ring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (comm_ring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_111945 (h0 : add_monoid (normed_comm_ring (ring Type))) : add_monoid.fg (normed_comm_ring (ring Type)) := sorry --non-trivial
lemma new_lemma_111946 (h0 : function.extfun Type ring) : @rank_condition.{0} (add_left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_111947 (h0 : ring (metric_space fun_info)) : rank_condition (metric_space fun_info) := sorry --non-trivial
lemma new_lemma_111948 (h0 : add_group (simple_graph (mul_one_class environment.projection_info))) : is_add_cyclic (simple_graph (mul_one_class environment.projection_info)) := sorry --non-trivial
lemma new_lemma_111949 (h0 : functor.add_const (topological_space (comm_group Type)) Type) : @t0_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (comm_group.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_111950 (h0 : topological_space (measurable_space (has_top num))) : irreducible_space (measurable_space (has_top num)) := sorry --non-trivial
lemma new_lemma_111951 (h0 : complete_lattice (normed_group (has_norm to_additive.value_type))) : is_compactly_generated (normed_group (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_111952 (h0 : complete_lattice (id (has_norm (has_norm linarith.comp)))) : is_atomistic (id (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_111953 (h2 : ring (topological_space linarith.comp_source)) : is_domain (topological_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_111954 (h0 : functor.add_const (finset (ring linarith.comp)) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_111955 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_inv.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_inv.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_111956 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (normed_lattice_add_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_111957 (h0 : ring (finset (has_pos_part linarith.comp))) : rank_condition (finset (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_111958 (h0 : ring (has_Inf (has_neg Type))) : rank_condition (has_Inf (has_neg Type)) := sorry --non-trivial
lemma new_lemma_111959 (h0 : ring (has_norm (random_gen to_additive.value_type))) : strong_rank_condition (has_norm (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_111960 (h0 : list (dlist (random_gen (random_gen (random_gen (random_gen (random_gen string_imp))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_111961 (h0 : list (has_inv (normed_lattice_add_comm_group string_imp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_111962 (h1 : not (ring (comm_ring to_additive.value_type) -> false)) : @rank_condition.{0} (comm_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (comm_ring.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_111963 (h0 : functor.add_const (semiring (boolean_algebra.core empty)) num) : @is_noetherian_ring.{0} (boolean_algebra.core.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (boolean_algebra.core.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_111964 (h0 : topological_space (has_to_string (option pos))) : irreducible_space (has_to_string (option pos)) := sorry --non-trivial
lemma new_lemma_111965 (h0 : topological_space (has_add (has_add pos))) : regular_space (has_add (has_add pos)) := sorry --non-trivial
lemma new_lemma_111966 (h0 : functor.add_const (topological_space (ordered_comm_monoid pos)) Type) : @totally_separated_space.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_111967 (h0 : semiring (ordered_comm_monoid Type)) : is_noetherian_ring (ordered_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_111968 (h0 : uniform_space (has_top (random_gen (has_add (has_compl to_additive.value_type))))) : complete_space (has_top (random_gen (has_add (has_compl to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_111969 (h0 : topological_space (boolean_algebra.core (has_add name))) : totally_disconnected_space (boolean_algebra.core (has_add name)) := sorry --non-trivial
lemma new_lemma_111970 (h0 : topological_space (id (random_gen string_imp))) : t0_space (id (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_111971 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_111972 (h0 : topological_space (linear_ordered_field empty)) : totally_separated_space (linear_ordered_field empty) := sorry --non-trivial
lemma new_lemma_111973 (h0 : ring (has_compl (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) : rank_condition (has_compl (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_111974 (h0 : has_lt (has_ssubset (mul_one_class linarith.ineq))) : no_max_order (has_ssubset (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_111975 (h0 : topological_space (has_Inf Type)) : path_connected_space (has_Inf Type) := sorry --non-trivial
lemma new_lemma_111976 (h0 : topological_space (simple_graph unsigned)) : path_connected_space (simple_graph unsigned) := sorry --non-trivial
lemma new_lemma_111977 (h0 : complete_lattice (nondiscrete_normed_field (add_comm_semigroup enat))) : complete_lattice.is_Sup_finite_compact (nondiscrete_normed_field (add_comm_semigroup enat)) := sorry --non-trivial
lemma new_lemma_111978 (h0 : functor.add_const (ring (generalized_boolean_algebra Type)) name) : @is_principal_ideal_ring.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (generalized_boolean_algebra.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_111979 (h0 : complete_lattice (with_one (has_inv to_additive.value_type))) : is_compactly_generated (with_one (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_111980 (h0 : topological_space (ordered_comm_ring (has_neg name))) : irreducible_space (ordered_comm_ring (has_neg name)) := sorry --non-trivial
lemma new_lemma_111981 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} h0 (cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_111982 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_emptyc.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_emptyc.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_111983 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_111984 (h0 : functor.add_const (topological_space (comm_group ennreal)) unsigned) : @path_connected_space.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_111985 (h0 : topological_space (ordered_comm_group congr_arg_kind)) : t0_space (ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_111986 (h0 : list (random_gen char)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_111987 (h0 : functor.add_const (complete_lattice (has_to_string unsigned)) (option name)) : @is_compactly_generated.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} unsigned)) (option.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_111988 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) pos) : @archimedean.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) pos h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_111989 (h0 : add_group (cancel_monoid (has_add (has_add Type)))) : is_add_cyclic (cancel_monoid (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_111990 (h0 : complete_lattice (mul_zero_class (has_add name))) : is_atomistic (mul_zero_class (has_add name)) := sorry --non-trivial
lemma new_lemma_111991 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_111992 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_111993 (h0 : functor.add_const (ordered_comm_monoid (simple_graph linarith.comp)) linarith.comp) : @has_exists_mul_of_le.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (simple_graph.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_111994 (h0 : ring (topological_space reducibility_hints)) : rank_condition (topological_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_111995 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @locally_compact_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_111996 (h0 : functor.add_const (uniform_space (ordered_comm_monoid name)) Type) : @separated_space.{0} (ordered_comm_monoid.{0} name) (@functor.add_const.run.{0 1} (uniform_space.{0} (ordered_comm_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_111997 (h0 : topological_space (has_norm (has_top empty))) : irreducible_space (has_norm (has_top empty)) := sorry --non-trivial
lemma new_lemma_111998 (h0 : not (ring (metric_space empty) -> false)) : @is_domain.{0} (metric_space.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (metric_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_111999 (h0 : functor.add_const (add_monoid (canonically_linear_ordered_monoid pos)) ennreal) : @add_monoid.fg.{0} (canonically_linear_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (canonically_linear_ordered_monoid.{0} pos)) ennreal h0)  := sorry --non-trivial
